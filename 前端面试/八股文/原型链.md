## 原型，原型链理解

原型：每个JavaScript对象在创建时都会与另一个对象相关联， 这个对象就是他的原型，对象可以从原型上继承属性和方法

- 每个函数都有一个proptotype属性，指向该函数的原型对象
- 每个对象都有一个内部属性[[prototype]]，可以通过proto访问，指向创建它的构造函数的原型对象

原型链： 访问一个对象的属性或者方法时，对象本身没有这个属性，JavaScript会沿着原型链向上查找，这种层层查找形成了原型链



## 函数prototype

每个函数在创建时会自动拥有一个prototype属性，指向一个对象，当这个函数被用作构造函数时，创建的实例对象会自动关联到这个原型对象

- 只有函数才有prototype属性
- prototype对象初始包含一个constructor属性
- 实例通过proto链接到构造函数的prototype



## this的绑定

this的取决与函数的调用方式，而不是函数定义的位置

- 默认绑定
- 隐式绑定
- 显示绑定
- new





## 认识proxy

允许创建一个对象的代理，从而可以拦截并自定义对象的基本操作



## 认识reflect

提供操作对象的方法

不用操作原对象

可以改变this指向



## 解释JavaScript中的原型以及原型链，以及设计目的

原型是每个JavaScript对象都具有的一个内部属性，这个属性是一个指向另一个对象的引用

原型链是指对象通过原型属性所形成的链条，这种机制允许JavaScript对象实现继承和属性查找

new

- 在内存中创建一个新对象
- 将函数this绑定到新对象
- 对象的内部属性[[prototype]]属性会被赋值为该构造 函数的prototype属性
- 构造函数返回这个对象

原型链的终点是null





## 为什么需要this，有哪些绑定规则

提供一种在对象方法中引用当前对象的方式

this的绑定和定义的位置没有关系，和调用的方式和位置有关系，运行时被绑定

- 默认绑定
- 隐式绑定
- 显式绑定
- new



## 解释proxy如何工作的，通常用于哪些场景，与defineProperty

- target
- handler

设计目的

- defineProperty不是为了数据监听而创建的， 而是为了提供对对象的精细控制
- proxy设计目的就是代理一个对象，监听和拦截对象的操作

功能上

- defineProperty无法作用与整个对象，只能对单个属性进行拦截，而且拦截功能有限，不能拦截属性的删除，新增，遍历等操作
- proxy可创建一个代理对象，全面拦截对另一个对象的操作，提供了多种捕捉器

性能上

- defineProperty无需引入中间对象，对单一属性操作性能好，但是监听对象的大量属性或者整个对象，代码复杂度增加和性能开销大
- proxy、引入代理层，消耗一定性能，但是更加灵活，尤其需要全局监听对象行为



## Map和WeekMap有什么不同，它们的特性和适用场景

map

- 键值对集合，可以使用任何类型的值作为键
- 键是强引用的
- map是可迭代的

weakmap

- 键必须是对象
- 键是弱引用
- 不可迭代





