## vue的架构分析





## vue3的整体架构



## vue3构建过程



## 认识diff算法



## vue3的编译器



## keep-alive的作用



## 什么是调度器



## vue调度系统的架构



## nexttick的原理



## pinia源码的调试







# vue3相较于vue2引入了哪些主要的更新和改进

### composition API

- 解决vue2中option API的一些局限
- 允许开发者在功能逻辑上进行更好的组织和复用，使得代码在可读性，复用性和类型支持方面有显著提升
- 在复杂组件可以将逻辑代码拆分为更小的函数，有助于代码的维护和测试

### 性能优化

- 使用proxy的响应式系统，使得vue3能够高效的追踪数据的变化，并且支持对象和数组更深层次的监听
- vue3的虚拟DOM和编译器也进行了优化，减少了不必要的渲染和重绘，提高了性能

### Tree-shaking

- vue3是基于模块化的，并且更好的支持函数式开发，可以被打包工具更好的进行树摇优化
- 为使用的代码可以在打包时被移除，从而减少最终的文件大小，对于在性能和加载速度有要求的项目十分重要

### 更好的typescript支持

- vue3在设计之初就考虑到了ts的支持，框架内部实现和api设计都与ts高度兼容
- 开发者可以方便vue项目中使用ts，并且在开发过程中获得更好的类型推断和代码提示

### 新组件和特性

- fragments，teleport，suspense
- fragment允许一个组件返回多个根节点，teleport可以将组件渲染到DOM中的其他位置，suspense提供了更好的异步加载体验，

### 改善的内部架构

- 重写了框架核心，使得更加模块化和轻量化，提高了性能，也为未来的扩展和维护提供了更好的基础
- 模块化的设计让开发者可以按需引入特性，而不是加载整个框架，从而优化项目的打包体积



# 是什么使得vue3在性能上比vue2更有优势

### 基于proxy的响应式系统

- object.defineProperty，无法检测到对象属性的添加和删除，也对数组的索引和长度变化有一定限制
- proxy能够更能精确和高效的追踪对象和数组的所有变化。proxy允许拦截所有操作
- 减少了vue3处理复杂数据结构的性能损耗，特别是在需要大量数据操作的应用中

### 编译器优化

- vue3的编译器进行了全面优化，更加智能的生成渲染函数，引入了静态提升和Block等技术
- 静态提升： 指将不变的部分标记为静态节点，这样在后续的渲染中就不需要重复创建这些节点
- block可以将动态的节点放到dynamicchilld中，在后续的diff算法中只需要比较动态节点

### 更小的打包的体积

- vue3采用模块化设计，使得核心库和一些特性模块可以独立打包和按需加载
- 结合现代打包工具的树摇，可以去除未使用的代码，从而显著减少最终的打体积
- 更小的打包体积不仅减少了网络传输时间，还加快了浏览器的解析和执行速度，者对于首屏加载性能至关重要

### 优化的虚拟DOM

- vue3对虚拟DOM中的diff算法进行了改进，通过减少不必要的对比和重拍操作，使得渲染过程更加高效
- 引入了基于快的优化策略，可以将组件分成不同的渲染快，从而在更新时只需要更新变化的快，而不需要渲染整个组件

### 优化的依赖追踪

- vue3在依赖追踪和更新做了更细粒度的优化
- 新的响应式系统可以更加精确的追踪依赖关系，只有在真正需要更新的时候才进行重新计算和渲染，避免了vue2中的某些不必要的重渲染问题



# vue3中的composition API与React hook的异同

### 设计理念和语法差异

- vue3是以函数的方式来组合和复用逻辑，提供了setup函数作为组件的入口点，允许开发者在一个函数中组织所有的逻辑，包块状态声明吗，声明周期钩子，以及方法定义
- hooks时在现有函数组件基础上引入一组特殊的函数，用来在函数组件中管理状态和副作用
- 关键区别在于，compositionAPI是Vue特有的api设计，允许将逻辑代码模块化，复用，并能清晰的管理依赖，hooks则是通过将函数组件视为状态的宿主，来提供类似状态管理和生命周期的功能

### 响应式系统vs状态和副作用管理

- vue中响应式是框架的核心概念，可以使用ref等api来创建响应式的数据对象，当这些数据发生变化时，视图会自动更新
- hooks则是通过usestate管理状态，useEffect处理副作用
- vue的响应式系统是自动的，只要数据发生变化， 视图就会更新，而hooks则需要显示调用来更新状态和处理副作用，意味着在vue中不需要担心依赖管理的细节，react需要在使用useEffect时指定依赖数组来控制副作用的执行



# 虚拟DOM是什么，为什么要使用虚拟DOM

本质是一系列的JavaScript对象，组成树结构，用来映射真实的DOM 树结构

为什么要使用虚拟DOM

- 声明式开发
- 跨平台能力



# 虚拟DOM和真实DOM性能对比

理论上的性能对比

虚拟dom在性能和可维护之间找到平衡



# 虚拟DOM的解析过程是怎么样的

### createApp传入组件

### 组件被解析成render函数

### render函数返回一个VNode

### VNode经过patchComponent

### VNode经过patchElememnt

### 最终的DOM操作



# DIff算法的原理是什么，他是如何提高性能的

在没有diff算法的情况下，每当状态或者数据发生变化时，需要重新渲染整个页面的DOM树

- 每当数据发生变化，整个DOM树都会被移除，然后用新的内容重新构建和插入
- 非常耗时，还会导致页面的闪烁和不必要的重绘和重拍
- 对于大型和复杂的页面，每次重新构建DOM树的开销会随着节点数量的增加而显著增长，导致性能严重下降

diff算法的工作

- 通过比较前后两个虚拟DOM树，来找出最小的差异，然后仅对这些差异部分进行更新，而不是渲染整个DOM树
- 每次状态更新时，框架会生成新的虚拟DOM树，框架将新的虚拟DOM与旧的虚拟DOM树进行比较，找出不同之处

提高性能

- 避免不必要的DOM更新
- 局部更新
- 更高效的节点处理
- 静态呢容优化



# vue3的diff算法与vue2相比有什么改进

vue2的diff算法主要采用的双端比较

- vue2的diff算法会从头部和尾部开始比较新旧VNode列表，通过双端比较来找到需要移动或者更新的节点
- 先从头部对比，不匹配，再从尾部对比，最后处理中间部分

vue3的dff算法的改进

- 块级优化
- 静态提升
- patchFlag标记
- 更高效的diff算法，最长递增子序列



# vue中key的作用是什么， 为什么要绑定

作用

- key是一个特殊属性，用于标记虚拟DOM中的每个节点
- 帮助vue在diff算法中识别节点是否发生变化，或者节点是否需要被移动或者重用
- 没有key，vue会采用一种基于索引的方式来逐个对比新旧节点，导致不必要的DOM操作
- key提供的唯一标识，使得vue能够更准确的识别和操作节点，从而减少不必要的DOM操作

为什么要绑定key

- 主要原因提高vue中的diff算法性能
- key允许vue精确定位每个节点，减少不必要的删除和创建操作

源码

没有key，执行patchUnkeyedChildren方法

- vue通过索引来比较新旧子节点
- 从头到尾逐个对比节点，如果节点不匹配，就会移除旧节点并创建新节点
- 在节点顺序发生变化时，导致不必要的重建和移除操作，影响性能

有key，执行patchKeyedChilidren方法

- 从头部和尾部同步新旧节点，然后通过key进行快速定位
- 发现key匹配 的节点时，会将旧节点移动到新位置，或者插入新节点到正确的位置，避免不必要的DOM操作
- 通过key，vue可以在保证稳定序列的同时，优化节点的插入，删除，移动，确保最小的DOM操作次数



# 为什么不建议使用index作为key

主要key的作用与diff算法的优化效果有关

- 当节点的顺序发生变化时，index作为key会导致vue无法正确识别节点的变化
- key应该时唯一且稳定的，可以正确识别每个节点，即使节点的顺序或者内容发生变化



# vue中Object.defineProperty的缺点，以及Proxy的有点

缺点：

- 无法监听新增或者删除属性
- 无法监听数组的变化
- 劫持过程时递归的
- 设计初衷

proxy优点

- 更加完善的对象拦截操作
- 数组支持
- 性能优化
- 灵活性和可扩展性
- 代码简化



# vue3中的响应式系统是如何工程的

1. 创建响应式系统
2. 依赖收集
3. 副作用函数与ReactiveEffect
4. 触发更新



# vue在哪些情况下会进行依赖收集，机制是什么

依赖收集 的情况

1. 在响应式数据的读取操作时
2. 在组件渲染时
3. 在watch或者computed中读取响应式数据时





# vue中的watch和watchEffect有什么不同

都是通过调用dowatch函数实现的

- 与watch不同，watchEffect没有显示的数据源，也没有回调函数，efffect函数会自动依赖执行过程中访问的所有响应式数据

watch场景

- 精确控制数据变化的处理
- 获取新值和旧值
- 监听多个数据源

watchEffect场景

- 自动依赖收集和副作用管理
- 简单的响应式副作用



# vue中reactive和ref的区别，和它们使用场景

数据类型区别

- reactive用于将对象转换为响应式对象的API
- ref是用于创建包含单一响应式值的对象，适用于基本数据类型

内部实现机制

- reactive创建的响应式对象是通过Proxy进行全局代理的
- ref创建的是包含单一值的对象，这个对象的value属性是响应式的

使用场景

- 需要处理嵌套的对象或者数组，并且希望整个对象的所有层级属性都能自动变为响应式时，使用reactive
- 只需处理一个基本数据类型，ref更合适



# vue的双向绑定是如何工作的，简述基本原理



- 数据到视图
- 视图到数据



## 描述vue的模板编译过程

1. 解析
2. 转换
3. 代码生成



## vue3在编译过程中进行了哪些优化，以提高运行时性能

- 静态提升
- patchFlag优化
- Block和Dynamic CHildren
- 预字符串化静态内容
- 条件编译



# vue中template和jsx的区别

template优势

- 分离样式，结构，行为，代码具有可读性，易于理解
- 能够静态优化，提升性能

JSX

- 自由度
- 没法从编译层面进行优化
- 灵活





# 解释keep-alive组件的作用和实现机制

keep-alive内部维护了一个缓存对象，这个对象存储了被包裹组件的虚拟节点

- 组件第一渲染，会被正常挂载到DOM中
- 当组件被切换出去时，keep-alive并不会销毁他， 而是调用deactivate的方法，将组件从当前DOM中移除并放入一个隐藏容器中
- 当组件再次被激活时，keep-alive会通过activeate将其从隐藏容器中取出，并重新挂载到DOM中



# nextTick的原理时什么，有什么用

nextTick方法的原理跟vue的调度系统有关

vue的调度系统时通过任务队列来管理更新的，他会把数据变化触发的任务放到一个任务队列中，然后这些任务会被批量执行

nextTick的作用是在下一个DOM更新循环结束之后执行一个回调函数

- 利用离promise的then方法
- vue的更新任务已经在一个微任务队列中了， next Tick时在这些更新任务完成后，再往微任务队列中插入一个then回调



## vue中的数据对象属性变化时， 视图的更新是同步的还是异步的

- vue采用了一个异步队列机制来管理视图更新
- vue会在同一个时间循环结束前，批量执行这些更新操作
- 减少DOM操作次数， 提高应用的性能和响应速度



# pinia在状态管理中的作用

- 响应式数据管理
- 模块化和可扩展性
- 类型安全和易用性
- 调试和开发工具集成

与localStorage，全局对象的异同

- 用途
- 特性

# pinia的核心原理

- 在pinia中状态时通过vue的reactive和ref来创建的
- pinia允许定义多个store，每个store时一个独立的模块
- pinia的状态集中存储在一个相适应对象中，这个对象包含了所有store的状态



与vuex对比

- 弃用了mutations
- 无需创建复杂的包装器来支持typescript
- 无需动态添加Store
- 不再有嵌套结构的模块
- 不再有可命名的模块







































































