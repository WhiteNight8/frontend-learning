## 手写new操作符的代码实现

1. 创建一个新的空对象
2. 将新对象的原型的链接到构造函数的原型
3. 使用apply调用构造函数，将新对象作为this上下文传递，并传入剩余的参数
4. 如果构造函数返回一个对象，则返回这个对象，否则返回新创建的对象



```javascript
fucntion myNew(Constructor, ...ars) {
   //创建一个新的空对象
    const obj = {}
    
    // 将新对象的原型指向构造函数的原型
    Object.setPrototypeOf(obj,Contructor.prototype)
    
    // 使用apply调用构造函数，并传入新对象作为上下文，以及构造函数的参数
    const result = Contructor.apply(obj,args)
    
    // 如果构造函数返回的是对象类型，则返回该对象，否则返回新创建的对象
    return typeof result === 'object' && result !== null ? result :obj
   
}
```



## 手写call函数的代码实现

1. 在指定的对象上临时添加一个方法
2. 调用这个临时方法，并将指定的参数传递给他
3. 删除这个临时方法，恢复对象的状态
4. 返回函数的结果

```js
Function.prototype.mycall = function(context,...args) {
    // 如果context是null或者undefined，默认指向全局对象
    context = context || globalThis
    
    // 将当前函数(就是this)挂载到context对象的一个属性上，使用symbol避免原有属性被覆盖
    const fnSymbol = Symbol()
    context[fnSymbol] = this
    
    // 调用这个挂载的函数，并传入参数
    const result = context[fnSymbol](...args)
    
    //删除临时添加的属性
    delete context[fnSymbol]
    
    // 返回函数指向的结果
    return result
}
```



## 手写apply函数的代码实现

1. 检查传入的context是否为null或者undefined
2. 在context上临时添加一个方法，这个方法指向当前的函数this
3. 调用该临时方法，传入数组参数
4. 删除临时方法
5. 返回执行结果

```js
Function.prototype.myapply = function(context,argsArray) {
    
   context = context || globalThis
    
    const fnSymbol = Symbol()
   	context[fnSymbol] = this
    
    let result 
    if(Array.isArray(argsArray)) {
        resutl = context[fnSymbol](...argsArray)
    } else {
        result = context[fnSymbol]()
    }
    
    delete conext[fnSymbol]
    
    return result
}
```

## 

## 手写bind函数的代码实现

1. 绑定this
2. 参数传递
3. 构造函数绑定

```js
Function.prototype.myBind = function(context,...args) {
    //保存当前函数引用
    const self = this
    
    // 返回一个新的函数
    return function(...newArgs) {
        //如果该函数作为构造函数使用
        if(this instanceof self) {
            return new self(...args,..newArgs)
        }
        
        return self.apply(context,[...args,...newArgs])
    }
}
```





## 手写promise的代码实现











## 手写防抖函数的代码实现

1. 延时执行
2. 清除定时器
3. 立即执行

```js
function debounce(fn,delay) {
    let timer = null
    
    return function(...args) {
        const context = this
        if(timer) clearTimerout(timer)
        timer = setTimeout( () => {
            fn.apply(context,args)
        },delay)
    }
}
```



## 手写节流函数的代码实现

1. 间隔执行
2. 定时器版本
3. 时间戳版本

```js
function throttle(fn,delay) {
    let lastTime = 0
    return function(...args) {
        const now = Date.now()
        if(now - lastTime >= delay)  {
            lastTime = now
            fn.apply(this,args)
        }
    }
}
```







## 手写vue响应式原理的代码实现











## 手写浅拷贝函数的代码实现

1. 判断传入的是否为对象或者数组，不是直接返回原始值
2. 对象或者数组，创建相应的副本，然后遍历赋值

```js
function shallowCopy(obj) {
    if(typeof obj !== 'object' || object === null) {
        return obj
    }
    
    let copy = Array.isArray(obj) ? [] :{}
    
    for(let key of obj) {
        if(obj.hasOwnProperty(key)) {
            copy[key] = obj[key]
        }
    }
    return copy
}
```





## 手写深拷贝代码的的实现

深拷贝不仅会复制对象或者数组的第一层属性，还会递归的复制所有嵌套对象或者数组的属性

```js
function deepCopy(obj) {
    
    if(typeof obj !== 'object' || object === null) {
        return obj
    }
    
    let copy = Array.isArray(obj) ? [] :{}
    
    for(let key in obj) {
        if(obj.hasOwnProperty(key)) {
            copy[key] = deepCopy(obj[key])
        }
    }
    
    return copy
}
```





## 手写柯里化的代码实现

将一个接受多个参数的函数转换为接受一个单一参数的函数，并且返回一个接受剩下参数的函数的技术

```js
function curry(fn) {
    
    return function curried(...args) {
        
        if(args.length >= fn.length) {
            return fn.apply(this,args)
        } else {
            return function(...nextArgs) {
                return curried.apply(this,args.concat(nextArgs))
            }
        }
    }
}
```



## 

## 手写事件总线的代码实现

一种在不同组件或者模块之间传递消息的机制

```js
class EventBus {
    constructor() {
        this.events = {} // 存储事件及其监听器
    }
    
    // 注册事件监听器
    on(eventName, callback) {
        if(!this.events[eventName]) {
            this.events[eventName] = []
        }
        this.events[eventName].push(callback)
    }
    
    // 触发事件并传递参数
    emit(eventName, ...args) {
        if(this.events[eventName]) {
            this.events[eventName].forEach( callback => {
                callback(...args)
            })
        }
    }
    
    // 取消事件监听
    off(eventName, callback) {
        if(this.events[eventName]) {
            this.events[eventName] = this.events[eventName].filter( cb => cb!== callback)
        }
    }
    
    //只监听一次
    once(eventName,callback) {
        const onceCallback = (...args) => {
            callback(...args)
            this.off(eventName,onceCallback)
        }
        this.on(eventName,onceCallback)
    }
}
```

