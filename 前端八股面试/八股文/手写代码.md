## 手写new操作符的代码实现

1. 创建一个新的空对象
2. 将新对象的原型的链接到构造函数的原型
3. 使用apply调用构造函数，将新对象作为this上下文传递，并传入剩余的参数
4. 如果构造函数返回一个对象，则返回这个对象，否则返回新创建的对象



```javascript
fucntion myNew(Constructor, ...ars) {
   //创建一个新的空对象
    const obj = {}
    
    // 将新对象的原型指向构造函数的原型
    Object.setPrototypeOf(obj,Contructor.prototype)
    
    // 使用apply调用构造函数，并传入新对象作为上下文，以及构造函数的参数
    const result = Contructor.apply(obj,args)
    
    // 如果构造函数返回的是对象类型，则返回该对象，否则返回新创建的对象
    return typeof result === 'object' && result !== null ? result :obj
   
}
```



## 手写call函数的代码实现

1. 在指定的对象上临时添加一个方法
2. 调用这个临时方法，并将指定的参数传递给他
3. 删除这个临时方法，恢复对象的状态
4. 返回函数的结果

```js
Function.prototype.mycall = function(context,...args) {
    // 如果context是null或者undefined，默认指向全局对象
    context = context || globalThis
    
    // 将当前函数(就是this)挂载到context对象的一个属性上，使用symbol避免原有属性被覆盖
    const fnSymbol = Symbol()
    context[fnSymbol] = this
    
    // 调用这个挂载的函数，并传入参数
    const result = context[fnSymbol](...args)
    
    //删除临时添加的属性
    delete context[fnSymbol]
    
    // 返回函数指向的结果
    return result
}
```



## 手写apply函数的代码实现

1. 检查传入的context是否为null或者undefined
2. 在context上临时添加一个方法，这个方法指向当前的函数this
3. 调用该临时方法，传入数组参数
4. 删除临时方法
5. 返回执行结果

```js
Function.prototype.myapply = function(context,argsArray) {
    
   context = context || globalThis
    
    const fnSymbol = Symbol()
   	context[fnSymbol] = this
    
    let result 
    if(Array.isArray(argsArray)) {
        resutl = context[fnSymbol](...argsArray)
    } else {
        result = context[fnSymbol]()
    }
    
    delete conext[fnSymbol]
    
    return result
}
```

