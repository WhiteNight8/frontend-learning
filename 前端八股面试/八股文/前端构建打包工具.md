## 说明npm在安装一个包到底经历了什么过程

1. 解析package.json文件
2. 选择注册表
3. 依赖树解析
4. 缓存检查
5. 下载并安装包
6. 安装依赖
7. 执行生命周期脚本
8. 更新locl文件
9. 更新node_modules
10. 全局安装
11. 本地缓存更新



## 比较npm，cnpm，yarn，pnpm之间的主要差异

- npm最广泛
- cnpm国内专属
- yarn注重性能和一致性，适合团队协作和大型项目
- pnpm: 在性能和磁盘使用上具有明显优势，适合依赖复杂的项目和monorepo项目





## 解释pnpm的存储结构是如何减少磁盘空间并提高安装速度的

- 全局存储库
- 硬连接
- 符号连接
- 内容可寻址存储





## webpack的基本工作原理是什么，描述其打包过程

基本原理：通过一个或者多个入口文件，递归的构建依赖关系图，将项目的各个模块打包成一个或者多个文件

1. 初始化
2. 解析入口
3. 模块解析
4. 依赖图构建
5. 代码优化
6. 生成文件
7. 输出



## 如何配置webpack以 优化生产环境下的打包结果

- 设置模式为production
- 代码压缩
- tree shaking
- 分离css
- 代码分割
- 使用content hash
- 启用sourcemap
- 移除无用插件和polyfill
- scope hoisting
- 图片和文件优化



## 解释loader和plugin的区别及其在webpack中的作用

- loader： 用于将不同类型的文件转换为webpack可以识别的模块，主要作用与文件和模块的转换
- plugin： 扩展webpack的功能，参与整个构建流程， 可以进行代码优化，资源管理等等复杂操作



## 如何使用webpack来处理css和sass

使用loader



## webpack的热更新是如何工作的，原理是什么

HMR： 一种在不重新加载整个页面的情况下，实时更新页面上某个模块的机制

核心原理是在浏览器和webpack开发服务器之间建立websocket链接，代码发生变化时， webpack会通过这个连接将变化的模块推送到浏览器，浏览器只更新哪些被修改的模块，而不刷新整个页面

1. webpack dev server
2. 编译和通知阶段
3. 接受更新
4. 模块处理
5. 不影响应用状态



## 代码分割在webpack中是如何实现的

1. 静态导入
2. 动态导入
3. splitChunks插件
4. 懒加载
5. 可视化工具



## 如何配置webpack以利用缓存提高重新构建的速度

1. 启用持久化缓存
2. 利用babel-loader的缓存
3. 利用thread-loader



## tree shaking是什么，如何在webpack中使用



## webpack如何与Babel一起工作来转译es6代码的



## 解释webpack的模块热替换与传统全页面刷新之间的区别



## webpack构建流程中，有哪些关键的生命周期钩子



## 如何编写一个简单的webpack loader



## 解释webpack插件的工作原理以及如何自定义插件



## webpack中的依赖图是如何构建的



## 分析webpack打包速度慢的原因以及优化策略



## vite和webpack对比有哪些区别和优势



## vite的核心优势是什么，它是如何实现快速启动的



## 解释vite中的插件系统， 它是如何工作的



## vite项目如何配置代理来解决跨域请求问题



## 解释vite中的HMR原理



## vite如何优化依赖预构建过程



## 说一下vite的打包过程和静态资源处理方式



## babel的主要作用是什么，举例说明其如何工作的



## 如何配置babel以转移es6代码向后兼容的JavaScript代码



## 解释babel插件和预设的区别是什么和用法



## babel是如何处理jsx语法的



## babel的polyfill和transform-plugins有何区别



## 解释babel的编译过程中的ast的作用



## babel插件是如何工作的，描述编写自定义babel插件的基本步骤



