# Vue.js 前端面试题清单

## 1. Vue 基础知识

### 1.1 Vue 的核心概念

- 什么是 Vue.js？Vue.js 的核心特性有哪些？
- Vue 和其他前端框架（如 React、Angular）的主要区别是什么？
- Vue 组件的生命周期钩子有哪些？各有什么作用？
- Vue 组件如何进行数据通信？
- Vue 的模板语法有哪些？

参考资料：[Vue 官方文档 - 基础](https://cn.vuejs.org/guide/)

## 2. Vue 进阶知识

### 2.1 Vue 组件

- Vue 组件的 data 为什么必须是函数？
- Vue 组件如何使用 props 进行数据传递？
- 什么是 Vue 插槽（slot），如何使用？
- Vue 组件如何实现 v-model 双向绑定？
- Vue 组件如何实现父子通信、兄弟通信？

参考资料：[Vue 官方文档 - 组件基础](https://cn.vuejs.org/guide/components/)

### 2.2 Vue 指令与计算属性

- v-if 和 v-show 的区别是什么？
- Vue 中 computed 和 watch 有什么区别？
- Vue 中 key 的作用是什么？
- Vue 事件绑定有哪些方式？如何在 Vue 中使用事件修饰符？

## 3. Vue 生态系统

### 3.1 Vue Router

- Vue Router 是什么？
- Vue Router 有哪几种导航方式？
- Vue Router 的导航守卫有哪些？
- 如何在 Vue Router 中实现动态路由？

参考资料：[Vue Router 官方文档](https://router.vuejs.org/zh/)

### 3.2 Vuex（或 Pinia）

- Vuex 的核心概念有哪些？
- Vuex 和 Pinia 的区别是什么？
- Vuex 的 mutation 和 action 有什么区别？
- 如何在 Vue 组件中使用 Vuex？

参考资料：[Vuex 官方文档](https://vuex.vuejs.org/zh/) | [Pinia 官方文档](https://pinia.vuejs.org/)

## 4. Vue3 新特性

### 4.1 Composition API

- 什么是 Composition API？和 Options API 的区别是什么？
- setup() 函数的作用是什么？
- 如何使用 ref 和 reactive？
- 什么是 Vue3 的 Teleport？
- Vue3 中的 Provide/Inject 机制如何使用？

参考资料：[Vue3 官方文档](https://cn.vuejs.org/guide/introduction.html)

## 5. Vue 性能优化

- Vue 中如何进行懒加载？
- 如何优化 Vue 组件的渲染性能？
- Vue3 中的 Suspense 是什么？
- Vue 的响应式原理是怎样的？
- Vue3 中的 diff 算法做了哪些优化？

## 6. Vue 实战问题

- 如何封装一个通用的 Vue 组件？
- 如何在 Vue 项目中使用 TypeScript？
- 如何在 Vue 组件中使用第三方库（如 ECharts、Axios）？
- Vue SSR（服务端渲染）是什么？
- Vue3 如何进行状态管理？

## 7. 其他高级问题

- Vue 项目如何做 SEO 优化？
- Vue 项目如何做权限管理？
- Vue 项目如何做 PWA？
- Vue 项目如何配置 Webpack 或 Vite？

参考资料：[Vite 官方文档](https://vitejs.dev/)

------

这份清单涵盖了从基础到高级的 Vue.js 面试问题，适用于前端开发者备考 Vue 相关岗位。可以根据实际情况选择重点复习。



# React.js 前端面试题清单（包含 React 19）

## 1. React 基础知识

### 1.1 React 核心概念

- 什么是 React？React 的核心特性有哪些？
- React 和其他前端框架（如 Vue、Angular）的主要区别是什么？
- React 组件的生命周期方法有哪些？（包括 React 19 变化）
- React 组件如何进行数据通信？
- JSX 语法是什么？如何在 JSX 中使用表达式？

参考资料：[React 官方文档 - 基础](https://react.dev/learn)

## 2. React 进阶知识

### 2.1 组件和状态管理

- React 组件如何使用 props 进行数据传递？
- 什么是受控组件和非受控组件？
- React 如何管理组件状态？
- useState 和 useReducer 的区别是什么？
- 如何优化 React 组件的性能？

### 2.2 React 事件和渲染机制

- React 如何处理事件？
- 为什么 React 需要使用合成事件？
- React 中的 key 有什么作用？
- React 的 Diff 算法是如何工作的？
- React 19 对事件系统有哪些优化？

参考资料：[React 官方文档 - 组件](https://react.dev/learn#defining-a-component)

## 3. React 生态系统

### 3.1 React Router

- React Router 是什么？
- React Router 的路由模式有哪些？
- 如何在 React Router 中实现动态路由？
- React Router 6 和之前版本的主要区别是什么？

参考资料：[React Router 官方文档](https://reactrouter.com/en/main)

### 3.2 状态管理（Redux, Context, Zustand）

- Redux 的核心概念有哪些？
- Redux 和 Context API 的区别是什么？
- React 19 推荐的状态管理方案有哪些？
- 如何使用 Zustand 进行轻量级状态管理？

参考资料：[Redux 官方文档](https://redux.js.org/) | [Zustand 官方文档](https://zustand-demo.pmnd.rs/)

## 4. React 19 新特性

- React 19 中的 React Compiler 是什么？
- React 19 如何优化 Strict Mode？
- React 19 在 Suspense 和 Server Components 方面的改进有哪些？
- React 19 如何更好地支持并发模式？
- React 19 的 use 函数如何工作？

参考资料：[React 19 变更日志](https://react.dev/blog)

## 5. React 性能优化

- React 如何进行代码拆分（Code Splitting）？
- 如何使用 React.memo 进行组件优化？
- React 的 Reconciliation 机制是怎样的？
- 什么是 useMemo 和 useCallback，它们的作用是什么？
- React Server Components 如何提高应用性能？

## 6. React 实战问题

- 如何封装一个通用的 React 组件？
- 如何在 React 项目中使用 TypeScript？
- 如何在 React 组件中使用第三方库（如 Chart.js, Axios）？
- React SSR（服务端渲染）是什么？
- 如何在 React 中实现权限管理？

## 7. 其他高级问题

- React 项目如何做 SEO 优化？
- React 项目如何做 PWA？
- React 项目如何配置 Webpack 或 Vite？
- 如何使用 React 进行微前端架构？

参考资料：[Vite 官方文档](https://vitejs.dev/)

------

这份清单涵盖了从基础到高级的 React.js 面试问题，适用于前端开发者备考 React 相关岗位，特别是 React 19 版本的最新变化。



# 前端三剑客（HTML、CSS、JavaScript）面试题清单

## 1. HTML 相关问题

### 1.1 HTML 基础

- 什么是 HTML？HTML 的基本结构是什么？
- HTML5 和 HTML4 的区别有哪些？
- 语义化 HTML 是什么？为什么重要？
- 什么是 Doctype？它的作用是什么？
- HTML 中的 meta 标签有哪些常见用途？

### 1.2 HTML 进阶

- 什么是 HTML5 的 Web Storage？
- localStorage、sessionStorage 和 cookie 的区别是什么？
- iframe 的作用是什么？有哪些缺点？
- HTML5 中的新特性有哪些？（如 WebSockets、Canvas、Geolocation）
- HTML5 的 video 和 audio 标签如何使用？

参考资料：[MDN HTML 指南](https://developer.mozilla.org/zh-CN/docs/Web/HTML)

## 2. CSS 相关问题

### 2.1 CSS 基础

- CSS 选择器有哪些？
- CSS 的盒模型是什么？
- CSS 中的 position 属性有哪些值？
- display: none、visibility: hidden 和 opacity: 0 的区别是什么？
- 伪类和伪元素的区别是什么？

### 2.2 CSS 进阶

- Flexbox 和 Grid 布局的区别是什么？
- CSS3 的动画如何实现？
- 什么是响应式设计？如何使用 CSS 实现？
- rem、em、vh、vw 的区别是什么？
- 如何优化 CSS 以提高性能？

参考资料：[MDN CSS 指南](https://developer.mozilla.org/zh-CN/docs/Web/CSS)

## 3. JavaScript 相关问题

### 3.1 JavaScript 基础

- JavaScript 的基本数据类型有哪些？
- let、const 和 var 的区别是什么？
- == 和 === 的区别是什么？
- 什么是闭包（Closure）？它的作用是什么？
- 什么是事件循环（Event Loop）？

### 3.2 JavaScript 进阶

- 什么是原型链？
- call、apply 和 bind 的区别是什么？
- 什么是 Promise？如何使用？
- async/await 是如何工作的？
- 什么是防抖（debounce）和节流（throttle）？

### 3.3 ES6+ 相关

- ES6 的解构赋值如何使用？
- 什么是箭头函数？与普通函数的区别是什么？
- 什么是 Set 和 Map？它们的作用是什么？
- 什么是模块化（import/export）？
- JavaScript 中的浅拷贝和深拷贝的区别？

参考资料：[MDN JavaScript 指南](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript)

## 4. 前端综合问题

### 4.1 浏览器相关

- 什么是 DOM 和 BOM？
- 如何提升页面的渲染性能？
- 浏览器的回流（Reflow）和重绘（Repaint）是什么？
- 什么是跨域？如何解决跨域问题？

### 4.2 前端安全

- 什么是 XSS 攻击？如何防范？
- 什么是 CSRF 攻击？如何防范？
- HTTPS 如何保证数据安全？
- 前端如何存储用户信息，如何保证安全性？

参考资料：[OWASP Web 安全指南](https://owasp.org/www-project-top-ten/)

------

这份清单涵盖了 HTML、CSS 和 JavaScript 的核心概念及进阶知识，适用于前端开发者备考面试。可以根据需求重点复习。

# 最新前端面试问题清单（2025）

## 1. HTML & CSS 相关问题

- 介绍 HTML5 的新特性

  HTML5 引入了许多强大的新特性，显著增强了 Web 开发能力：

  - **语义化标签**：`<header>`, `<footer>`, `<article>`, `<section>`, `<nav>`, `<aside>` 等
  - **音频和视频支持**：原生 `<audio>` 和 `<video>` 标签
  - **Canvas 和 SVG**：强大的图形和动画能力
  - **本地存储**：localStorage 和 sessionStorage
  - **表单增强**：新的输入类型（email, date, tel 等）和属性（required, placeholder）
  - **WebSockets**：实时双向通信
  - **地理定位 API**：获取用户位置信息
  - **Web Workers**：在后台运行 JavaScript
  - **拖放 API**：原生拖放功能支持

- 语义化 HTML 及其作用

  语义化 HTML 是指使用具有特定含义的标签来构建网页结构，而不仅仅依赖于无语义的 `<div>` 和 `<span>`。

  **作用**：

  - **提升可访问性**：屏幕阅读器等辅助技术能更好地理解网页结构
  - **SEO 优化**：搜索引擎能更准确地解析页面内容和结构
  - **代码可维护性**：结构更清晰，便于开发者理解和维护
  - **未来兼容**：符合 Web 标准的发展方向
  - **设备适配**：有助于内容在不同设备上合理展示

- Flexbox 和 Grid 布局的对比及应用场景

  **Flexbox（弹性盒子）**：

  - **一维布局系统**：主要处理行或列的布局
  - **适用场景**：导航菜单、卡片列表、内容居中、等高列
  - **优势**：灵活调整元素大小，自动分配空间，容易对齐

  **Grid（网格）**：

  - **二维布局系统**：同时处理行和列
  - **适用场景**：整体页面布局、复杂的多维界面、图片画廊
  - **优势**：精确控制二维位置，区域划分，"模板"式布局

  **选择建议**：

  - 使用 Flexbox 处理单行/列内容的排列和对齐
  - 使用 Grid 处理整体页面结构和复杂多维布局

- CSS 预处理器（SASS/LESS）的作用

  CSS 预处理器扩展了 CSS 的功能，提供编程特性以增强 CSS 的编写体验：

  - **嵌套规则**：反映 HTML 结构的 CSS 规则嵌套
  - **变量**：存储和重用颜色、字体等值
  - **混合（Mixins）**：可重用的样式块，支持参数
  - **函数**：颜色处理、数学运算等
  - **条件语句和循环**：逻辑控制和批量生成样式
  - **模块化**：将样式分割为多个文件并导入
  - **继承**：扩展现有样式

  这些特性显著提高了 CSS 代码的可维护性、可扩展性和组织性。

- 如何实现响应式设计？（媒体查询、rem/vw/vh 等）

  响应式设计让网站能适应不同设备和屏幕尺寸：

  **核心技术**：

  - 媒体查询

    ：根据屏幕尺寸应用不同样式

    ```
    cssCopy@media (max-width: 768px) {
      /* 平板样式 */
    }
    @media (max-width: 480px) {
      /* 手机样式 */
    }
    ```

  - 相对单位

    ：

    - **rem**：相对于根元素字体大小
    - **em**：相对于父元素字体大小
    - **vw/vh**：视口宽度/高度的百分比
    - **%**：相对于父元素

  - **弹性图片**：`max-width: 100%; height: auto;`

  - **弹性布局**：使用 Flexbox 和 Grid 而非固定像素

  - **移动优先**：先为小屏设计，再逐步增强

- 现代 CSS 动画（@keyframes、animation、transition）

  **transition（过渡）**：

  - 属性从一个状态平滑过渡到另一个状态

  - **animation 和 @keyframes（关键帧动画）**：

    - 定义复杂的多步骤动画序列

  - **animation 属性**：

    - `animation-name`：关键帧名称
    - `animation-duration`：动画持续时间
    - `animation-timing-function`：速度曲线
    - `animation-delay`：延迟开始时间
    - `animation-iteration-count`：重复次数
    - `animation-direction`：播放方向
    - `animation-fill-mode`：完成后状态
    - `animation-play-state`：运行或暂停

    现代 CSS 动画配合 transform 和 opacity 属性变化能实现高性能、流畅的界面动效。

## 2. JavaScript & ES6+

- 我来详细解答这些 JavaScript 相关问题：

  ## ES6+ 语法特性

  ### 解构赋值

  ```javascript
  // 数组解构
  const [a, b] = [1, 2];
  
  // 对象解构
  const {name, age} = {name: 'Tom', age: 25};
  
  // 设置默认值
  const {title = 'Default'} = {};
  
  // 嵌套解构
  const {company: {address}} = {company: {address: 'Beijing'}};
  ```

  ### 箭头函数

  ```javascript
  // 基本语法
  const add = (a, b) => a + b;
  
  // 没有自己的this，继承上下文的this
  const obj = {
    name: 'Tom',
    sayLater() {
      setTimeout(() => {
        console.log(this.name); // 'Tom'
      }, 1000);
    }
  };
  ```

  ### Promise

  ```javascript
  const fetchData = () => {
    return new Promise((resolve, reject) => {
      // 异步操作
      if (success) {
        resolve(data);
      } else {
        reject(error);
      }
    });
  };
  
  fetchData()
    .then(data => console.log(data))
    .catch(error => console.error(error));
  ```

  ### async/await

  ```javascript
  const getData = async () => {
    try {
      const response = await fetch('https://api.example.com/data');
      const data = await response.json();
      return data;
    } catch (error) {
      console.error('Error:', error);
    }
  };
  ```

  ## JavaScript 事件循环机制

  JavaScript 是单线程语言，使用事件循环处理异步操作：

  1. **调用栈**：执行同步代码

  2. 任务队列

     ：

     - **宏任务(macro-task)**：setTimeout, setInterval, I/O, UI渲染等
     - **微任务(micro-task)**：Promise回调, process.nextTick等

  执行顺序：

  1. 执行同步代码（调用栈中的任务）
  2. 执行所有微任务
  3. 执行一个宏任务
  4. 重复步骤2和3

  ```javascript
  console.log('1'); // 同步
  
  setTimeout(() => {
    console.log('2'); // 宏任务
  }, 0);
  
  Promise.resolve().then(() => {
    console.log('3'); // 微任务
  });
  
  console.log('4'); // 同步
  
  // 输出顺序: 1, 4, 3, 2
  ```

  ## 深拷贝和浅拷贝

  ### 浅拷贝

  复制对象的第一层属性，但嵌套对象仍是引用关系。

  实现方式：

  ```javascript
  // 方法1：Object.assign()
  const copy1 = Object.assign({}, original);
  
  // 方法2：展开运算符
  const copy2 = {...original};
  
  // 方法3：Array.slice()（数组）
  const arrCopy = original.slice();
  ```

  ### 深拷贝

  递归复制对象的所有层级，创建全新的数据结构。

  实现方式：

  ```javascript
  // 方法1：JSON方法（有局限性，不能处理函数、正则等）
  const deepCopy1 = JSON.parse(JSON.stringify(original));
  
  // 方法2：递归实现
  function deepClone(obj) {
    if (obj === null || typeof obj !== 'object') return obj;
    
    const copy = Array.isArray(obj) ? [] : {};
    
    for (let key in obj) {
      if (obj.hasOwnProperty(key)) {
        copy[key] = deepClone(obj[key]);
      }
    }
    
    return copy;
  }
  
  // 方法3：使用第三方库如lodash
  // const deepCopy3 = _.cloneDeep(original);
  ```

  ## 防抖和节流

  ### 防抖(debounce)

  在触发事件后等待一定时间再执行函数，如果在等待时间内再次触发则重新计时。

  应用场景：

  - 搜索框输入查询（等用户输入完再发送请求）
  - 窗口大小调整时重新布局
  - 表单验证

  ```javascript
  function debounce(fn, delay) {
    let timer = null;
    return function(...args) {
      clearTimeout(timer);
      timer = setTimeout(() => {
        fn.apply(this, args);
      }, delay);
    };
  }
  
  const handleSearch = debounce(function(query) {
    // 发送API请求
  }, 300);
  ```

  ### 节流(throttle)

  在一定时间内只执行一次函数，无论事件触发多少次。

  应用场景：

  - 滚动事件处理（如懒加载）
  - mousemove事件
  - 游戏中的按键响应

  ```javascript
  function throttle(fn, interval) {
    let lastTime = 0;
    return function(...args) {
      const now = Date.now();
      if (now - lastTime >= interval) {
        fn.apply(this, args);
        lastTime = now;
      }
    };
  }
  
  const handleScroll = throttle(function() {
    // 处理滚动逻辑
  }, 200);
  ```

  ## 闭包

  闭包是指函数和其词法环境的组合，允许函数访问其外部作用域中的变量。

  特点：

  - 可以访问外部函数作用域中的变量
  - 这些变量会保存在内存中，不会被垃圾回收

  项目中的应用：

  - 创建私有变量和方法
  - 实现模块化
  - 实现柯里化（currying）
  - 实现记忆化（memoization）

  ```javascript
  // 私有变量示例
  function createCounter() {
    let count = 0; // 私有变量
    
    return {
      increment() {
        count++;
        return count;
      },
      decrement() {
        count--;
        return count;
      },
      getCount() {
        return count;
      }
    };
  }
  
  const counter = createCounter();
  counter.increment(); // 1
  counter.increment(); // 2
  counter.getCount();  // 2
  // 无法直接访问count变量
  ```

  ## call、apply 和 bind 的区别

  这三个方法都用于改变函数执行时的 `this` 指向，但具体使用方式不同：

  ### call

  立即调用函数，参数以逗号分隔列表形式传入。

  ```javascript
  function greet(greeting) {
    console.log(`${greeting}, ${this.name}`);
  }
  
  const person = { name: 'John' };
  greet.call(person, 'Hello'); // "Hello, John"
  ```

  ### apply

  立即调用函数，参数以数组形式传入。

  ```javascript
  function greet(greeting, punctuation) {
    console.log(`${greeting}, ${this.name}${punctuation}`);
  }
  
  const person = { name: 'John' };
  greet.apply(person, ['Hello', '!']); // "Hello, John!"
  ```

  ### bind

  返回一个新函数，不会立即执行，`this` 值被永久绑定到第一个参数。

  ```javascript
  function greet(greeting) {
    console.log(`${greeting}, ${this.name}`);
  }
  
  const person = { name: 'John' };
  const greetJohn = greet.bind(person);
  
  greetJohn('Hello'); // "Hello, John"
  // 即使更改上下文，bind绑定的this不会改变
  greetJohn.call({name: 'Tom'}); // 仍然是 "Hello, John"
  ```

  总结：

  - `call`：立即执行，参数列表
  - `apply`：立即执行，参数数组
  - `bind`：返回新函数，参数可分多次传入

## 3. React 相关问题（包含 React 19）

- React 组件的生命周期（React 19 的变化）
- useEffect 的依赖项问题及最佳实践
- React 状态管理方案（Redux、Context API、Zustand）
- React Server Components 是什么？
- React 事件系统及优化
- React 19 的新特性（Compiler、并发模式优化等）

## 4. Vue 相关问题（包含 Vue 3）

- Vue2 和 Vue3 的核心区别
- Composition API vs Options API
- Vue3 中的 Teleport 和 Suspense
- Vue3 响应式原理（Proxy vs Object.defineProperty）
- Vue 组件间通信方式
- Vue3 的 Pinia 状态管理

## 5. 前端性能优化

- 如何提高 Web 页面加载速度？
- 什么是 Webpack Tree Shaking？
- Code Splitting 和 Lazy Loading 的实现
- React/Vue 的虚拟 DOM 及 diff 算法优化
- 浏览器缓存机制（强缓存 vs 协商缓存）
- 如何减少页面的回流和重绘？

## 6. 前端安全

- XSS（跨站脚本攻击）及防御措施
- CSRF（跨站请求伪造）如何防范？
- CORS（跨域资源共享）及解决方案
- Content Security Policy（CSP）是什么？

## 7. 浏览器原理 & 网络

- 浏览器的渲染流程（从输入 URL 到页面展示）
- TCP/IP、HTTP/HTTPS 及 HTTP2/HTTP3 的区别
- 前端如何处理大数据渲染（虚拟滚动等）
- 浏览器的回流（Reflow）和重绘（Repaint）
- 前端如何优化 SEO？

## 8. Web 前端工程化

- Vite 与 Webpack 的区别
- 如何优化 Webpack 打包性能？
- 如何在项目中配置 ESLint + Prettier？
- CI/CD 在前端项目中的实践
- Monorepo 和 Micro Frontend（微前端）的概念及应用

## 9. AI 赋能前端开发

- AI 生成代码（GitHub Copilot、ChatGPT）对前端开发的影响
- 如何使用 AI 进行代码优化与调试？
- AI 与 Web 交互（语音识别、计算机视觉）

------

这份清单涵盖了最新的前端技术趋势和面试热点问题，适用于 2025 年前端面试准备。

