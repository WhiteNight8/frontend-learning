# Vue.js 前端面试题清单

## 1. Vue 基础知识

### 1.1 Vue 的核心概念

- 什么是 Vue.js？Vue.js 的核心特性有哪些？
- Vue 和其他前端框架（如 React、Angular）的主要区别是什么？
- Vue 组件的生命周期钩子有哪些？各有什么作用？
- Vue 组件如何进行数据通信？
- Vue 的模板语法有哪些？

参考资料：[Vue 官方文档 - 基础](https://cn.vuejs.org/guide/)

## 2. Vue 进阶知识

### 2.1 Vue 组件

- Vue 组件的 data 为什么必须是函数？
- Vue 组件如何使用 props 进行数据传递？
- 什么是 Vue 插槽（slot），如何使用？
- Vue 组件如何实现 v-model 双向绑定？
- Vue 组件如何实现父子通信、兄弟通信？

参考资料：[Vue 官方文档 - 组件基础](https://cn.vuejs.org/guide/components/)

### 2.2 Vue 指令与计算属性

- v-if 和 v-show 的区别是什么？
- Vue 中 computed 和 watch 有什么区别？
- Vue 中 key 的作用是什么？
- Vue 事件绑定有哪些方式？如何在 Vue 中使用事件修饰符？

## 3. Vue 生态系统

### 3.1 Vue Router

- Vue Router 是什么？
- Vue Router 有哪几种导航方式？
- Vue Router 的导航守卫有哪些？
- 如何在 Vue Router 中实现动态路由？

参考资料：[Vue Router 官方文档](https://router.vuejs.org/zh/)

### 3.2 Vuex（或 Pinia）

- Vuex 的核心概念有哪些？
- Vuex 和 Pinia 的区别是什么？
- Vuex 的 mutation 和 action 有什么区别？
- 如何在 Vue 组件中使用 Vuex？

参考资料：[Vuex 官方文档](https://vuex.vuejs.org/zh/) | [Pinia 官方文档](https://pinia.vuejs.org/)

## 4. Vue3 新特性

### 4.1 Composition API

- 什么是 Composition API？和 Options API 的区别是什么？
- setup() 函数的作用是什么？
- 如何使用 ref 和 reactive？
- 什么是 Vue3 的 Teleport？
- Vue3 中的 Provide/Inject 机制如何使用？

参考资料：[Vue3 官方文档](https://cn.vuejs.org/guide/introduction.html)

## 5. Vue 性能优化

- Vue 中如何进行懒加载？
- 如何优化 Vue 组件的渲染性能？
- Vue3 中的 Suspense 是什么？
- Vue 的响应式原理是怎样的？
- Vue3 中的 diff 算法做了哪些优化？

## 6. Vue 实战问题

- 如何封装一个通用的 Vue 组件？
- 如何在 Vue 项目中使用 TypeScript？
- 如何在 Vue 组件中使用第三方库（如 ECharts、Axios）？
- Vue SSR（服务端渲染）是什么？
- Vue3 如何进行状态管理？

## 7. 其他高级问题

- Vue 项目如何做 SEO 优化？
- Vue 项目如何做权限管理？
- Vue 项目如何做 PWA？
- Vue 项目如何配置 Webpack 或 Vite？

参考资料：[Vite 官方文档](https://vitejs.dev/)

------

这份清单涵盖了从基础到高级的 Vue.js 面试问题，适用于前端开发者备考 Vue 相关岗位。可以根据实际情况选择重点复习。



# React.js 前端面试题清单（包含 React 19）

## 1. React 基础知识

### 1.1 React 核心概念

- 什么是 React？React 的核心特性有哪些？
- React 和其他前端框架（如 Vue、Angular）的主要区别是什么？
- React 组件的生命周期方法有哪些？（包括 React 19 变化）
- React 组件如何进行数据通信？
- JSX 语法是什么？如何在 JSX 中使用表达式？

参考资料：[React 官方文档 - 基础](https://react.dev/learn)

## 2. React 进阶知识

### 2.1 组件和状态管理

- React 组件如何使用 props 进行数据传递？
- 什么是受控组件和非受控组件？
- React 如何管理组件状态？
- useState 和 useReducer 的区别是什么？
- 如何优化 React 组件的性能？

### 2.2 React 事件和渲染机制

- React 如何处理事件？
- 为什么 React 需要使用合成事件？
- React 中的 key 有什么作用？
- React 的 Diff 算法是如何工作的？
- React 19 对事件系统有哪些优化？

参考资料：[React 官方文档 - 组件](https://react.dev/learn#defining-a-component)

## 3. React 生态系统

### 3.1 React Router

- React Router 是什么？
- React Router 的路由模式有哪些？
- 如何在 React Router 中实现动态路由？
- React Router 6 和之前版本的主要区别是什么？

参考资料：[React Router 官方文档](https://reactrouter.com/en/main)

### 3.2 状态管理（Redux, Context, Zustand）

- Redux 的核心概念有哪些？
- Redux 和 Context API 的区别是什么？
- React 19 推荐的状态管理方案有哪些？
- 如何使用 Zustand 进行轻量级状态管理？

参考资料：[Redux 官方文档](https://redux.js.org/) | [Zustand 官方文档](https://zustand-demo.pmnd.rs/)

## 4. React 19 新特性

- React 19 中的 React Compiler 是什么？
- React 19 如何优化 Strict Mode？
- React 19 在 Suspense 和 Server Components 方面的改进有哪些？
- React 19 如何更好地支持并发模式？
- React 19 的 use 函数如何工作？

参考资料：[React 19 变更日志](https://react.dev/blog)

## 5. React 性能优化

- React 如何进行代码拆分（Code Splitting）？
- 如何使用 React.memo 进行组件优化？
- React 的 Reconciliation 机制是怎样的？
- 什么是 useMemo 和 useCallback，它们的作用是什么？
- React Server Components 如何提高应用性能？

## 6. React 实战问题

- 如何封装一个通用的 React 组件？
- 如何在 React 项目中使用 TypeScript？
- 如何在 React 组件中使用第三方库（如 Chart.js, Axios）？
- React SSR（服务端渲染）是什么？
- 如何在 React 中实现权限管理？

## 7. 其他高级问题

- React 项目如何做 SEO 优化？
- React 项目如何做 PWA？
- React 项目如何配置 Webpack 或 Vite？
- 如何使用 React 进行微前端架构？

参考资料：[Vite 官方文档](https://vitejs.dev/)

------

这份清单涵盖了从基础到高级的 React.js 面试问题，适用于前端开发者备考 React 相关岗位，特别是 React 19 版本的最新变化。



# 前端三剑客（HTML、CSS、JavaScript）面试题清单

## 1. HTML 相关问题

### 1.1 HTML 基础

- 什么是 HTML？HTML 的基本结构是什么？
- HTML5 和 HTML4 的区别有哪些？
- 语义化 HTML 是什么？为什么重要？
- 什么是 Doctype？它的作用是什么？
- HTML 中的 meta 标签有哪些常见用途？

### 1.2 HTML 进阶

- 什么是 HTML5 的 Web Storage？
- localStorage、sessionStorage 和 cookie 的区别是什么？
- iframe 的作用是什么？有哪些缺点？
- HTML5 中的新特性有哪些？（如 WebSockets、Canvas、Geolocation）
- HTML5 的 video 和 audio 标签如何使用？

参考资料：[MDN HTML 指南](https://developer.mozilla.org/zh-CN/docs/Web/HTML)

## 2. CSS 相关问题

### 2.1 CSS 基础

- CSS 选择器有哪些？
- CSS 的盒模型是什么？
- CSS 中的 position 属性有哪些值？
- display: none、visibility: hidden 和 opacity: 0 的区别是什么？
- 伪类和伪元素的区别是什么？

### 2.2 CSS 进阶

- Flexbox 和 Grid 布局的区别是什么？
- CSS3 的动画如何实现？
- 什么是响应式设计？如何使用 CSS 实现？
- rem、em、vh、vw 的区别是什么？
- 如何优化 CSS 以提高性能？

参考资料：[MDN CSS 指南](https://developer.mozilla.org/zh-CN/docs/Web/CSS)

## 3. JavaScript 相关问题

### 3.1 JavaScript 基础

- JavaScript 的基本数据类型有哪些？
- let、const 和 var 的区别是什么？
- == 和 === 的区别是什么？
- 什么是闭包（Closure）？它的作用是什么？
- 什么是事件循环（Event Loop）？

### 3.2 JavaScript 进阶

- 什么是原型链？
- call、apply 和 bind 的区别是什么？
- 什么是 Promise？如何使用？
- async/await 是如何工作的？
- 什么是防抖（debounce）和节流（throttle）？

### 3.3 ES6+ 相关

- ES6 的解构赋值如何使用？
- 什么是箭头函数？与普通函数的区别是什么？
- 什么是 Set 和 Map？它们的作用是什么？
- 什么是模块化（import/export）？
- JavaScript 中的浅拷贝和深拷贝的区别？

参考资料：[MDN JavaScript 指南](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript)

## 4. 前端综合问题

### 4.1 浏览器相关

- 什么是 DOM 和 BOM？
- 如何提升页面的渲染性能？
- 浏览器的回流（Reflow）和重绘（Repaint）是什么？
- 什么是跨域？如何解决跨域问题？

### 4.2 前端安全

- 什么是 XSS 攻击？如何防范？
- 什么是 CSRF 攻击？如何防范？
- HTTPS 如何保证数据安全？
- 前端如何存储用户信息，如何保证安全性？

参考资料：[OWASP Web 安全指南](https://owasp.org/www-project-top-ten/)

------

这份清单涵盖了 HTML、CSS 和 JavaScript 的核心概念及进阶知识，适用于前端开发者备考面试。可以根据需求重点复习。

# 最新前端面试问题清单（2025）

## 1. HTML & CSS 相关问题

- 介绍 HTML5 的新特性

  HTML5 引入了许多强大的新特性，显著增强了 Web 开发能力：

  - **语义化标签**：`<header>`, `<footer>`, `<article>`, `<section>`, `<nav>`, `<aside>` 等
  - **音频和视频支持**：原生 `<audio>` 和 `<video>` 标签
  - **Canvas 和 SVG**：强大的图形和动画能力
  - **本地存储**：localStorage 和 sessionStorage
  - **表单增强**：新的输入类型（email, date, tel 等）和属性（required, placeholder）
  - **WebSockets**：实时双向通信
  - **地理定位 API**：获取用户位置信息
  - **Web Workers**：在后台运行 JavaScript
  - **拖放 API**：原生拖放功能支持

- 语义化 HTML 及其作用

  语义化 HTML 是指使用具有特定含义的标签来构建网页结构，而不仅仅依赖于无语义的 `<div>` 和 `<span>`。

  **作用**：

  - **提升可访问性**：屏幕阅读器等辅助技术能更好地理解网页结构
  - **SEO 优化**：搜索引擎能更准确地解析页面内容和结构
  - **代码可维护性**：结构更清晰，便于开发者理解和维护
  - **未来兼容**：符合 Web 标准的发展方向
  - **设备适配**：有助于内容在不同设备上合理展示

- Flexbox 和 Grid 布局的对比及应用场景

  **Flexbox（弹性盒子）**：

  - **一维布局系统**：主要处理行或列的布局
  - **适用场景**：导航菜单、卡片列表、内容居中、等高列
  - **优势**：灵活调整元素大小，自动分配空间，容易对齐

  **Grid（网格）**：

  - **二维布局系统**：同时处理行和列
  - **适用场景**：整体页面布局、复杂的多维界面、图片画廊
  - **优势**：精确控制二维位置，区域划分，"模板"式布局

  **选择建议**：

  - 使用 Flexbox 处理单行/列内容的排列和对齐
  - 使用 Grid 处理整体页面结构和复杂多维布局

- CSS 预处理器（SASS/LESS）的作用

  CSS 预处理器扩展了 CSS 的功能，提供编程特性以增强 CSS 的编写体验：

  - **嵌套规则**：反映 HTML 结构的 CSS 规则嵌套
  - **变量**：存储和重用颜色、字体等值
  - **混合（Mixins）**：可重用的样式块，支持参数
  - **函数**：颜色处理、数学运算等
  - **条件语句和循环**：逻辑控制和批量生成样式
  - **模块化**：将样式分割为多个文件并导入
  - **继承**：扩展现有样式

  这些特性显著提高了 CSS 代码的可维护性、可扩展性和组织性。

- 如何实现响应式设计？（媒体查询、rem/vw/vh 等）

  响应式设计让网站能适应不同设备和屏幕尺寸：

  **核心技术**：

  - 媒体查询

    ：根据屏幕尺寸应用不同样式

    ```
    cssCopy@media (max-width: 768px) {
      /* 平板样式 */
    }
    @media (max-width: 480px) {
      /* 手机样式 */
    }
    ```

  - 相对单位

    ：

    - **rem**：相对于根元素字体大小
    - **em**：相对于父元素字体大小
    - **vw/vh**：视口宽度/高度的百分比
    - **%**：相对于父元素

  - **弹性图片**：`max-width: 100%; height: auto;`

  - **弹性布局**：使用 Flexbox 和 Grid 而非固定像素

  - **移动优先**：先为小屏设计，再逐步增强

- 现代 CSS 动画（@keyframes、animation、transition）

  **transition（过渡）**：

  - 属性从一个状态平滑过渡到另一个状态

  - **animation 和 @keyframes（关键帧动画）**：

    - 定义复杂的多步骤动画序列

  - **animation 属性**：

    - `animation-name`：关键帧名称
    - `animation-duration`：动画持续时间
    - `animation-timing-function`：速度曲线
    - `animation-delay`：延迟开始时间
    - `animation-iteration-count`：重复次数
    - `animation-direction`：播放方向
    - `animation-fill-mode`：完成后状态
    - `animation-play-state`：运行或暂停

    现代 CSS 动画配合 transform 和 opacity 属性变化能实现高性能、流畅的界面动效。

## 2. JavaScript & ES6+

- 我来详细解答这些 JavaScript 相关问题：

  ## ES6+ 语法特性

  ### 解构赋值

  ```javascript
  // 数组解构
  const [a, b] = [1, 2];
  
  // 对象解构
  const {name, age} = {name: 'Tom', age: 25};
  
  // 设置默认值
  const {title = 'Default'} = {};
  
  // 嵌套解构
  const {company: {address}} = {company: {address: 'Beijing'}};
  ```

  ### 箭头函数

  ```javascript
  // 基本语法
  const add = (a, b) => a + b;
  
  // 没有自己的this，继承上下文的this
  const obj = {
    name: 'Tom',
    sayLater() {
      setTimeout(() => {
        console.log(this.name); // 'Tom'
      }, 1000);
    }
  };
  ```

  ### Promise

  ```javascript
  const fetchData = () => {
    return new Promise((resolve, reject) => {
      // 异步操作
      if (success) {
        resolve(data);
      } else {
        reject(error);
      }
    });
  };
  
  fetchData()
    .then(data => console.log(data))
    .catch(error => console.error(error));
  ```

  ### async/await

  ```javascript
  const getData = async () => {
    try {
      const response = await fetch('https://api.example.com/data');
      const data = await response.json();
      return data;
    } catch (error) {
      console.error('Error:', error);
    }
  };
  ```

  ## JavaScript 事件循环机制

  JavaScript 是单线程语言，使用事件循环处理异步操作：

  1. **调用栈**：执行同步代码

  2. 任务队列

     ：

     - **宏任务(macro-task)**：setTimeout, setInterval, I/O, UI渲染等
     - **微任务(micro-task)**：Promise回调, process.nextTick等

  执行顺序：

  1. 执行同步代码（调用栈中的任务）
  2. 执行所有微任务
  3. 执行一个宏任务
  4. 重复步骤2和3

  ```javascript
  console.log('1'); // 同步
  
  setTimeout(() => {
    console.log('2'); // 宏任务
  }, 0);
  
  Promise.resolve().then(() => {
    console.log('3'); // 微任务
  });
  
  console.log('4'); // 同步
  
  // 输出顺序: 1, 4, 3, 2
  ```

  ## 深拷贝和浅拷贝

  ### 浅拷贝

  复制对象的第一层属性，但嵌套对象仍是引用关系。

  实现方式：

  ```javascript
  // 方法1：Object.assign()
  const copy1 = Object.assign({}, original);
  
  // 方法2：展开运算符
  const copy2 = {...original};
  
  // 方法3：Array.slice()（数组）
  const arrCopy = original.slice();
  ```

  ### 深拷贝

  递归复制对象的所有层级，创建全新的数据结构。

  实现方式：

  ```javascript
  // 方法1：JSON方法（有局限性，不能处理函数、正则等）
  const deepCopy1 = JSON.parse(JSON.stringify(original));
  
  // 方法2：递归实现
  function deepClone(obj) {
    if (obj === null || typeof obj !== 'object') return obj;
    
    const copy = Array.isArray(obj) ? [] : {};
    
    for (let key in obj) {
      if (obj.hasOwnProperty(key)) {
        copy[key] = deepClone(obj[key]);
      }
    }
    
    return copy;
  }
  
  // 方法3：使用第三方库如lodash
  // const deepCopy3 = _.cloneDeep(original);
  ```

  ## 防抖和节流

  ### 防抖(debounce)

  在触发事件后等待一定时间再执行函数，如果在等待时间内再次触发则重新计时。

  应用场景：

  - 搜索框输入查询（等用户输入完再发送请求）
  - 窗口大小调整时重新布局
  - 表单验证

  ```javascript
  function debounce(fn, delay) {
    let timer = null;
    return function(...args) {
      clearTimeout(timer);
      timer = setTimeout(() => {
        fn.apply(this, args);
      }, delay);
    };
  }
  
  const handleSearch = debounce(function(query) {
    // 发送API请求
  }, 300);
  ```

  ### 节流(throttle)

  在一定时间内只执行一次函数，无论事件触发多少次。

  应用场景：

  - 滚动事件处理（如懒加载）
  - mousemove事件
  - 游戏中的按键响应

  ```javascript
  function throttle(fn, interval) {
    let lastTime = 0;
    return function(...args) {
      const now = Date.now();
      if (now - lastTime >= interval) {
        fn.apply(this, args);
        lastTime = now;
      }
    };
  }
  
  const handleScroll = throttle(function() {
    // 处理滚动逻辑
  }, 200);
  ```

  ## 闭包

  闭包是指函数和其词法环境的组合，允许函数访问其外部作用域中的变量。

  特点：

  - 可以访问外部函数作用域中的变量
  - 这些变量会保存在内存中，不会被垃圾回收

  项目中的应用：

  - 创建私有变量和方法
  - 实现模块化
  - 实现柯里化（currying）
  - 实现记忆化（memoization）

  ```javascript
  // 私有变量示例
  function createCounter() {
    let count = 0; // 私有变量
    
    return {
      increment() {
        count++;
        return count;
      },
      decrement() {
        count--;
        return count;
      },
      getCount() {
        return count;
      }
    };
  }
  
  const counter = createCounter();
  counter.increment(); // 1
  counter.increment(); // 2
  counter.getCount();  // 2
  // 无法直接访问count变量
  ```

  ## call、apply 和 bind 的区别

  这三个方法都用于改变函数执行时的 `this` 指向，但具体使用方式不同：

  ### call

  立即调用函数，参数以逗号分隔列表形式传入。

  ```javascript
  function greet(greeting) {
    console.log(`${greeting}, ${this.name}`);
  }
  
  const person = { name: 'John' };
  greet.call(person, 'Hello'); // "Hello, John"
  ```

  ### apply

  立即调用函数，参数以数组形式传入。

  ```javascript
  function greet(greeting, punctuation) {
    console.log(`${greeting}, ${this.name}${punctuation}`);
  }
  
  const person = { name: 'John' };
  greet.apply(person, ['Hello', '!']); // "Hello, John!"
  ```

  ### bind

  返回一个新函数，不会立即执行，`this` 值被永久绑定到第一个参数。

  ```javascript
  function greet(greeting) {
    console.log(`${greeting}, ${this.name}`);
  }
  
  const person = { name: 'John' };
  const greetJohn = greet.bind(person);
  
  greetJohn('Hello'); // "Hello, John"
  // 即使更改上下文，bind绑定的this不会改变
  greetJohn.call({name: 'Tom'}); // 仍然是 "Hello, John"
  ```

  总结：

  - `call`：立即执行，参数列表
  - `apply`：立即执行，参数数组
  - `bind`：返回新函数，参数可分多次传入

## 3. React 相关问题（包含 React 19）

- 让我详细解答这些 React 相关问题：

  ## React 组件的生命周期（React 19 的变化）

  React 19（截至我的知识截止日期 2024 年 10 月）带来了生命周期的一些重要调整：

  ### 类组件生命周期

  类组件的生命周期方法在 React 19 中继续存在，但官方更推荐使用函数组件和 Hooks。传统生命周期方法包括：

  - **挂载阶段**：constructor → render → componentDidMount
  - **更新阶段**：shouldComponentUpdate → render → componentDidUpdate
  - **卸载阶段**：componentWillUnmount

  React 19 中弃用了一些生命周期方法，如 componentWillMount、componentWillReceiveProps 和 componentWillUpdate。

  ### 函数组件生命周期（通过 Hooks）

  React 19 更强化了函数组件的生命周期控制，主要通过 Hooks 实现：

  ```javascript
  function MyComponent() {
    // 等同于 constructor + componentDidMount 的组合
    useEffect(() => {
      // 组件挂载后执行
      return () => {
        // 组件卸载前执行（类似 componentWillUnmount）
      };
    }, []);
  
    // 等同于 componentDidUpdate（当依赖项变化时）
    useEffect(() => {
      // 依赖项变化后执行
    }, [dependency]);
  
    return <div>内容</div>;
  }
  ```

  React 19 为函数组件引入了更多优化，特别是在并发模式下的行为更为一致和可预测。

  ## useEffect 的依赖项问题及最佳实践

  useEffect 的依赖项是 React 中常见的问题源。以下是一些最佳实践：

  ### 问题

  1. **空依赖数组**：`useEffect(() => {}, [])`
     - 仅在组件挂载和卸载时执行
     - 可能导致闭包陷阱，使用到的状态永远是初始值
  2. **缺少依赖项**：没有列出所有使用的外部变量
     - 可能导致过时的状态引用
     - React 的 lint 规则会警告
  3. **过多依赖项**：包含不必要的依赖导致频繁执行

  ### 最佳实践

  ```javascript
  // 1. 使用函数式更新避免依赖项
  useEffect(() => {
    setCount(c => c + 1); // 不需要将 count 作为依赖项
  }, []);
  
  // 2. 使用 useCallback 和 useMemo 缓存函数和对象
  const memoizedCallback = useCallback(() => {
    doSomething(a, b);
  }, [a, b]);
  
  useEffect(() => {
    memoizedCallback();
  }, [memoizedCallback]); // 只有 a 或 b 变化时才会重新创建
  
  // 3. 使用 useRef 保存不需要触发重渲染的值
  const prevCountRef = useRef();
  useEffect(() => {
    prevCountRef.current = count;
  }, [count]);
  
  // 4. 分离关注点，使用多个 useEffect
  useEffect(() => {
    document.title = `Count: ${count}`;
  }, [count]);
  
  useEffect(() => {
    fetchUserData(userId);
  }, [userId]);
  
  // 5. 使用自定义 Hook 抽象复杂逻辑
  function useUserData(userId) {
    const [userData, setUserData] = useState(null);
    
    useEffect(() => {
      if (!userId) return;
      fetchUserData(userId).then(setUserData);
    }, [userId]);
    
    return userData;
  }
  ```

  React 19 对 useEffect 的处理更加智能，特别是在并发模式下能够更好地协调和调度 effects 的执行。

  ## React 状态管理方案

  ### Redux

  Redux 是一个独立的状态管理库，遵循单一数据源和不可变性原则。

  ```javascript
  // 创建 store
  const store = createStore(rootReducer);
  
  // 在组件中使用
  function Counter() {
    const count = useSelector(state => state.counter.value);
    const dispatch = useDispatch();
  
    return (
      <div>
        <button onClick={() => dispatch(increment())}>+</button>
        <span>{count}</span>
        <button onClick={() => dispatch(decrement())}>-</button>
      </div>
    );
  }
  ```

  优点：

  - 可预测性强
  - 开发者工具支持
  - 中间件系统强大

  缺点：

  - 配置复杂
  - 样板代码多

  ### Context API

  React 内置的状态管理解决方案，适合中小型应用。

  ```javascript
  // 创建 Context
  const CounterContext = createContext();
  
  // 提供者
  function CounterProvider({ children }) {
    const [count, setCount] = useState(0);
    return (
      <CounterContext.Provider value={{ count, setCount }}>
        {children}
      </CounterContext.Provider>
    );
  }
  
  // 在组件中使用
  function Counter() {
    const { count, setCount } = useContext(CounterContext);
    return (
      <div>
        <button onClick={() => setCount(count + 1)}>+</button>
        <span>{count}</span>
        <button onClick={() => setCount(count - 1)}>-</button>
      </div>
    );
  }
  ```

  优点：

  - 内置于 React
  - 简单易用
  - 不需要额外依赖

  缺点：

  - 可能导致不必要的重渲染
  - 不适合复杂状态管理

  ### Zustand

  轻量级的状态管理库，API 简洁，性能优秀。

  ```javascript
  // 创建 store
  const useStore = create((set) => ({
    count: 0,
    increment: () => set((state) => ({ count: state.count + 1 })),
    decrement: () => set((state) => ({ count: state.count - 1 })),
  }));
  
  // 在组件中使用
  function Counter() {
    const { count, increment, decrement } = useStore();
    return (
      <div>
        <button onClick={increment}>+</button>
        <span>{count}</span>
        <button onClick={decrement}>-</button>
      </div>
    );
  }
  ```

  优点：

  - 极简 API
  - 性能优秀
  - 不需要 Provider 包装
  - 可以用于部分状态管理

  缺点：

  - 生态系统不如 Redux 成熟

  React 19 增强了内置状态管理功能，使得在某些场景下可以减少对第三方状态管理库的依赖。

  ## React Server Components 是什么？

  React Server Components (RSC) 是 React 的一个重要创新，允许组件在服务器上渲染并在客户端进行激活。它们在 React 19 中得到了进一步的完善。

  ### 核心概念

  1. **服务器组件**：在服务器上渲染，不包含交互逻辑
  2. **客户端组件**：在客户端渲染，包含交互逻辑
  3. **共享组件**：可以在服务器和客户端都渲染

  ### 工作原理

  ```javascript
  // 服务器组件（默认）
  // UserProfile.js
  async function UserProfile({ userId }) {
    // 直接在服务器上获取数据，不需要客户端 API 调用
    const userData = await fetchUserData(userId);
    return <div>{userData.name}</div>;
  }
  
  // 客户端组件
  // "use client";
  import { useState } from 'react';
  
  function Counter() {
    const [count, setCount] = useState(0);
    return (
      <button onClick={() => setCount(count + 1)}>
        Count: {count}
      </button>
    );
  }
  ```

  ### 优势

  1. **减少客户端 JavaScript**：服务器组件不会发送 JS 到客户端
  2. **直接访问服务器资源**：可以直接访问数据库、文件系统等
  3. **自动代码分割**：客户端组件会自动代码分割
  4. **流式渲染**：可以逐步流式传输 UI

  ### 局限性

  1. **不支持浏览器 API**：服务器组件无法使用浏览器 API
  2. **不支持事件处理**：服务器组件无法添加事件处理器
  3. **不支持 useState 等 Hooks**：服务器组件无法使用客户端状态

  React 19 对 RSC 进行了更多优化，使其与 React 的其他部分更好地集成，并提供了更多工具来处理服务器与客户端组件之间的数据流。

  ## React 事件系统及优化

  React 实现了一个合成事件系统，它是 DOM 事件系统的跨浏览器包装器。

  ### 合成事件系统

  1. **事件委托**：React 将大多数事件处理程序附加到 document 上而不是实际的 DOM 节点
  2. **事件池**：重用事件对象以提高性能
  3. **跨浏览器一致性**：提供统一的 API

  ```javascript
  function handleClick(event) {
    // React 的事件对象是合成的
    event.preventDefault();
    console.log(event.target);
  }
  
  <button onClick={handleClick}>Click me</button>
  ```

  ### 事件优化

  1. **使用防抖和节流**：

  ```javascript
  import { useCallback } from 'react';
  import { debounce } from 'lodash';
  
  function SearchComponent() {
    const debouncedSearch = useCallback(
      debounce((term) => {
        fetchSearchResults(term);
      }, 300),
      []
    );
  
    return <input onChange={(e) => debouncedSearch(e.target.value)} />;
  }
  ```

  1. **使用事件委托**：

  ```javascript
  function TodoList({ todos, onTodoClick }) {
    return (
      <ul onClick={(e) => {
        if (e.target.tagName === 'LI') {
          const id = e.target.dataset.id;
          onTodoClick(id);
        }
      }}>
        {todos.map(todo => (
          <li key={todo.id} data-id={todo.id}>
            {todo.text}
          </li>
        ))}
      </ul>
    );
  }
  ```

  1. **使用 useTransition 处理低优先级事件**：

  ```javascript
  const [isPending, startTransition] = useTransition();
  
  function handleInputChange(e) {
    setInputValue(e.target.value);
    
    startTransition(() => {
      // 低优先级更新
      setSearchResults(performExpensiveSearch(e.target.value));
    });
  }
  ```

  React 19 对事件系统进行了优化，特别是在并发模式下的事件处理，使其更加高效和可预测。

  ## React 19 的新特性

  React 19 带来了许多重要的新特性和改进：

  ### React Compiler

  React 19 引入了编译器，可以自动优化 React 组件，减少不必要的重渲染。

  ```javascript
  // 编译前
  function Counter() {
    const [count, setCount] = useState(0);
    return (
      <div>
        <h1>Count: {count}</h1>
        <button onClick={() => setCount(count + 1)}>Increment</button>
      </div>
    );
  }
  
  // 编译后（概念性示例）
  function Counter() {
    const [count, setCount] = useState(0);
    return React.createElement(
      'div',
      null,
      React.memo(() => React.createElement('h1', null, 'Count: ', count)),
      React.memo(() => React.createElement(
        'button',
        { onClick: () => setCount(count + 1) },
        'Increment'
      ))
    );
  }
  ```

  编译器可以：

  - 自动识别不变的组件部分
  - 减少不必要的重渲染
  - 优化渲染性能

  ### 并发模式优化

  React 19 改进了并发模式，使其更加稳定和可用：

  1. **useTransition**：更好地控制状态更新的优先级

     ```javascript
     const [isPending, startTransition] = useTransition();
     
     function handleClick() {
       startTransition(() => {
         // 低优先级更新
         setTab('settings');
       });
     }
     ```

  2. **useDeferredValue**：延迟某些值的更新

     ```javascript
     const deferredQuery = useDeferredValue(query);
     ```

  3. **优化的 Suspense**：更好的加载状态处理

     ```javascript
     <Suspense fallback={<Spinner />}>
       <UserProfile userId={userId} />
     </Suspense>
     ```

  ### 其他新特性

  1. **Actions**：简化表单处理

     ```javascript
     function MyForm() {
       async function handleSubmit(formData) {
         // 直接处理表单数据
         const result = await submitForm(formData);
         // 处理结果
       }
       
       return <form action={handleSubmit}>...</form>;
     }
     ```

  2. **更好的 TypeScript 支持**：改进了泛型和类型推断

  3. **改进的 SSR 支持**：更好的服务器端渲染和水合

  4. **Asset Loading**：更好地处理资源加载

     ```javascript
     import { lazy } from 'react';
     const LazyComponent = lazy(() => import('./LazyComponent'));
     ```

  5. **文档组件**：专门用于静态内容的组件类型

  6. **改进的错误处理**：更好的错误边界和报告

  React 19 的这些新特性旨在提高应用性能、改善开发体验，并使 React 更加适应现代 web 应用的需求。

## 4. Vue 相关问题（包含 Vue 3）

- 我来详细比较 Vue2 和 Vue3 的核心区别以及这些相关概念：

  ## Vue2 和 Vue3 的核心区别

  ### 1. 响应式系统

  - **Vue2**：使用 Object.defineProperty 实现响应式，无法检测对象属性的添加和删除，需要使用 Vue.set() 或 this.$set()
  - **Vue3**：使用 Proxy 实现响应式，可以检测对象属性的添加和删除，无需特殊 API

  ### 2. API 设计

  - **Vue2**：主要使用 Options API，即通过 data、methods、computed 等选项组织代码
  - **Vue3**：推出 Composition API，允许使用函数形式组织代码逻辑，同时保留了 Options API

  ### 3. 性能优化

  - **Vue2**：组件级别的虚拟 DOM 重渲染
  - **Vue3**：引入了片段（Fragment）、静态节点提升、基于 Proxy 的响应式系统等优化，性能更佳

  ### 4. TypeScript 支持

  - **Vue2**：TypeScript 支持较弱，需要额外的类型声明
  - **Vue3**：使用 TypeScript 重写，提供更好的类型推断和支持

  ### 5. 组件创建

  - Vue2

    ：

    ```javascript
    Vue.component('my-component', {  data() { return { count: 0 } },  methods: { increment() { this.count++ } }})
    ```

  - Vue3

    ：

    ```javascript
    import { defineComponent, ref } from 'vue'const MyComponent = defineComponent({  setup() {    const count = ref(0)    const increment = () => count.value++    return { count, increment }  }})
    ```

  ### 6. 内置组件和功能

  - **Vue3 新增**：Teleport、Suspense、多根节点组件、组合式 API、响应式 API 等

  ## Composition API vs Options API

  ### Options API

  传统的 Vue 组件组织方式，通过 data、methods、computed 等选项组织代码：

  ```javascript
  export default {
    data() {
      return {
        user: { name: 'John', age: 30 },
        searchQuery: ''
      }
    },
    computed: {
      filteredUsers() {
        return this.users.filter(user => user.name.includes(this.searchQuery))
      }
    },
    methods: {
      fetchUsers() {
        // 获取用户数据
      }
    },
    mounted() {
      this.fetchUsers()
    }
  }
  ```

  **优点**：

  - 对新手友好，概念清晰
  - 代码组织跟随选项分类

  **缺点**：

  - 相关逻辑分散在不同选项中
  - 在大型组件中维护困难
  - 代码重用需要 mixins，可能导致命名冲突

  ### Composition API

  Vue3 引入的新 API，使用函数式方法组织代码：

  ```javascript
  import { ref, computed, onMounted } from 'vue'
  
  export default {
    setup() {
      // 用户相关逻辑
      const user = ref({ name: 'John', age: 30 })
      const searchQuery = ref('')
      
      const filteredUsers = computed(() => 
        users.value.filter(user => user.name.includes(searchQuery.value))
      )
      
      const fetchUsers = async () => {
        // 获取用户数据
      }
      
      onMounted(() => {
        fetchUsers()
      })
      
      return {
        user,
        searchQuery,
        filteredUsers,
        fetchUsers
      }
    }
  }
  ```

  **优点**：

  - 相关逻辑可以组织在一起
  - 更好的代码重用和组合
  - 更好的类型推断
  - 更小的生产包体积

  **缺点**：

  - 学习曲线相对陡峭
  - 需要理解响应式系统的工作原理

  ## Vue3 中的 Teleport 和 Suspense

  ### Teleport

  Teleport 允许将组件的一部分 DOM 移动到 Vue 应用之外的位置，比如 body 元素下：

  ```vue
  <template>
    <div>
      <h1>我的组件</h1>
      <!-- 这部分内容会被移动到 body 下 -->
      <teleport to="body">
        <div class="modal">
          <h2>这是一个模态框</h2>
          <button @click="closeModal">关闭</button>
        </div>
      </teleport>
    </div>
  </template>
  ```

  **应用场景**：

  - 模态框、对话框
  - 工具提示
  - 通知栏
  - 任何需要突破 CSS 上下文的情况

  ### Suspense

  Suspense 是一个内置组件，用于处理异步组件加载状态：

  ```vue
  <template>
    <suspense>
      <!-- 异步组件会在这里显示 -->
      <template #default>
        <async-component />
      </template>
      <!-- 加载中状态 -->
      <template #fallback>
        <div>Loading...</div>
      </template>
    </suspense>
  </template>
  ```

  **工作原理**：

  - 等待异步组件解析完成
  - 显示加载中状态
  - 异步组件加载完成后替换为实际内容

  **特点**：

  - 支持 async setup() 函数
  - 可以等待多个异步组件
  - 可以使用 onErrorCaptured 处理错误

  ## Vue3 响应式原理（Proxy vs Object.defineProperty）

  ### Vue2 中的 Object.defineProperty

  ```javascript
  let data = { price: 5, quantity: 2 }
  let total = 0
  
  Object.defineProperty(data, 'price', {
    get() {
      console.log('Getting price')
      return price
    },
    set(newVal) {
      console.log('Setting price')
      price = newVal
      // 重新计算总价
      total = price * data.quantity
    }
  })
  ```

  **限制**：

  - 必须预先知道属性键
  - 无法检测属性添加/删除
  - 无法检测数组索引和长度变化
  - 需要递归遍历对象

  ### Vue3 中的 Proxy

  ```javascript
  let data = { price: 5, quantity: 2 }
  let total = 0
  
  const handler = {
    get(target, key) {
      console.log('Getting ' + key)
      return target[key]
    },
    set(target, key, value) {
      console.log('Setting ' + key + ' to ' + value)
      target[key] = value
      // 重新计算总价
      total = target.price * target.quantity
      return true
    }
  }
  
  data = new Proxy(data, handler)
  ```

  **优势**：

  - 可以检测属性添加/删除
  - 可以检测数组索引和长度变化
  - 更好的性能（减少递归遍历）
  - 可以拦截更多操作（如 delete）

  ## Vue 组件间通信方式

  ### 1. Props 和 Emits（父子组件）

  ```vue
  <!-- 父组件 -->
  <template>
    <child-component :msg="message" @response="handleResponse" />
  </template>
  
  <!-- 子组件 -->
  <script>
  export default {
    props: ['msg'],
    setup(props, { emit }) {
      const sendResponse = () => {
        emit('response', 'Hello from child')
      }
      return { sendResponse }
    }
  }
  </script>
  ```

  ### 2. Provide 和 Inject（祖先和后代组件）

  ```javascript
  // 祖先组件
  import { provide, ref } from 'vue'
  
  export default {
    setup() {
      const theme = ref('dark')
      provide('theme', theme)
    }
  }
  
  // 后代组件
  import { inject } from 'vue'
  
  export default {
    setup() {
      const theme = inject('theme')
      return { theme }
    }
  }
  ```

  ### 3. Vuex/Pinia（全局状态管理）

  ```javascript
  // Vuex store
  const store = createStore({
    state: { count: 0 },
    mutations: {
      increment(state) { state.count++ }
    }
  })
  
  // 组件中使用
  import { useStore } from 'vuex'
  
  export default {
    setup() {
      const store = useStore()
      const increment = () => store.commit('increment')
      return { count: computed(() => store.state.count), increment }
    }
  }
  ```

  ### 4. EventBus（Vue2）/Mitt（Vue3）

  ```javascript
  // 创建 EventBus
  import mitt from 'mitt'
  const emitter = mitt()
  
  // 组件 A
  emitter.emit('event-name', { data: 'some data' })
  
  // 组件 B
  emitter.on('event-name', (data) => {
    console.log(data)
  })
  ```

  ### 5. $attrs 和 v-bind 继承

  ```vue
  <!-- 父组件 -->
  <child-component title="标题" class="large" />
  
  <!-- 子组件 -->
  <template>
    <div v-bind="$attrs">
      <!-- 继承所有未被声明为 prop 的属性 -->
    </div>
  </template>
  ```

  ## Vue3 的 Pinia 状态管理

  Pinia 是 Vue 团队创建的新一代状态管理库，是 Vuex 5 的原型。

  ### 基本使用

  ```javascript
  // 创建 store
  import { defineStore } from 'pinia'
  
  export const useUserStore = defineStore('user', {
    state: () => ({
      name: 'John',
      isAdmin: false,
      items: []
    }),
    getters: {
      fullName: (state) => `${state.name} Doe`
    },
    actions: {
      async fetchItems() {
        this.items = await api.getItems()
      },
      logout() {
        this.name = ''
        this.isAdmin = false
      }
    }
  })
  
  // 组件中使用
  import { useUserStore } from '@/stores/user'
  
  export default {
    setup() {
      const userStore = useUserStore()
      
      userStore.name = 'Jane' // 直接修改状态
      userStore.fetchItems() // 调用 action
      
      return {
        user: userStore,
        fullName: computed(() => userStore.fullName)
      }
    }
  }
  ```

  ### 使用 Composition API 创建 Store

  ```javascript
  import { defineStore } from 'pinia'
  import { ref, computed } from 'vue'
  
  export const useCounterStore = defineStore('counter', () => {
    const count = ref(0)
    const doubleCount = computed(() => count.value * 2)
    
    function increment() {
      count.value++
    }
    
    return { count, doubleCount, increment }
  })
  ```

  ### Pinia 的优势

  1. **更好的类型推断**：对 TypeScript 的支持更好
  2. **轻量级**：体积更小（约 1KB）
  3. **无需命名空间**：扁平化设计
  4. **无需 mutations**：直接修改状态
  5. **开发工具支持**：与 Vue DevTools 集成
  6. **模块化设计**：每个 store 都是独立的
  7. **支持 SSR**：服务器端渲染更容易

  ```javascript
  // 组合多个 store
  import { useUserStore } from './user'
  import { useCartStore } from './cart'
  
  export function useCheckout() {
    const user = useUserStore()
    const cart = useCartStore()
    
    async function checkout() {
      try {
        await apiCheckout({
          items: cart.items,
          userId: user.id
        })
        cart.clearItems()
      } catch (error) {
        // 处理错误
      }
    }
    
    return { checkout }
  }
  ```

  Pinia 作为 Vue3 的推荐状态管理库，简化了状态管理的复杂性，提供了更现代化的 API 和更好的性能。

## 5. 前端性能优化

- 如何提高 Web 页面加载速度？
- 什么是 Webpack Tree Shaking？
- Code Splitting 和 Lazy Loading 的实现
- React/Vue 的虚拟 DOM 及 diff 算法优化
- 浏览器缓存机制（强缓存 vs 协商缓存）
- 如何减少页面的回流和重绘？

## 6. 前端安全

- XSS（跨站脚本攻击）及防御措施
- CSRF（跨站请求伪造）如何防范？
- CORS（跨域资源共享）及解决方案
- Content Security Policy（CSP）是什么？

## 7. 浏览器原理 & 网络

- 浏览器的渲染流程（从输入 URL 到页面展示）
- TCP/IP、HTTP/HTTPS 及 HTTP2/HTTP3 的区别
- 前端如何处理大数据渲染（虚拟滚动等）
- 浏览器的回流（Reflow）和重绘（Repaint）
- 前端如何优化 SEO？

## 8. Web 前端工程化

- Vite 与 Webpack 的区别
- 如何优化 Webpack 打包性能？
- 如何在项目中配置 ESLint + Prettier？
- CI/CD 在前端项目中的实践
- Monorepo 和 Micro Frontend（微前端）的概念及应用

## 9. AI 赋能前端开发

- AI 生成代码（GitHub Copilot、ChatGPT）对前端开发的影响
- 如何使用 AI 进行代码优化与调试？
- AI 与 Web 交互（语音识别、计算机视觉）

------

这份清单涵盖了最新的前端技术趋势和面试热点问题，适用于 2025 年前端面试准备。

