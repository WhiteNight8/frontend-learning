## 原型继承

获取并扩展一些东西

### [[Prototype]]

对象有个特殊的隐藏属性[[Prototype]],它要么为null， 要么就是对一个对另一个对象的引用，称为原型

![image-20250120092046635](https://raw.githubusercontent.com/JoeyXXia/MyPictureData/main/image-20250120092046635.png)

属性[[Prototype]]是内部而且隐藏的

__proto__

- 引用不能形成闭环
- proto的值可以是对象，也可以是null，其他类型的会被忽略

proto是[[Prototype]]是因为历史原因留下来的getter/setter

根据规范，proto必须受到浏览器环境的支持，实际包括服务端在内的环境基本都支持它

现代编程语言使用Object.getPrototypeOf, Object.setPrototypeOf，来代替proto的get，set原型

### 写入不适用原型

原型仅用于读取属性，写入和删除操作可以直接在对象上进行

### this的值

this不受原型的影响，在一个方法调用中，this始终是点符号前面的对象

方法是共享的，但是对象状态不是

### for in循环

for in循环会迭代继承的属性

obj.hasOwnProperty(key)，如果对象具有自己非继承的key的属性，返回true

几乎其他所有键值获得方法都忽略继承的属性，如Obejct.keys, Object.values，只会对自身对象进行操作



## F.prototype

如果F.prototype是一个对象，那么new操作符会适用它为新对象设置[[Prototype]]

F.prototype仅在new F被调用时适用，它为新对象的Prototype赋值

### 默认的F.prototype，构造器属性

每个函数都有prototype属性，即使没有提供

默认的prototype是一个只有属性constructor的对象，属性constructor指向函数自身

JavaScript自身并不能保证正确的constructor函数值



