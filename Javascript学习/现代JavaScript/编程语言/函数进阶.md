## 递归

最大的嵌套调用次数被称为递归深度



### 执行上下文和堆栈

执行上下文是一个内部数据结构， 包含有关函数执行是的详细细节

- 当前控制流所在的位置
- 当前的变量
- this的值
- 等

任何递归都可以用循环来重写， 通常循环变体更有效



### 递归遍历

Object.values返回属性值组成的数组



### 递归结构

### 链表







## Rest参数和Spread语法

### Rest 参数

- ...rest必须写在参数列表最后
- 不计入length的计算



### arguments 变量

在过去JavaScript不支持rest参数语法，使用arguments获取所有参数

类数组，是可迭代对象，但是不支持数组方法

箭头函数是没有arguments变量



### Spread语法

在函数调用

内部调用了迭代器收集元素

Array.from(obj)跟[...obj]的区别

- Array.from适用于类数组对象，也适用于可迭代对象
- Spread语法只适用于可迭代对象



### 复制array /  object

spread语法可以进行浅拷贝





## 变量作用域，闭包

JavaScript是面向函数的，可以随时创建函数，将函数作为参数传递给另一个函数



### 代码块

只在代码块中可见



### 嵌套函数

在函数中创建另一个函数

词法环境是一个规范对象，只存在于语言规范的理论层面，用于描述事物是如何工作的， 无法在代码中获得该对象并直接对其进行操作

当代码要访问一个变量时，首先会搜索内部词法环境，然后搜索外部环境，然后搜索更外部的环境，直到全局词法环境



### 词法环境

词法环境的组成

- 环境记录：  一个存储所有局部变量作为其属性的对象
- 对外部词法环境的引用， 与外部代码相关联



闭包是指一个函数可以记住其外部变量并访问这些变量，JavaScript中，函数天生闭包，也就是说JavaScript中的函数会自动通过隐藏的[[Environment]]属性记住创建它们的位置，所以它们都可以访问外部变量



### 垃圾回收

通常，函数调用完成后，会将词法环境和其中的变量从内存中删除， 当词法环境变得不可达时，就会死去

注意实际开发中的优化 ： 此类变量在调试中不可用



## 老旧的var

远古时代的怪兽



### var 没有块级作用域

用var声明的变量，不是函数作用域就是全局作用域

### var允许重新声明

可以重新声明一个变量

### var声明的变量，可以在其声明语句前被调用

函数开始时，，就会处理var声明

提升 hoisting

**声明会被提升但是赋值不会**

### IIFE

立即函数调用表达式，拥有自己的私有变量

创建一个函数表达式并立即调用





## 全局对象

全局对象提供可在任何地方使用的变量和函数。 

在浏览器中，是window， node中是global

建议少使用

### 使用polyfills

使用全局对象测试对现代语言功能的支持



## 函数对象

在JavaScript中，函数的类型是对象

### 属性 name

大多数函数都是有名字的

#### 属性length

返回函数入参的个数

rest参数不计数

### 自定义属性

属性不是变量

有时候可以用来替代闭包

### 命名函数表达式

带有名字的函数表达式



## new function 语法

创建函数的方法，很少使用

### 语法

```js
let func = new Function([arg1,arg2,...argN], functionBody)
```

使用场景特殊，在复杂的web应用中，需要从服务器获取代码或者动态的从模板编译函数时使用

### 闭包

是指使用一个特殊的属性[[Environment]]来记录函数自身的创建时的环境的函数。具体指向了函数创建时的词法环境

使用new function 创建一个函数，该函数的[[Environment]]并不指向当前的词法环境，而是指向全局环境。

因此new function无法访问外部变量，只能访问全局变量



## 调度 setTimeout， setInterval

计划调用

### setTimeout

传入一个函数但是不要执行

### 用clearTimeout来取消调度

定时器标识符

### setInterval

每间隔给定时间周期性执行

### 嵌套的setTimeout

嵌套的setTimeout相较于setInterval能够更精确的设置两次执行之间的延时

### 零延时的setTimeout

实际上在浏览器中不存在零延时



## 装饰器模式和转发， call  apply

转发，调用，装饰函数

### 透明缓存

缓存逻辑时独立的，没有增加本身的复杂度

### 使用func.call设定上下文

改变函数上下文

### 传递多个参数

使用arguments

### func.apply

spread语法允许将可迭代对象作为列表传递给call

apply只接受类数组

### 借一种方法

方法借用

[].join.call()

### 装饰器和函数属性

如果需要装饰器保留对函数属性的访问权限，可能需要proxy了



## 函数绑定

要解决对象方法传递时，丢失this的问题

### 丢失this

如何确保正确的上下文呢

1. 包装器
2. bind

### 部分函数

### 在没有上下文情况下的partial



## 深入理解箭头函数

JavaScript的精髓在于创建一个函数并将它传递到某个地方

在这样的函数中，不想离开当前上下文

### 箭头函数没有this

箭头函数没有this，如果访问this，会从外部获取

因为没有this，所以箭头函数不能用作构造器，不能new

### 箭头函数没有arguments

转发调用非常有用













