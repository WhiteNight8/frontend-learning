# 深入理解浏览器渲染机制与性能优化



## 浏览器渲染引擎工作原理与关键渲染路径

### 渲染引擎架构

浏览器渲染引擎（如Blink、WebKit、Gecko）负责解析HTML、CSS和JavaScript，将其转换为用户可见的页面。

### 关键渲染路径（Critical Rendering Path）

关键渲染路径包含6个主要步骤：

**1. HTML解析 → DOM树构建**

```html
<!-- HTML文档 -->
<html>
  <head>
    <title>页面标题</title>
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="container">
      <h1>标题</h1>
      <p>内容</p>
    </div>
  </body>
</html>
```

**2. CSS解析 → CSSOM树构建**

```css
/* CSS样式 */
.container {
  width: 100%;
  padding: 20px;
}

h1 {
  color: #333;
  font-size: 24px;
}
```

**3. DOM + CSSOM → 渲染树（Render Tree）** 渲染树只包含需要显示的节点和样式信息，不包含`display: none`的元素。

**4. 布局（Layout/Reflow）** 计算每个节点在屏幕上的确切位置和尺寸。

**5. 绘制（Paint）** 将渲染树中的每个节点转换为屏幕上的实际像素。

**6. 合成（Composite）** 将各个图层合并到最终的屏幕图像中。

### 优化关键渲染路径

```html
<!DOCTYPE html>
<html>
<head>
  <!-- 内联关键CSS -->
  <style>
    .above-fold { display: block; }
  </style>
  
  <!-- 异步加载非关键CSS -->
  <link rel="preload" href="non-critical.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
  
  <!-- 预加载关键资源 -->
  <link rel="preload" href="hero-image.jpg" as="image">
</head>
<body>
  <!-- 关键内容 -->
  <div class="above-fold">首屏内容</div>
  
  <!-- 延迟加载JavaScript -->
  <script src="main.js" defer></script>
</body>
</html>
```



## 深入理解回流与重绘的触发机制及优化策略

### 回流（Reflow）触发条件

回流会重新计算元素的几何属性：

javascript

```javascript
// 触发回流的操作
const element = document.getElementById('box');

// 1. 修改盒模型相关属性
element.style.width = '200px';
element.style.height = '200px';
element.style.padding = '10px';
element.style.margin = '20px';
element.style.border = '1px solid red';

// 2. 修改定位相关属性
element.style.position = 'absolute';
element.style.top = '100px';
element.style.left = '100px';

// 3. 修改字体相关属性
element.style.fontSize = '16px';
element.style.fontFamily = 'Arial';
element.style.lineHeight = '1.5';

// 4. 添加/删除DOM节点
document.body.appendChild(newElement);
element.parentNode.removeChild(element);

// 5. 获取特定属性时强制回流
const width = element.offsetWidth;
const height = element.offsetHeight;
const rect = element.getBoundingClientRect();
```

### 重绘（Repaint）触发条件

重绘不会改变元素几何属性，只改变外观：

javascript

```javascript
// 只触发重绘的操作
element.style.color = 'red';
element.style.backgroundColor = 'blue';
element.style.boxShadow = '0 0 10px rgba(0,0,0,0.5)';
element.style.borderRadius = '5px';
element.style.visibility = 'hidden'; // 注意：display:none会触发回流
```

### 优化策略

**1. 批量DOM操作**

```javascript
// 不好的做法 - 多次回流
const list = document.getElementById('list');
for (let i = 0; i < 1000; i++) {
  const item = document.createElement('li');
  item.textContent = `Item ${i}`;
  list.appendChild(item); // 每次都触发回流
}

// 好的做法 - 使用DocumentFragment
const fragment = document.createDocumentFragment();
for (let i = 0; i < 1000; i++) {
  const item = document.createElement('li');
  item.textContent = `Item ${i}`;
  fragment.appendChild(item);
}
list.appendChild(fragment); // 只触发一次回流
```

**2. 使用CSS类而非内联样式**

```javascript
// 不好的做法
element.style.width = '200px';
element.style.height = '200px';
element.style.backgroundColor = 'red';

// 好的做法
element.className = 'optimized-style';
```

**3. 缓存DOM查询结果**

```javascript
// 不好的做法
for (let i = 0; i < 1000; i++) {
  document.getElementById('box').style.left = i + 'px'; // 每次都查询DOM
}

// 好的做法
const box = document.getElementById('box');
for (let i = 0; i < 1000; i++) {
  box.style.left = i + 'px';
}
```

**4. 使用transform和opacity实现动画**

```css
/* 触发回流重绘的动画 */
.element {
  transition: left 0.3s ease;
}
.element:hover {
  left: 100px; /* 触发回流 */
}

/* 只触发合成层的动画 */
.element {
  transition: transform 0.3s ease;
}
.element:hover {
  transform: translateX(100px); /* 只触发合成 */
}
```



##  Shadow DOM 与 Web Components 的实现原理

### Shadow DOM 基础概念

Shadow DOM 提供了组件级别的DOM封装和样式隔离。

```javascript
// 创建自定义元素
class CustomButton extends HTMLElement {
  constructor() {
    super();
    
    // 创建Shadow Root
    this.attachShadow({ mode: 'open' });
    
    // 创建模板
    const template = document.createElement('template');
    template.innerHTML = `
      <style>
        :host {
          display: inline-block;
          padding: 10px 20px;
          background: #007bff;
          color: white;
          border: none;
          border-radius: 4px;
          cursor: pointer;
        }
        
        :host(:hover) {
          background: #0056b3;
        }
        
        .button-content {
          display: flex;
          align-items: center;
          gap: 8px;
        }
        
        ::slotted(.icon) {
          width: 16px;
          height: 16px;
        }
      </style>
      
      <button class="button-content">
        <slot name="icon"></slot>
        <slot></slot>
      </button>
    `;
    
    // 将模板内容克隆到Shadow DOM中
    this.shadowRoot.appendChild(template.content.cloneNode(true));
  }
  
  connectedCallback() {
    // 元素被插入DOM时调用
    this.addEventListener('click', this.handleClick);
  }
  
  disconnectedCallback() {
    // 元素从DOM中移除时调用
    this.removeEventListener('click', this.handleClick);
  }
  
  handleClick = (event) => {
    // 派发自定义事件
    this.dispatchEvent(new CustomEvent('custom-click', {
      detail: { originalEvent: event },
      bubbles: true
    }));
  }
}

// 注册自定义元素
customElements.define('custom-button', CustomButton);
```

### 使用Web Components

```html
<!-- HTML中使用自定义元素 -->
<custom-button>
  <span slot="icon">🚀</span>
  点击我
</custom-button>

<script>
// 监听自定义事件
document.addEventListener('custom-click', (event) => {
  console.log('按钮被点击了', event.detail);
});
</script>
```

### 高级Web Components特性

```javascript
class DataTable extends HTMLElement {
  static get observedAttributes() {
    return ['data-source', 'columns'];
  }
  
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
    this.data = [];
    this.columns = [];
  }
  
  attributeChangedCallback(name, oldValue, newValue) {
    if (name === 'data-source') {
      this.loadData(newValue);
    } else if (name === 'columns') {
      this.columns = JSON.parse(newValue);
      this.render();
    }
  }
  
  async loadData(url) {
    try {
      const response = await fetch(url);
      this.data = await response.json();
      this.render();
    } catch (error) {
      console.error('加载数据失败:', error);
    }
  }
  
  render() {
    const template = `
      <style>
        table {
          width: 100%;
          border-collapse: collapse;
        }
        th, td {
          padding: 8px 12px;
          border: 1px solid #ddd;
          text-align: left;
        }
        th {
          background-color: #f5f5f5;
          font-weight: bold;
        }
      </style>
      
      <table>
        <thead>
          <tr>
            ${this.columns.map(col => `<th>${col.title}</th>`).join('')}
          </tr>
        </thead>
        <tbody>
          ${this.data.map(row => `
            <tr>
              ${this.columns.map(col => `<td>${row[col.key] || ''}</td>`).join('')}
            </tr>
          `).join('')}
        </tbody>
      </table>
    `;
    
    this.shadowRoot.innerHTML = template;
  }
}

customElements.define('data-table', DataTable);
```



## 复杂DOM操作的高性能实现策略

### 虚拟滚动实现

```javascript
class VirtualScrollList {
  constructor(container, itemHeight, totalItems, renderItem) {
    this.container = container;
    this.itemHeight = itemHeight;
    this.totalItems = totalItems;
    this.renderItem = renderItem;
    
    this.viewportHeight = container.clientHeight;
    this.visibleCount = Math.ceil(this.viewportHeight / itemHeight) + 1;
    this.buffer = 5; // 缓冲区项目数
    
    this.init();
  }
  
  init() {
    // 创建滚动容器
    this.scrollElement = document.createElement('div');
    this.scrollElement.style.height = `${this.totalItems * this.itemHeight}px`;
    this.scrollElement.style.position = 'relative';
    
    // 创建可见区域容器
    this.visibleContainer = document.createElement('div');
    this.visibleContainer.style.position = 'absolute';
    this.visibleContainer.style.top = '0';
    this.visibleContainer.style.width = '100%';
    
    this.scrollElement.appendChild(this.visibleContainer);
    this.container.appendChild(this.scrollElement);
    
    // 监听滚动事件
    this.container.addEventListener('scroll', this.handleScroll.bind(this));
    
    this.render();
  }
  
  handleScroll() {
    // 使用requestAnimationFrame优化滚动性能
    if (this.scrollRAF) {
      cancelAnimationFrame(this.scrollRAF);
    }
    
    this.scrollRAF = requestAnimationFrame(() => {
      this.render();
    });
  }
  
  render() {
    const scrollTop = this.container.scrollTop;
    const startIndex = Math.max(0, Math.floor(scrollTop / this.itemHeight) - this.buffer);
    const endIndex = Math.min(
      this.totalItems - 1,
      startIndex + this.visibleCount + this.buffer * 2
    );
    
    // 清空当前内容
    this.visibleContainer.innerHTML = '';
    
    // 设置容器位置
    this.visibleContainer.style.transform = `translateY(${startIndex * this.itemHeight}px)`;
    
    // 渲染可见项目
    for (let i = startIndex; i <= endIndex; i++) {
      const item = this.renderItem(i);
      item.style.height = `${this.itemHeight}px`;
      this.visibleContainer.appendChild(item);
    }
  }
}

// 使用示例
const renderItem = (index) => {
  const div = document.createElement('div');
  div.textContent = `Item ${index}`;
  div.style.padding = '10px';
  div.style.borderBottom = '1px solid #eee';
  return div;
};

const virtualList = new VirtualScrollList(
  document.getElementById('list-container'),
  50, // 每项高度
  10000, // 总项目数
  renderItem
);
```

### 高效的DOM更新策略

```javascript
class DOMBatcher {
  constructor() {
    this.updates = [];
    this.rafId = null;
  }
  
  // 批量添加更新操作
  batch(updateFn) {
    this.updates.push(updateFn);
    
    if (!this.rafId) {
      this.rafId = requestAnimationFrame(() => {
        this.flush();
      });
    }
  }
  
  // 执行所有批量更新
  flush() {
    // 先执行所有读取操作
    const reads = this.updates.filter(update => update.type === 'read');
    reads.forEach(update => update.fn());
    
    // 再执行所有写入操作
    const writes = this.updates.filter(update => update.type === 'write');
    writes.forEach(update => update.fn());
    
    // 清空队列
    this.updates = [];
    this.rafId = null;
  }
  
  // 读取操作
  read(fn) {
    this.batch({ type: 'read', fn });
  }
  
  // 写入操作
  write(fn) {
    this.batch({ type: 'write', fn });
  }
}

// 使用示例
const batcher = new DOMBatcher();

// 批量处理多个元素的样式更新
const elements = document.querySelectorAll('.animate-element');
elements.forEach((el, index) => {
  batcher.read(() => {
    // 读取当前状态
    const rect = el.getBoundingClientRect();
  });
  
  batcher.write(() => {
    // 更新样式
    el.style.transform = `translateX(${index * 10}px)`;
  });
});
```



## 浏览器布局系统与CSS引擎工作机制

### 布局算法理解

```css
/* Flex布局计算流程 */
.flex-container {
  display: flex;
  width: 800px;
  height: 200px;
}

.flex-item {
  flex: 1 1 auto; /* flex-grow: 1, flex-shrink: 1, flex-basis: auto */
  min-width: 100px;
  max-width: 300px;
}
```

### CSS引擎优化技巧

```css
/* 1. 使用CSS containment优化 */
.component {
  contain: layout style paint;
}

/* 2. 创建新的层叠上下文 */
.gpu-layer {
  will-change: transform;
  transform: translateZ(0); /* 或使用translate3d(0,0,0) */
}

/* 3. 优化选择器性能 */
/* 不好的选择器 */
div div div p span { color: red; }

/* 好的选择器 */
.specific-text { color: red; }

/* 4. 使用CSS Grid进行复杂布局 */
.grid-layout {
  display: grid;
  grid-template-areas: 
    "header header header"
    "sidebar main aside"
    "footer footer footer";
  grid-template-columns: 200px 1fr 200px;
  grid-template-rows: auto 1fr auto;
}
```



## 使用Performance API与DevTools分析渲染性能

### Performance API实战应用

```javascript
class PerformanceMonitor {
  constructor() {
    this.observer = null;
    this.metrics = {};
    this.init();
  }
  
  init() {
    // 监听性能条目
    this.observer = new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        this.handlePerformanceEntry(entry);
      }
    });
    
    // 监听不同类型的性能数据
    try {
      this.observer.observe({ entryTypes: ['measure', 'navigation', 'paint', 'largest-contentful-paint'] });
    } catch (e) {
      // 降级处理
      this.observer.observe({ entryTypes: ['measure', 'navigation'] });
    }
  }
  
  handlePerformanceEntry(entry) {
    switch (entry.entryType) {
      case 'navigation':
        this.handleNavigationTiming(entry);
        break;
      case 'paint':
        this.handlePaintTiming(entry);
        break;
      case 'largest-contentful-paint':
        this.handleLCP(entry);
        break;
      case 'measure':
        this.handleCustomMeasure(entry);
        break;
    }
  }
  
  handleNavigationTiming(entry) {
    this.metrics.domContentLoaded = entry.domContentLoadedEventEnd - entry.domContentLoadedEventStart;
    this.metrics.loadComplete = entry.loadEventEnd - entry.loadEventStart;
    this.metrics.domInteractive = entry.domInteractive - entry.fetchStart;
  }
  
  handlePaintTiming(entry) {
    this.metrics[entry.name] = entry.startTime;
  }
  
  handleLCP(entry) {
    this.metrics.lcp = entry.startTime;
  }
  
  // 自定义性能测量
  measureFunction(name, fn) {
    performance.mark(`${name}-start`);
    const result = fn();
    performance.mark(`${name}-end`);
    performance.measure(name, `${name}-start`, `${name}-end`);
    return result;
  }
  
  // 测量DOM操作性能
  measureDOMOperation(operation) {
    return this.measureFunction('dom-operation', operation);
  }
  
  // 获取FPS
  measureFPS() {
    let fps = 0;
    let lastTime = performance.now();
    let frames = 0;
    
    const measure = () => {
      frames++;
      const currentTime = performance.now();
      
      if (currentTime >= lastTime + 1000) {
        fps = Math.round((frames * 1000) / (currentTime - lastTime));
        frames = 0;
        lastTime = currentTime;
        
        console.log(`当前FPS: ${fps}`);
      }
      
      requestAnimationFrame(measure);
    };
    
    requestAnimationFrame(measure);
  }
  
  // 获取所有性能指标
  getMetrics() {
    return {
      ...this.metrics,
      // Core Web Vitals
      fcp: this.metrics['first-contentful-paint'],
      lcp: this.metrics.lcp,
      // 自定义计算的指标
      renderTime: this.metrics.domInteractive,
      loadTime: this.metrics.loadComplete
    };
  }
}

// 使用示例
const monitor = new PerformanceMonitor();

// 测量DOM操作性能
const result = monitor.measureDOMOperation(() => {
  const fragment = document.createDocumentFragment();
  for (let i = 0; i < 1000; i++) {
    const div = document.createElement('div');
    div.textContent = `Item ${i}`;
    fragment.appendChild(div);
  }
  document.body.appendChild(fragment);
});

// 开始FPS监控
monitor.measureFPS();

// 获取性能报告
setTimeout(() => {
  console.log('性能指标:', monitor.getMetrics());
}, 5000);
```



### DevTools性能分析技巧

```javascript
// 1. 使用console.time进行简单性能测量
console.time('DOM操作');
// 执行DOM操作
console.timeEnd('DOM操作');

// 2. 使用profile API
console.profile('渲染性能分析');
// 执行需要分析的代码
console.profileEnd('渲染性能分析');

// 3. 标记时间线
performance.mark('开始复杂计算');
// 执行复杂计算
performance.mark('结束复杂计算');
performance.measure('复杂计算耗时', '开始复杂计算', '结束复杂计算');
```



##  渲染管道优化技术

### 层级优化策略

```css
/* 创建独立的合成层 */
.optimized-animation {
  /* 使用transform和opacity，避免触发layout和paint */
  transform: translateX(0);
  opacity: 1;
  
  /* 提示浏览器创建合成层 */
  will-change: transform, opacity;
  
  /* 或者使用3D变换强制创建层 */
  transform: translate3d(0, 0, 0);
}

/* 避免不必要的层创建 */
.avoid-layer {
  /* 动画结束后移除will-change */
  will-change: auto;
}
```

### JavaScript优化实现

```javascript
class RenderOptimizer {
  constructor() {
    this.scheduledAnimations = new Set();
    this.isAnimating = false;
  }
  
  // 优化动画调度
  scheduleAnimation(element, animation) {
    this.scheduledAnimations.add({ element, animation });
    
    if (!this.isAnimating) {
      this.startAnimationLoop();
    }
  }
  
  startAnimationLoop() {
    this.isAnimating = true;
    
    const animate = (timestamp) => {
      // 批量执行所有动画
      for (const { element, animation } of this.scheduledAnimations) {
        animation(element, timestamp);
      }
      
      if (this.scheduledAnimations.size > 0) {
        requestAnimationFrame(animate);
      } else {
        this.isAnimating = false;
      }
    };
    
    requestAnimationFrame(animate);
  }
  
  // 优化大量元素的样式更新
  batchStyleUpdate(elements, styleUpdates) {
    // 使用DocumentFragment减少DOM操作
    const fragment = document.createDocumentFragment();
    
    elements.forEach((element, index) => {
      // 克隆元素以避免多次回流
      const clone = element.cloneNode(true);
      
      // 应用样式更新
      Object.assign(clone.style, styleUpdates[index]);
      
      fragment.appendChild(clone);
    });
    
    // 一次性替换所有元素
    const parent = elements[0].parentNode;
    elements.forEach(el => el.remove());
    parent.appendChild(fragment);
  }
  
  // 智能防抖滚动处理
  optimizeScrollHandler(handler, delay = 16) {
    let rafId;
    let lastKnownScrollPosition = 0;
    let ticking = false;
    
    return function(event) {
      lastKnownScrollPosition = window.scrollY;
      
      if (!ticking) {
        requestAnimationFrame(() => {
          handler(lastKnownScrollPosition);
          ticking = false;
        });
        ticking = true;
      }
    };
  }
}

// 使用示例
const optimizer = new RenderOptimizer();

// 优化的滚动处理
const optimizedScrollHandler = optimizer.optimizeScrollHandler((scrollY) => {
  // 处理滚动逻辑
  const elements = document.querySelectorAll('.parallax-element');
  elements.forEach((el, index) => {
    const speed = (index + 1) * 0.5;
    el.style.transform = `translateY(${scrollY * speed}px)`;
  });
});

window.addEventListener('scroll', optimizedScrollHandler);

// 批量样式更新示例
const elements = document.querySelectorAll('.batch-update');
const styleUpdates = elements.map((_, index) => ({
  transform: `translateX(${index * 10}px)`,
  opacity: Math.random()
}));

optimizer.batchStyleUpdate(elements, styleUpdates);
```



### 内存优化策略

```javascript
class MemoryOptimizer {
  constructor() {
    this.observers = new Map();
    this.eventListeners = new WeakMap();
  }
  
  // 自动清理Intersection Observer
  createIntersectionObserver(callback, options) {
    const observer = new IntersectionObserver(callback, options);
    
    // 包装原始方法以自动清理
    const originalObserve = observer.observe.bind(observer);
    const originalUnobserve = observer.unobserve.bind(observer);
    
    observer.observe = (target) => {
      originalObserve(target);
      
      if (!this.observers.has(observer)) {
        this.observers.set(observer, new Set());
      }
      this.observers.get(observer).add(target);
    };
    
    observer.unobserve = (target) => {
      originalUnobserve(target);
      
      if (this.observers.has(observer)) {
        this.observers.get(observer).delete(target);
        
        if (this.observers.get(observer).size === 0) {
          observer.disconnect();
          this.observers.delete(observer);
        }
      }
    };
    
    return observer;
  }
  
  // 自动清理事件监听器
  addEventListenerWithCleanup(element, event, handler, options) {
    element.addEventListener(event, handler, options);
    
    if (!this.eventListeners.has(element)) {
      this.eventListeners.set(element, []);
    }
    
    this.eventListeners.get(element).push({
      event,
      handler,
      options
    });
    
    // 返回清理函数
    return () => {
      element.removeEventListener(event, handler, options);
      const listeners = this.eventListeners.get(element);
      if (listeners) {
        const index = listeners.findIndex(l => 
          l.event === event && l.handler === handler
        );
        if (index > -1) {
          listeners.splice(index, 1);
        }
      }
    };
  }
  
  // 清理所有资源
  cleanup() {
    // 清理所有观察器
    for (const [observer] of this.observers) {
      observer.disconnect();
    }
    this.observers.clear();
    
    // 清理事件监听器
    for (const [element, listeners] of this.eventListeners) {
      listeners.forEach(({ event, handler, options }) => {
        element.removeEventListener(event, handler, options);
      });
    }
  }
}

// 使用示例
const memoryOptimizer = new MemoryOptimizer();

// 创建自动清理的观察器
const observer = memoryOptimizer.createIntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      // 元素进入视口
      entry.target.classList.add('visible');
    }
  });
});

// 添加自动清理的事件监听器
const cleanup = memoryOptimizer.addEventListenerWithCleanup(
  document,
  'click',
  (event) => {
    console.log('点击事件', event.target);
  }
);

// 页面卸载时清理资源
window.addEventListener('beforeunload', () => {
  memoryOptimizer.cleanup();
});
```



# 浏览器存储与缓存

## 浏览器存储机制：从 Cookie 到 IndexedDB 的技术演进

###  技术演进历程

#### Cookie (1994年)

- **容量限制**：4KB
- **特点**：自动随HTTP请求发送，支持过期时间
- **问题**：容量小、影响网络性能、安全性有限

javascript

```javascript
// Cookie 操作示例
document.cookie = "username=john; expires=Fri, 31 Dec 2024 23:59:59 GMT; path=/";
```

#### Web Storage (2009年) - HTML5标准

**localStorage**

- **容量**：5-10MB（因浏览器而异）
- **生命周期**：持久化存储，手动清除
- **作用域**：同源策略限制

**sessionStorage**

- **容量**：5-10MB
- **生命周期**：会话结束即清除
- **作用域**：标签页级别

```javascript
// localStorage 示例
localStorage.setItem('userPrefs', JSON.stringify({theme: 'dark', lang: 'zh'}));
const prefs = JSON.parse(localStorage.getItem('userPrefs'));

// sessionStorage 示例
sessionStorage.setItem('tempData', 'session-specific-data');
```

#### IndexedDB (2010年)

- **容量**：理论上无限制（受设备存储影响）
- **特点**：NoSQL数据库、事务支持、异步操作
- **适用场景**：大量结构化数据存储

```javascript
// IndexedDB 基本操作
const request = indexedDB.open('MyDatabase', 1);
request.onsuccess = function(event) {
  const db = event.target.result;
  const transaction = db.transaction(['users'], 'readwrite');
  const store = transaction.objectStore('users');
  store.add({id: 1, name: 'Alice', email: 'alice@example.com'});
};
```



### 演进驱动因素

1. **应用复杂度增加**：从简单页面到复杂Web应用
2. **离线需求**：PWA和离线应用的兴起
3. **性能要求**：减少网络请求，提升用户体验
4. **数据量增长**：需要存储更多客户端数据



## Service Worker 缓存策略设计与最佳实践

### 核心缓存策略

#### Cache First (缓存优先)

```javascript
self.addEventListener('fetch', event => {
  event.respondWith(
    caches.match(event.request)
      .then(response => {
        // 缓存命中则返回缓存
        if (response) {
          return response;
        }
        // 否则发起网络请求
        return fetch(event.request);
      })
  );
});
```



#### Network First (网络优先)

```javascript
self.addEventListener('fetch', event => {
  event.respondWith(
    fetch(event.request)
      .then(response => {
        // 网络请求成功，更新缓存
        const responseClone = response.clone();
        caches.open('dynamic-cache')
          .then(cache => cache.put(event.request, responseClone));
        return response;
      })
      .catch(() => {
        // 网络失败，回退到缓存
        return caches.match(event.request);
      })
  );
});
```



#### Stale While Revalidate (过期重新验证)

```javascript
self.addEventListener('fetch', event => {
  event.respondWith(
    caches.match(event.request)
      .then(response => {
        // 立即返回缓存（如果存在）
        const fetchPromise = fetch(event.request)
          .then(networkResponse => {
            // 后台更新缓存
            caches.open('cache-v1')
              .then(cache => cache.put(event.request, networkResponse.clone()));
            return networkResponse;
          });
        
        return response || fetchPromise;
      })
  );
});
```



### 最佳实践

#### 分层缓存策略

```javascript
const CACHE_STRATEGIES = {
  '/api/': 'networkFirst',
  '/assets/': 'cacheFirst',
  '/': 'staleWhileRevalidate'
};

self.addEventListener('fetch', event => {
  const url = new URL(event.request.url);
  const strategy = getStrategy(url.pathname);
  
  event.respondWith(executeStrategy(strategy, event.request));
});

function getStrategy(pathname) {
  for (const [pattern, strategy] of Object.entries(CACHE_STRATEGIES)) {
    if (pathname.startsWith(pattern)) {
      return strategy;
    }
  }
  return 'networkFirst'; // 默认策略
}
```



#### 缓存版本管理

```javascript
const CACHE_NAME = 'app-cache-v2';
const urlsToCache = [
  '/',
  '/styles/main.css',
  '/scripts/app.js',
  '/offline.html'
];

self.addEventListener('install', event => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then(cache => cache.addAll(urlsToCache))
  );
});

self.addEventListener('activate', event => {
  event.waitUntil(
    caches.keys().then(cacheNames => {
      return Promise.all(
        cacheNames.map(cacheName => {
          if (cacheName !== CACHE_NAME) {
            return caches.delete(cacheName);
          }
        })
      );
    })
  );
});
```



## 缓存 API 与离线应用设计

### Cache API 核心操作

```javascript
// 打开缓存
const cache = await caches.open('my-cache-v1');

// 添加资源到缓存
await cache.add('/api/data');
await cache.addAll(['/style.css', '/app.js']);

// 手动缓存响应
const response = await fetch('/api/user');
await cache.put('/api/user', response.clone());

// 匹配缓存
const cachedResponse = await cache.match('/api/data');

// 删除缓存项
await cache.delete('/api/old-data');
```



### 离线应用架构设计

#### 离线优先架构

```javascript
class OfflineFirstApp {
  constructor() {
    this.initServiceWorker();
    this.setupOfflineDetection();
  }

  async initServiceWorker() {
    if ('serviceWorker' in navigator) {
      try {
        const registration = await navigator.serviceWorker.register('/sw.js');
        console.log('SW registered:', registration);
      } catch (error) {
        console.log('SW registration failed:', error);
      }
    }
  }

  setupOfflineDetection() {
    window.addEventListener('online', this.handleOnline.bind(this));
    window.addEventListener('offline', this.handleOffline.bind(this));
  }

  handleOnline() {
    this.syncPendingData();
    this.showOnlineStatus();
  }

  handleOffline() {
    this.showOfflineStatus();
  }

  async syncPendingData() {
    const pendingRequests = await this.getPendingRequests();
    for (const request of pendingRequests) {
      try {
        await fetch(request.url, request.options);
        await this.removePendingRequest(request.id);
      } catch (error) {
        console.log('Sync failed:', error);
      }
    }
  }
}
```



#### 数据同步策略

```javascript
class DataSyncManager {
  constructor() {
    this.pendingSync = new Map();
  }

  async saveData(key, data) {
    // 本地存储
    await this.saveToIndexedDB(key, data);
    
    // 尝试同步到服务器
    if (navigator.onLine) {
      try {
        await this.syncToServer(key, data);
      } catch (error) {
        // 添加到待同步队列
        this.addToPendingSync(key, data);
      }
    } else {
      this.addToPendingSync(key, data);
    }
  }

  async syncToServer(key, data) {
    const response = await fetch('/api/sync', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ key, data })
    });
    
    if (!response.ok) {
      throw new Error('Sync failed');
    }
  }

  addToPendingSync(key, data) {
    this.pendingSync.set(key, {
      data,
      timestamp: Date.now(),
      retryCount: 0
    });
  }
}
```



## 浏览器存储配额管理与存储优化

### 存储配额查询

```javascript
// 查询存储配额信息
async function getStorageInfo() {
  if ('storage' in navigator && 'estimate' in navigator.storage) {
    try {
      const estimate = await navigator.storage.estimate();
      console.log('已使用存储:', estimate.usage);
      console.log('可用配额:', estimate.quota);
      console.log('使用率:', (estimate.usage / estimate.quota * 100).toFixed(2) + '%');
      
      return {
        used: estimate.usage,
        total: estimate.quota,
        available: estimate.quota - estimate.usage
      };
    } catch (error) {
      console.error('获取存储信息失败:', error);
    }
  }
}

// 请求持久化存储
async function requestPersistentStorage() {
  if ('storage' in navigator && 'persist' in navigator.storage) {
    const persistent = await navigator.storage.persist();
    console.log('持久化存储状态:', persistent);
    return persistent;
  }
}
```

### 存储优化策略

#### 智能清理机制

```javascript
class StorageManager {
  constructor() {
    this.maxStorage = 50 * 1024 * 1024; // 50MB
    this.cleanupThreshold = 0.8; // 80%使用率触发清理
  }

  async checkAndCleanup() {
    const info = await getStorageInfo();
    const usageRatio = info.used / info.total;

    if (usageRatio > this.cleanupThreshold) {
      await this.performCleanup();
    }
  }

  async performCleanup() {
    // 按优先级清理
    await this.cleanupExpiredCache();
    await this.cleanupOldUserData();
    await this.cleanupTemporaryFiles();
  }

  async cleanupExpiredCache() {
    const cacheNames = await caches.keys();
    for (const name of cacheNames) {
      const cache = await caches.open(name);
      const keys = await cache.keys();
      
      for (const request of keys) {
        const response = await cache.match(request);
        if (this.isExpired(response)) {
          await cache.delete(request);
        }
      }
    }
  }

  isExpired(response) {
    const cacheControl = response.headers.get('cache-control');
    const maxAge = this.parseMaxAge(cacheControl);
    const responseDate = new Date(response.headers.get('date'));
    
    return maxAge && (Date.now() - responseDate.getTime()) > maxAge * 1000;
  }
}
```



#### 数据压缩存储

```javascript
class CompressedStorage {
  // 使用 LZ-string 或类似库进行压缩
  async setItem(key, data) {
    const compressed = LZString.compress(JSON.stringify(data));
    localStorage.setItem(key, compressed);
  }

  async getItem(key) {
    const compressed = localStorage.getItem(key);
    if (compressed) {
      const decompressed = LZString.decompress(compressed);
      return JSON.parse(decompressed);
    }
    return null;
  }

  // 分块存储大数据
  async setLargeItem(key, data) {
    const serialized = JSON.stringify(data);
    const chunkSize = 1024 * 1024; // 1MB chunks
    const chunks = [];
    
    for (let i = 0; i < serialized.length; i += chunkSize) {
      chunks.push(serialized.slice(i, i + chunkSize));
    }
    
    localStorage.setItem(`${key}_chunks`, chunks.length);
    chunks.forEach((chunk, index) => {
      localStorage.setItem(`${key}_${index}`, chunk);
    });
  }
}
```



## IndexedDB 事务处理与性能优化

### 事务处理最佳实践

```javascript
class IndexedDBManager {
  constructor(dbName, version) {
    this.dbName = dbName;
    this.version = version;
    this.db = null;
  }

  async init() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.version);
      
      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        this.db = request.result;
        resolve(this.db);
      };
      
      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        this.createObjectStores(db);
      };
    });
  }

  // 批量操作事务
  async batchOperation(storeName, operations) {
    const transaction = this.db.transaction([storeName], 'readwrite');
    const store = transaction.objectStore(storeName);
    
    const promises = operations.map(op => {
      switch (op.type) {
        case 'add':
          return this.promisifyRequest(store.add(op.data));
        case 'put':
          return this.promisifyRequest(store.put(op.data));
        case 'delete':
          return this.promisifyRequest(store.delete(op.key));
        default:
          return Promise.resolve();
      }
    });

    return Promise.all(promises);
  }

  // 事务错误处理
  async safeTransaction(storeName, mode, operation) {
    try {
      const transaction = this.db.transaction([storeName], mode);
      const store = transaction.objectStore(storeName);
      
      // 设置事务错误处理
      transaction.onerror = (event) => {
        console.error('Transaction failed:', event.target.error);
      };
      
      const result = await operation(store);
      
      // 等待事务完成
      await new Promise((resolve, reject) => {
        transaction.oncomplete = () => resolve();
        transaction.onerror = () => reject(transaction.error);
      });
      
      return result;
    } catch (error) {
      console.error('Transaction error:', error);
      throw error;
    }
  }

  promisifyRequest(request) {
    return new Promise((resolve, reject) => {
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }
}
```



### 性能优化技巧

#### 索引优化

```javascript
// 创建复合索引
request.onupgradeneeded = function(event) {
  const db = event.target.result;
  const store = db.createObjectStore('products', { keyPath: 'id' });
  
  // 单字段索引
  store.createIndex('name', 'name', { unique: false });
  store.createIndex('category', 'category', { unique: false });
  
  // 复合索引
  store.createIndex('category_price', ['category', 'price'], { unique: false });
};

// 使用索引查询
async function searchProducts(category, maxPrice) {
  const transaction = db.transaction(['products'], 'readonly');
  const store = transaction.objectStore('products');
  const index = store.index('category_price');
  
  const range = IDBKeyRange.bound([category, 0], [category, maxPrice]);
  const request = index.openCursor(range);
  
  const results = [];
  return new Promise((resolve) => {
    request.onsuccess = function(event) {
      const cursor = event.target.result;
      if (cursor) {
        results.push(cursor.value);
        cursor.continue();
      } else {
        resolve(results);
      }
    };
  });
}
```



#### 游标优化

```javascript
// 高效游标遍历
async function efficientCursorTraversal(storeName, processor) {
  const transaction = this.db.transaction([storeName], 'readonly');
  const store = transaction.objectStore(storeName);
  const request = store.openCursor();
  
  let processed = 0;
  
  return new Promise((resolve, reject) => {
    request.onsuccess = function(event) {
      const cursor = event.target.result;
      
      if (cursor) {
        processor(cursor.value);
        processed++;
        
        // 批量处理，减少主线程阻塞
        if (processed % 100 === 0) {
          setTimeout(() => cursor.continue(), 0);
        } else {
          cursor.continue();
        }
      } else {
        resolve(processed);
      }
    };
    
    request.onerror = () => reject(request.error);
  });
}
```



## 主流浏览器的存储隔离策略与安全机制

### 同源策略 (Same-Origin Policy)

```javascript
// 存储隔离示例
function demonstrateStorageIsolation() {
  // 不同源的页面无法访问彼此的存储
  
  // https://example.com 的存储
  localStorage.setItem('user', 'alice');
  
  // https://app.example.com 无法访问上述数据
  // 即使是同一域名的不同子域也被视为不同源
}

// 安全的跨域存储通信
function secureStorageCommunication() {
  // 使用 postMessage 进行安全通信
  window.addEventListener('message', (event) => {
    // 验证消息来源
    if (event.origin !== 'https://trusted-domain.com') {
      return;
    }
    
    // 处理存储请求
    if (event.data.type === 'STORAGE_REQUEST') {
      const data = localStorage.getItem(event.data.key);
      event.source.postMessage({
        type: 'STORAGE_RESPONSE',
        data: data
      }, event.origin);
    }
  });
}
```



###  浏览器特定的安全机制

#### Chrome 的 Storage Partitioning

```javascript
// Chrome 85+ 实现了存储分区
// 第三方上下文中的存储会被分区隔离

// 检测存储分区支持
function detectStoragePartitioning() {
  if ('storage' in navigator && 'getDirectory' in navigator.storage) {
    // 支持 Storage Partitioning
    return true;
  }
  return false;
}

// 适配存储分区的代码
class PartitionAwareStorage {
  constructor() {
    this.isPartitioned = this.detectPartitioning();
  }

  async setItem(key, data) {
    if (this.isPartitioned) {
      // 使用分区安全的存储方式
      return this.setPartitionedItem(key, data);
    } else {
      // 传统存储方式
      return localStorage.setItem(key, JSON.stringify(data));
    }
  }

  async setPartitionedItem(key, data) {
    // 使用 IndexedDB 或其他分区安全的存储
    const db = await this.openDatabase();
    const transaction = db.transaction(['storage'], 'readwrite');
    const store = transaction.objectStore('storage');
    return store.put({ key, data });
  }
}
```



### Content Security Policy (CSP) 影响

```javascript
// CSP 对存储的影响
function handleCSPRestrictions() {
  // unsafe-eval 限制影响 JSON 序列化
  try {
    const data = { user: 'alice', timestamp: Date.now() };
    
    // 安全的序列化方式
    const serialized = JSON.stringify(data);
    localStorage.setItem('userData', serialized);
    
    // 避免使用 eval 或 Function 构造器
    const parsed = JSON.parse(localStorage.getItem('userData'));
    
  } catch (error) {
    console.error('CSP restriction encountered:', error);
  }
}
```



## WebStorage、IndexedDB 与 Cache API 的适用场景分析

### 用场景详解

#### localStorage 适用场景

```javascript
// 1. 用户偏好设置
const userPreferences = {
  theme: 'dark',
  language: 'zh-CN',
  notifications: true
};
localStorage.setItem('preferences', JSON.stringify(userPreferences));

// 2. 购物车数据
class ShoppingCart {
  addItem(item) {
    const cart = this.getCart();
    cart.push(item);
    localStorage.setItem('cart', JSON.stringify(cart));
  }

  getCart() {
    return JSON.parse(localStorage.getItem('cart') || '[]');
  }
}

// 3. 表单数据自动保存
function autoSaveForm() {
  const form = document.getElementById('userForm');
  form.addEventListener('input', (e) => {
    const formData = new FormData(form);
    const data = Object.fromEntries(formData.entries());
    localStorage.setItem('formDraft', JSON.stringify(data));
  });
}
```



#### sessionStorage 适用场景

```javascript
// 1. 单页应用状态管理
class SPAStateManager {
  saveState(state) {
    sessionStorage.setItem('appState', JSON.stringify(state));
  }

  restoreState() {
    const state = sessionStorage.getItem('appState');
    return state ? JSON.parse(state) : null;
  }
}

// 2. 表单向导数据
class FormWizard {
  saveStep(stepData) {
    sessionStorage.setItem(`step_${stepData.step}`, JSON.stringify(stepData));
  }

  getStepData(step) {
    return JSON.parse(sessionStorage.getItem(`step_${step}`) || '{}');
  }
}

// 3. 临时文件上传
function tempFileUpload() {
  // 存储文件上传进度
  sessionStorage.setItem('uploadProgress', JSON.stringify({
    files: ['file1.jpg', 'file2.pdf'],
    progress: 75
  }));
}
```



#### ndexedDB 适用场景

```javascript
// 1. 大量结构化数据
class ProductCatalog {
  async addProducts(products) {
    const transaction = this.db.transaction(['products'], 'readwrite');
    const store = transaction.objectStore('products');
    
    for (const product of products) {
      await this.promisifyRequest(store.add(product));
    }
  }

  async searchProducts(query) {
    const transaction = this.db.transaction(['products'], 'readonly');
    const store = transaction.objectStore('products');
    const index = store.index('name');
    
    return this.promisifyRequest(index.getAll(query));
  }
}

// 2. 离线数据同步
class OfflineDataManager {
  async cacheServerData(data) {
    const transaction = this.db.transaction(['cache'], 'readwrite');
    const store = transaction.objectStore('cache');
    
    await this.promisifyRequest(store.put({
      id: 'serverData',
      data: data,
      timestamp: Date.now()
    }));
  }

  async syncWithServer() {
    // 获取离线期间的变更
    const changes = await this.getPendingChanges();
    
    // 上传到服务器
    for (const change of changes) {
      await this.uploadChange(change);
    }
  }
}

// 3. 复杂查询和分析
class DataAnalytics {
  async analyzeUserBehavior() {
    const transaction = this.db.transaction(['events'], 'readonly');
    const store = transaction.objectStore('events');
    const index = store.index('timestamp');
    
    const lastWeek = Date.now() - 7 * 24 * 60 * 60 * 1000;
    const range = IDBKeyRange.lowerBound(lastWeek);
    
    return new Promise((resolve) => {
      const results = [];
      const request = index.openCursor(range);
      
      request.onsuccess = function(event) {
        const cursor = event.target.result;
        if (cursor) {
          results.push(cursor.value);
          cursor.continue();
        } else {
          resolve(this.processAnalytics(results));
        }
      };
    });
  }
}
```



#### Cache API 适用场景

```javascript
// 1. Service Worker 资源缓存
self.addEventListener('install', event => {
  event.waitUntil(
    caches.open('static-v1').then(cache => {
      return cache.addAll([
        '/',
        '/styles/app.css',
        '/scripts/app.js',
        '/images/logo.png'
      ]);
    })
  );
});

// 2. API 响应缓存
class APICache {
  async cacheResponse(request, response) {
    const cache = await caches.open('api-cache');
    await cache.put(request, response.clone());
  }

  async getCachedResponse(request) {
    const cache = await caches.open('api-cache');
    return await cache.match(request);
  }
}

// 3. 动态内容缓存
self.addEventListener('fetch', event => {
  if (event.request.url.includes('/api/')) {
    event.respondWith(
      caches.open('dynamic-cache').then(cache => {
        return cache.match(event.request).then(response => {
          if (response) {
            // 后台更新
            fetch(event.request).then(fetchResponse => {
              cache.put(event.request, fetchResponse.clone());
            });
            return response;
          }
          
          return fetch(event.request).then(fetchResponse => {
            cache.put(event.request, fetchResponse.clone());
            return fetchResponse;
          });
        });
      })
    );
  }
});
```



### 选择决策树

```javascript
class StorageSelector {
  static selectStorage(requirements) {
    const {
      dataSize,
      dataType,
      persistence,
      queryComplexity,
      offline,
      sync
    } = requirements;

    // 大数据量 + 复杂查询 = IndexedDB
    if (dataSize > 10 * 1024 * 1024 || queryComplexity === 'high') {
      return 'IndexedDB';
    }

    // HTTP 响应缓存 = Cache API
    if (dataType === 'response' || offline) {
      return 'Cache API';
    }

    // 会话级数据 = sessionStorage
    if (persistence === 'session') {
      return 'sessionStorage';
    }

    // 简单持久化数据 = localStorage
    if (dataSize < 5 * 1024 * 1024 && queryComplexity === 'low') {
      return 'localStorage';
    }

    return 'IndexedDB'; // 默认推荐
  }

  static getRecommendation(scenario) {
    const scenarios = {
      'user-preferences': 'localStorage',
      'shopping-cart': 'localStorage',
      'form-draft': 'sessionStorage',
      'spa-state': 'sessionStorage',
      'product-catalog': 'IndexedDB',
      'offline-sync': 'IndexedDB',
      'static-assets': 'Cache API',
      'api-responses': 'Cache API'
    };

    return scenarios[scenario] || 'localStorage';
  }
}
```

## 总结

浏览器存储技术的发展体现了Web应用从简单页面向复杂应用的演进。每种存储技术都有其特定的适用场景：

- **localStorage/sessionStorage**：适合小量数据的简单存储
- **IndexedDB**：大量数据和复杂查询的首选
- **Cache API**：与Service Worker配合实现离线功能
- **Cookie**：仍然是服务器通信的重要手段



# 前端网络通信与安全



## Fetch API 与 XMLHttpRequest 深度对比

### 基本语法对比

#### XMLHttpRequest 传统方式

```javascript
// XMLHttpRequest 方式
const xhr = new XMLHttpRequest();
xhr.open('GET', '/api/data');
xhr.onreadystatechange = function() {
  if (xhr.readyState === 4 && xhr.status === 200) {
    const data = JSON.parse(xhr.responseText);
    console.log(data);
  }
};
xhr.send();
```



#### Fetch API 现代方式

```javascript
// Fetch API 方式
fetch('/api/data')
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error('Error:', error));

// 使用 async/await
async function fetchData() {
  try {
    const response = await fetch('/api/data');
    const data = await response.json();
    console.log(data);
  } catch (error) {
    console.error('Error:', error);
  }
}
```



![image-20250529095930516](C:/Users/27019/AppData/Roaming/Typora/typora-user-images/image-20250529095930516.png)

### 高级用法示例

#### Fetch API 高级配置

```javascript
const controller = new AbortController();
const timeoutId = setTimeout(() => controller.abort(), 5000);

try {
  const response = await fetch('/api/data', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': 'Bearer token'
    },
    body: JSON.stringify({ key: 'value' }),
    credentials: 'include', // 发送 cookies
    signal: controller.signal, // 支持取消
    cache: 'no-cache',
    mode: 'cors'
  });
  
  clearTimeout(timeoutId);
  
  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }
  
  const data = await response.json();
  return data;
} catch (error) {
  if (error.name === 'AbortError') {
    console.log('Request was aborted');
  } else {
    console.error('Fetch error:', error);
  }
}
```



## HTTP/2 与 HTTP/3 在前端性能优化中的应用‘

### HTTP/2 核心特性

#### 多路复用 (Multiplexing)

```javascript
// HTTP/1.1 需要限制并发连接数
const MAX_CONCURRENT = 6;
const requestQueue = [];

// HTTP/2 可以并发发送多个请求
async function loadResources() {
  const requests = [
    fetch('/api/user'),
    fetch('/api/posts'),
    fetch('/api/comments'),
    fetch('/api/notifications')
  ];
  
  const responses = await Promise.all(requests);
  return responses.map(r => r.json());
}
```

#### 服务器推送 (Server Push)

```javascript
// 检测资源是否被推送
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.addEventListener('message', event => {
    if (event.data.type === 'CACHE_UPDATED') {
      console.log('Resource pushed and cached:', event.data.url);
    }
  });
}
```



### HTTP/3 (QUIC) 优势

#### 连接迁移与快速握手

```javascript
// 检测 HTTP/3 支持
function detectHTTP3Support() {
  return new Promise((resolve) => {
    const img = new Image();
    const start = performance.now();
    
    img.onload = () => {
      const loadTime = performance.now() - start;
      resolve({
        supported: true,
        loadTime,
        protocol: 'h3' // HTTP/3
      });
    };
    
    img.onerror = () => resolve({ supported: false });
    img.src = '/test-h3-image.jpg';
  });
}
```





### 前端优化策略

#### 资源优先级设置

```javascript
// 使用 fetchpriority 属性
const criticalCSS = document.createElement('link');
criticalCSS.rel = 'stylesheet';
criticalCSS.href = '/critical.css';
criticalCSS.fetchPriority = 'high';

const lazyImage = document.createElement('img');
lazyImage.src = '/hero-image.jpg';
lazyImage.fetchPriority = 'low';

// Fetch API 中设置优先级
fetch('/api/critical-data', {
  priority: 'high'
});
```



## 深入理解跨域资源共享 (CORS) 与安全策略

###  CORS 工作原理

#### 简单请求条件

```javascript
// 简单请求 - 不会触发预检
fetch('/api/data', {
  method: 'GET', // GET, POST, HEAD
  headers: {
    'Content-Type': 'text/plain' // 简单头部
  }
});

// 复杂请求 - 会触发预检
fetch('/api/data', {
  method: 'PUT', // 非简单方法
  headers: {
    'Content-Type': 'application/json', // 非简单头部
    'X-Custom-Header': 'value'
  },
  body: JSON.stringify({ data: 'test' })
});
```



#### 预检请求处理

```javascript
// 前端无需特殊处理，浏览器自动发送 OPTIONS 请求
// 服务端需要正确响应预检请求

// 监听预检请求的结果
const observer = new PerformanceObserver((list) => {
  list.getEntries().forEach((entry) => {
    if (entry.name.includes('OPTIONS')) {
      console.log('Preflight request:', entry);
    }
  });
});
observer.observe({ entryTypes: ['navigation', 'resource'] });
```



### CORS 配置策略

#### 动态 CORS 处理

```javascript
// 客户端检测 CORS 支持
function checkCORSSupport(url) {
  return new Promise((resolve) => {
    const xhr = new XMLHttpRequest();
    xhr.open('GET', url);
    xhr.onload = () => resolve(true);
    xhr.onerror = () => resolve(false);
    xhr.send();
  });
}

// 跨域请求封装
class CORSFetcher {
  constructor(baseURL, options = {}) {
    this.baseURL = baseURL;
    this.defaultOptions = {
      credentials: 'include',
      mode: 'cors',
      ...options
    };
  }
  
  async request(endpoint, options = {}) {
    const url = `${this.baseURL}${endpoint}`;
    const config = { ...this.defaultOptions, ...options };
    
    try {
      const response = await fetch(url, config);
      
      if (!response.ok) {
        throw new Error(`CORS request failed: ${response.status}`);
      }
      
      return response;
    } catch (error) {
      if (error.name === 'TypeError') {
        throw new Error('CORS policy blocked the request');
      }
      throw error;
    }
  }
}
```



## WebSocket 协议实现原理与性能调优

### WebSocket 基础实现

#### 连接管理

```javascript
class WebSocketManager {
  constructor(url, options = {}) {
    this.url = url;
    this.options = {
      reconnectInterval: 3000,
      maxReconnectAttempts: 5,
      heartbeatInterval: 30000,
      ...options
    };
    this.reconnectAttempts = 0;
    this.isConnecting = false;
    this.heartbeatTimer = null;
    this.messageQueue = [];
  }
  
  connect() {
    if (this.isConnecting || (this.ws && this.ws.readyState === WebSocket.OPEN)) {
      return Promise.resolve();
    }
    
    this.isConnecting = true;
    
    return new Promise((resolve, reject) => {
      this.ws = new WebSocket(this.url);
      
      this.ws.onopen = (event) => {
        console.log('WebSocket connected');
        this.isConnecting = false;
        this.reconnectAttempts = 0;
        this.startHeartbeat();
        this.flushMessageQueue();
        resolve(event);
      };
      
      this.ws.onmessage = (event) => {
        this.handleMessage(event);
      };
      
      this.ws.onclose = (event) => {
        console.log('WebSocket closed:', event.code, event.reason);
        this.stopHeartbeat();
        this.handleReconnect();
      };
      
      this.ws.onerror = (error) => {
        console.error('WebSocket error:', error);
        this.isConnecting = false;
        reject(error);
      };
    });
  }
  
  send(data) {
    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify(data));
    } else {
      // 连接未建立时将消息加入队列
      this.messageQueue.push(data);
      this.connect();
    }
  }
  
  handleReconnect() {
    if (this.reconnectAttempts < this.options.maxReconnectAttempts) {
      this.reconnectAttempts++;
      console.log(`Attempting reconnect ${this.reconnectAttempts}/${this.options.maxReconnectAttempts}`);
      
      setTimeout(() => {
        this.connect();
      }, this.options.reconnectInterval);
    } else {
      console.error('Max reconnection attempts reached');
    }
  }
  
  startHeartbeat() {
    this.heartbeatTimer = setInterval(() => {
      if (this.ws && this.ws.readyState === WebSocket.OPEN) {
        this.ws.send(JSON.stringify({ type: 'ping' }));
      }
    }, this.options.heartbeatInterval);
  }
  
  stopHeartbeat() {
    if (this.heartbeatTimer) {
      clearInterval(this.heartbeatTimer);
      this.heartbeatTimer = null;
    }
  }
  
  flushMessageQueue() {
    while (this.messageQueue.length > 0) {
      const message = this.messageQueue.shift();
      this.send(message);
    }
  }
}
```

## 

### 性能优化策略

#### 消息批处理

```javascript
class BatchedWebSocket extends WebSocketManager {
  constructor(url, options = {}) {
    super(url, options);
    this.batchSize = options.batchSize || 10;
    this.batchTimeout = options.batchTimeout || 100;
    this.pendingMessages = [];
    this.batchTimer = null;
  }
  
  sendBatched(data) {
    this.pendingMessages.push(data);
    
    if (this.pendingMessages.length >= this.batchSize) {
      this.flushBatch();
    } else if (!this.batchTimer) {
      this.batchTimer = setTimeout(() => {
        this.flushBatch();
      }, this.batchTimeout);
    }
  }
  
  flushBatch() {
    if (this.pendingMessages.length > 0) {
      const batch = {
        type: 'batch',
        messages: this.pendingMessages.splice(0)
      };
      this.send(batch);
    }
    
    if (this.batchTimer) {
      clearTimeout(this.batchTimer);
      this.batchTimer = null;
    }
  }
}
```



## 服务端推送技术对比：SSE、WebSocket 与长轮询

### Server-Sent Events (SSE)

#### SSE 基础实现

```javascript
class SSEClient {
  constructor(url, options = {}) {
    this.url = url;
    this.options = {
      reconnectInterval: 3000,
      maxReconnectAttempts: 5,
      ...options
    };
    this.reconnectAttempts = 0;
    this.eventSource = null;
  }
  
  connect() {
    this.eventSource = new EventSource(this.url);
    
    this.eventSource.onopen = () => {
      console.log('SSE connection opened');
      this.reconnectAttempts = 0;
    };
    
    this.eventSource.onmessage = (event) => {
      const data = JSON.parse(event.data);
      this.handleMessage(data);
    };
    
    this.eventSource.onerror = () => {
      console.error('SSE connection error');
      this.handleReconnect();
    };
    
    // 监听自定义事件
    this.eventSource.addEventListener('custom-event', (event) => {
      console.log('Custom event received:', event.data);
    });
  }
  
  handleReconnect() {
    if (this.reconnectAttempts < this.options.maxReconnectAttempts) {
      this.reconnectAttempts++;
      setTimeout(() => {
        this.connect();
      }, this.options.reconnectInterval);
    }
  }
  
  close() {
    if (this.eventSource) {
      this.eventSource.close();
    }
  }
}
```



### 长轮询实现

#### 长轮询客户端

```javascript
class LongPolling {
  constructor(url, options = {}) {
    this.url = url;
    this.options = {
      timeout: 30000,
      reconnectInterval: 1000,
      maxReconnectAttempts: Infinity,
      ...options
    };
    this.isPolling = false;
    this.reconnectAttempts = 0;
  }
  
  start() {
    if (this.isPolling) return;
    this.isPolling = true;
    this.poll();
  }
  
  stop() {
    this.isPolling = false;
  }
  
  async poll() {
    while (this.isPolling) {
      try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), this.options.timeout);
        
        const response = await fetch(this.url, {
          signal: controller.signal,
          headers: {
            'Cache-Control': 'no-cache'
          }
        });
        
        clearTimeout(timeoutId);
        
        if (response.ok) {
          const data = await response.json();
          if (data && Object.keys(data).length > 0) {
            this.handleMessage(data);
          }
          this.reconnectAttempts = 0;
        } else {
          throw new Error(`HTTP ${response.status}`);
        }
        
      } catch (error) {
        if (error.name === 'AbortError') {
          console.log('Long polling timeout, retrying...');
        } else {
          console.error('Long polling error:', error);
          await this.wait(this.options.reconnectInterval);
        }
      }
    }
  }
  
  wait(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```

![image-20250529100154402](C:/Users/27019/AppData/Roaming/Typora/typora-user-images/image-20250529100154402.png)



##  内容安全策略 (CSP) 的设计与实施

### CSP 基础配置

#### CSP 头部设置

```javascript
// 基础 CSP 策略
const basicCSP = {
  'default-src': ["'self'"],
  'script-src': ["'self'", "'unsafe-inline'", 'https://cdn.example.com'],
  'style-src': ["'self'", "'unsafe-inline'", 'https://fonts.googleapis.com'],
  'img-src': ["'self'", 'data:', 'https:'],
  'font-src': ["'self'", 'https://fonts.gstatic.com'],
  'connect-src': ["'self'", 'https://api.example.com'],
  'frame-src': ["'none'"],
  'object-src': ["'none'"],
  'base-uri': ["'self'"],
  'form-action': ["'self'"]
};

// 生成 CSP 字符串
function generateCSP(policy) {
  return Object.entries(policy)
    .map(([directive, sources]) => `${directive} ${sources.join(' ')}`)
    .join('; ');
}
```



#### 动态 CSP 管理

```javascript
class CSPManager {
  constructor() {
    this.nonces = new Set();
    this.reportEndpoint = '/csp-report';
  }
  
  generateNonce() {
    const nonce = btoa(crypto.getRandomValues(new Uint8Array(16)));
    this.nonces.add(nonce);
    return nonce;
  }
  
  createSecureScript(code, nonce) {
    const script = document.createElement('script');
    script.nonce = nonce || this.generateNonce();
    script.textContent = code;
    return script;
  }
  
  reportViolation(violationReport) {
    fetch(this.reportEndpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(violationReport)
    });
  }
  
  setupReporting() {
    document.addEventListener('securitypolicyviolation', (event) => {
      const report = {
        documentURI: event.documentURI,
        referrer: event.referrer,
        blockedURI: event.blockedURI,
        violatedDirective: event.violatedDirective,
        originalPolicy: event.originalPolicy,
        sourceFile: event.sourceFile,
        lineNumber: event.lineNumber,
        columnNumber: event.columnNumber,
        timestamp: Date.now()
      };
      
      this.reportViolation(report);
    });
  }
}
```



### 渐进式 CSP 部署

#### CSP 兼容性检测

```javascript
class CSPDeployment {
  constructor() {
    this.isReportOnlyMode = true;
    this.violations = [];
  }
  
  enableReportOnlyMode() {
    const meta = document.createElement('meta');
    meta.httpEquiv = 'Content-Security-Policy-Report-Only';
    meta.content = this.generateRestrictiveCSP();
    document.head.appendChild(meta);
  }
  
  generateRestrictiveCSP() {
    return [
      "default-src 'self'",
      "script-src 'self' 'unsafe-eval'",
      "style-src 'self' 'unsafe-inline'",
      "img-src 'self' data: https:",
      "report-uri /csp-report"
    ].join('; ');
  }
  
  analyzeViolations() {
    const violationStats = this.violations.reduce((stats, violation) => {
      const directive = violation.violatedDirective;
      stats[directive] = (stats[directive] || 0) + 1;
      return stats;
    }, {});
    
    return violationStats;
  }
  
  generateOptimizedCSP() {
    const stats = this.analyzeViolations();
    // 基于违规统计生成优化的 CSP
    // 这里需要根据实际违规情况调整策略
  }
}
```



## 前端安全防御体系构建：XSS、CSRF、点击劫持等

### XSS 防护

#### 输入验证与输出编码

```javascript
class XSSProtection {
  // HTML 编码
  static escapeHTML(str) {
    const div = document.createElement('div');
    div.textContent = str;
    return div.innerHTML;
  }
  
  // JavaScript 编码
  static escapeJS(str) {
    return str.replace(/[\\'"<>]/g, (match) => {
      const escapeMap = {
        '\\': '\\\\',
        "'": "\\'",
        '"': '\\"',
        '<': '\\u003c',
        '>': '\\u003e'
      };
      return escapeMap[match];
    });
  }
  
  // URL 编码
  static escapeURL(str) {
    return encodeURIComponent(str);
  }
  
  // 安全的 innerHTML 替代
  static safeInnerHTML(element, htmlString) {
    // 使用 DOMPurify 或类似库
    if (typeof DOMPurify !== 'undefined') {
      element.innerHTML = DOMPurify.sanitize(htmlString);
    } else {
      // 简单的白名单过滤
      const cleanHTML = this.sanitizeHTML(htmlString);
      element.innerHTML = cleanHTML;
    }
  }
  
  // 简单的 HTML 净化
  static sanitizeHTML(html) {
    const allowedTags = ['p', 'br', 'strong', 'em', 'u', 'span'];
    const allowedAttributes = ['class', 'id'];
    
    // 这里应该使用专业的 HTML 净化库
    // 以下只是示例代码
    return html.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '');
  }
  
  // 内容安全策略检查
  static checkCSP() {
    const cspMeta = document.querySelector('meta[http-equiv="Content-Security-Policy"]');
    if (cspMeta) {
      const cspContent = cspMeta.getAttribute('content');
      return cspContent.includes("script-src") && !cspContent.includes("'unsafe-inline'");
    }
    return false;
  }
}

// 使用示例
const userInput = "<script>alert('XSS')</script>Hello World";
const safeOutput = XSSProtection.escapeHTML(userInput);
document.getElementById('output').textContent = safeOutput;
```



### CSRF 防护

#### Token 验证机制

```javascript
class CSRFProtection {
  constructor() {
    this.token = null;
    this.tokenExpiry = null;
    this.refreshThreshold = 5 * 60 * 1000; // 5分钟
  }
  
  async getToken() {
    if (!this.token || this.isTokenExpiring()) {
      await this.refreshToken();
    }
    return this.token;
  }
  
  async refreshToken() {
    try {
      const response = await fetch('/api/csrf-token', {
        method: 'GET',
        credentials: 'same-origin'
      });
      
      const data = await response.json();
      this.token = data.token;
      this.tokenExpiry = Date.now() + data.expiresIn;
    } catch (error) {
      console.error('Failed to refresh CSRF token:', error);
    }
  }
  
  isTokenExpiring() {
    return !this.tokenExpiry || (Date.now() + this.refreshThreshold) > this.tokenExpiry;
  }
  
  async makeSecureRequest(url, options = {}) {
    const token = await this.getToken();
    
    const secureOptions = {
      ...options,
      headers: {
        ...options.headers,
        'X-CSRF-Token': token
      },
      credentials: 'same-origin'
    };
    
    return fetch(url, secureOptions);
  }
  
  // 自动为表单添加 CSRF token
  protectForms() {
    document.addEventListener('submit', async (event) => {
      const form = event.target;
      if (form.tagName === 'FORM' && !form.querySelector('input[name="csrf_token"]')) {
        event.preventDefault();
        
        const token = await this.getToken();
        const tokenInput = document.createElement('input');
        tokenInput.type = 'hidden';
        tokenInput.name = 'csrf_token';
        tokenInput.value = token;
        form.appendChild(tokenInput);
        
        form.submit();
      }
    });
  }
}

// 全局 CSRF 保护实例
const csrfProtection = new CSRFProtection();
csrfProtection.protectForms();
```



### 点击劫持防护

#### Frame Busting 与 X-Frame-Options

```javascript
class ClickjackingProtection {
  constructor() {
    this.init();
  }
  
  init() {
    this.preventFraming();
    this.setupFrameKiller();
    this.monitorFrameChanges();
  }
  
  // 检查是否在 iframe 中
  isInFrame() {
    return window.self !== window.top;
  }
  
  // 防止页面被嵌入 iframe
  preventFraming() {
    if (this.isInFrame()) {
      // 尝试跳出 iframe
      try {
        window.top.location = window.location;
      } catch (e) {
        // 如果跳出失败，隐藏页面内容
        document.body.style.display = 'none';
        this.showWarning();
      }
    }
  }
  
  // 设置 frame killer
  setupFrameKiller() {
    let bust = false;
    
    if (window.top !== window.self) {
      try {
        if (window.top.location.hostname !== window.location.hostname) {
          bust = true;
        }
      } catch (ex) {
        bust = true;
      }
    }
    
    if (bust) {
      window.top.location = window.self.location;
    }
  }
  
  // 监控 frame 环境变化
  monitorFrameChanges() {
    setInterval(() => {
      if (this.isInFrame() && !this.isAllowedFrame()) {
        this.preventFraming();
      }
    }, 1000);
  }
  
  // 检查是否为允许的 frame
  isAllowedFrame() {
    const allowedDomains = ['trusted-domain.com', 'partner-site.com'];
    
    try {
      const parentHostname = window.parent.location.hostname;
      return allowedDomains.includes(parentHostname);
    } catch (e) {
      return false;
    }
  }
  
  // 显示警告信息
  showWarning() {
    const warning = document.createElement('div');
    warning.innerHTML = `
      <div style="
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: #f44336;
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 24px;
        z-index: 999999;
      ">
        安全警告：此页面不应在框架中显示
        <br>
        <a href="${window.location.href}" style="color: white; text-decoration: underline;">
          点击此处在新窗口中打开
        </a>
      </div>
    `;
    document.body.appendChild(warning);
  }
}

// 启用点击劫持保护
new ClickjackingProtection();
```



### 综合安全防护

#### 安全检查器

```javascript
class SecurityChecker {
  constructor() {
    this.checks = [
      this.checkHTTPS,
      this.checkCSP,
      this.checkXFrameOptions,
      this.checkSecureCookies,
      this.checkMixedContent
    ];
  }
  
  async runAllChecks() {
    const results = await Promise.all(
      this.checks.map(check => this.runCheck(check))
    );
    
    return {
      passed: results.filter(r => r.passed).length,
      failed: results.filter(r => !r.passed).length,
      total: results.length,
      details: results
    };
  }
  
  async runCheck(checkFunction) {
    try {
      const result = await checkFunction.call(this);
      return { ...result, error: null };
    } catch (error) {
      return {
        name: checkFunction.name,
        passed: false,
        message: `检查失败: ${error.message}`,
        error: error
      };
    }
  }
  
  checkHTTPS() {
    const isHTTPS = location.protocol === 'https:';
    return {
      name: 'HTTPS检查',
      passed: isHTTPS,
      message: isHTTPS ? 'HTTPS已启用' : '建议使用HTTPS协议',
      severity: isHTTPS ? 'low' : 'high'
    };
  }
  
  checkCSP() {
    const cspHeader = document.querySelector('meta[http-equiv="Content-Security-Policy"]');
    const hasCSP = !!cspHeader;
    
    let cspQuality = 'none';
    if (hasCSP) {
      const content = cspHeader.getAttribute('content');
      if (content.includes("'unsafe-inline'") || content.includes("'unsafe-eval'")) {
        cspQuality = 'weak';
      } else {
        cspQuality = 'strong';
      }
    }
    
    return {
      name: 'CSP检查',
      passed: hasCSP && cspQuality === 'strong',
      message: `CSP状态: ${cspQuality}`,
      severity: cspQuality === 'none' ? 'high' : cspQuality === 'weak' ? 'medium' : 'low'
    };
  }
  
  checkXFrameOptions() {
    return new Promise((resolve) => {
      // 检查 X-Frame-Options 通过发送请求到自身
      fetch(window.location.href, { method: 'HEAD' })
        .then(response => {
          const xFrameOptions = response.headers.get('X-Frame-Options');
          const hasProtection = !!xFrameOptions;
          
          resolve({
            name: 'X-Frame-Options检查',
            passed: hasProtection,
            message: hasProtection ? `X-Frame-Options: ${xFrameOptions}` : '缺少X-Frame-Options头部',
            severity: hasProtection ? 'low' : 'medium'
          });
        })
        .catch(() => {
          resolve({
            name: 'X-Frame-Options检查',
            passed: false,
            message: '无法检查X-Frame-Options',
            severity: 'medium'
          });
        });
    });
  }
  
  checkSecureCookies() {
    const cookies = document.cookie.split(';');
    const insecureCookies = cookies.filter(cookie => {
      return cookie.trim() && !cookie.includes('Secure') && !cookie.includes('HttpOnly');
    });
    
    return {
      name: '安全Cookie检查',
      passed: insecureCookies.length === 0,
      message: insecureCookies.length > 0 ? 
        `发现 ${insecureCookies.length} 个不安全的Cookie` : 
        '所有Cookie都具有安全标志',
      severity: insecureCookies.length > 0 ? 'medium' : 'low'
    };
  }
  
  checkMixedContent() {
    const insecureResources = [];
    
    // 检查图片
    document.querySelectorAll('img[src^="http:"]').forEach(img => {
      insecureResources.push({ type: 'image', url: img.src });
    });
    
    // 检查脚本
    document.querySelectorAll('script[src^="http:"]').forEach(script => {
      insecureResources.push({ type: 'script', url: script.src });
    });
    
    // 检查样式表
    document.querySelectorAll('link[href^="http:"]').forEach(link => {
      insecureResources.push({ type: 'stylesheet', url: link.href });
    });
    
    return {
      name: '混合内容检查',
      passed: insecureResources.length === 0,
      message: insecureResources.length > 0 ? 
        `发现 ${insecureResources.length} 个不安全的资源` : 
        '未发现混合内容',
      details: insecureResources,
      severity: insecureResources.length > 0 ? 'high' : 'low'
    };
  }
  
  generateReport(results) {
    const report = {
      timestamp: new Date().toISOString(),
      url: window.location.href,
      userAgent: navigator.userAgent,
      summary: {
        total: results.total,
        passed: results.passed,
        failed: results.failed,
        score: Math.round((results.passed / results.total) * 100)
      },
      checks: results.details,
      recommendations: this.generateRecommendations(results.details)
    };
    
    return report;
  }
  
  generateRecommendations(checks) {
    const recommendations = [];
    
    checks.forEach(check => {
      if (!check.passed) {
        switch (check.name) {
          case 'HTTPS检查':
            recommendations.push({
              priority: 'high',
              action: '启用HTTPS',
              description: '使用SSL/TLS证书保护数据传输'
            });
            break;
          case 'CSP检查':
            recommendations.push({
              priority: 'high',
              action: '配置内容安全策略',
              description: '实施严格的CSP以防止XSS攻击'
            });
            break;
          case 'X-Frame-Options检查':
            recommendations.push({
              priority: 'medium',
              action: '设置X-Frame-Options头部',
              description: '防止点击劫持攻击'
            });
            break;
          case '安全Cookie检查':
            recommendations.push({
              priority: 'medium',
              action: '为Cookie添加安全标志',
              description: '使用Secure和HttpOnly标志保护Cookie'
            });
            break;
          case '混合内容检查':
            recommendations.push({
              priority: 'high',
              action: '修复混合内容',
              description: '将所有HTTP资源升级为HTTPS'
            });
            break;
        }
      }
    });
    
    return recommendations.sort((a, b) => {
      const priority = { high: 3, medium: 2, low: 1 };
      return priority[b.priority] - priority[a.priority];
    });
  }
}

// 安全监控和报告
class SecurityMonitor {
  constructor() {
    this.checker = new SecurityChecker();
    this.alertThreshold = 60; // 安全评分阈值
    this.monitoringInterval = 5 * 60 * 1000; // 5分钟
    this.isMonitoring = false;
  }
  
  async startMonitoring() {
    if (this.isMonitoring) return;
    
    this.isMonitoring = true;
    console.log('安全监控已启动');
    
    // 立即执行一次检查
    await this.performSecurityCheck();
    
    // 定期检查
    this.monitoringTimer = setInterval(async () => {
      await this.performSecurityCheck();
    }, this.monitoringInterval);
  }
  
  stopMonitoring() {
    this.isMonitoring = false;
    if (this.monitoringTimer) {
      clearInterval(this.monitoringTimer);
    }
    console.log('安全监控已停止');
  }
  
  async performSecurityCheck() {
    try {
      const results = await this.checker.runAllChecks();
      const report = this.checker.generateReport(results);
      
      console.log('安全检查报告:', report);
      
      if (report.summary.score < this.alertThreshold) {
        this.triggerSecurityAlert(report);
      }
      
      // 发送报告到监控服务
      this.sendReport(report);
      
      return report;
    } catch (error) {
      console.error('安全检查失败:', error);
    }
  }
  
  triggerSecurityAlert(report) {
    const alert = {
      type: 'security_alert',
      severity: 'warning',
      score: report.summary.score,
      timestamp: report.timestamp,
      url: report.url,
      failedChecks: report.checks.filter(check => !check.passed),
      recommendations: report.recommendations.slice(0, 3) // 前3个优先级最高的建议
    };
    
    console.warn('🚨 安全警报:', alert);
    
    // 可以在这里实现通知机制
    this.showSecurityNotification(alert);
  }
  
  showSecurityNotification(alert) {
    // 创建安全通知UI
    if (!document.getElementById('security-notification')) {
      const notification = document.createElement('div');
      notification.id = 'security-notification';
      notification.innerHTML = `
        <div style="
          position: fixed;
          top: 20px;
          right: 20px;
          background: #ff5722;
          color: white;
          padding: 15px;
          border-radius: 5px;
          box-shadow: 0 4px 6px rgba(0,0,0,0.1);
          z-index: 10000;
          max-width: 300px;
          font-family: Arial, sans-serif;
        ">
          <div style="font-weight: bold; margin-bottom: 10px;">
            🚨 安全警报
          </div>
          <div style="font-size: 14px; margin-bottom: 10px;">
            安全评分: ${alert.score}%
          </div>
          <div style="font-size: 12px; margin-bottom: 10px;">
            发现 ${alert.failedChecks.length} 个安全问题
          </div>
          <button onclick="this.parentElement.parentElement.remove()" style="
            background: white;
            color: #ff5722;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
          ">
            关闭
          </button>
        </div>
      `;
      document.body.appendChild(notification);
      
      // 5秒后自动移除
      setTimeout(() => {
        const elem = document.getElementById('security-notification');
        if (elem) elem.remove();
      }, 5000);
    }
  }
  
  async sendReport(report) {
    try {
      await fetch('/api/security-report', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(report)
      });
    } catch (error) {
      console.error('发送安全报告失败:', error);
    }
  }
}

// 实用工具函数
class SecurityUtils {
  // 生成安全的随机字符串
  static generateSecureRandom(length = 32) {
    const array = new Uint8Array(length);
    crypto.getRandomValues(array);
    return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
  }
  
  // 安全的字符串比较（防止时序攻击）
  static safeStringCompare(a, b) {
    if (a.length !== b.length) {
      return false;
    }
    
    let result = 0;
    for (let i = 0; i < a.length; i++) {
      result |= a.charCodeAt(i) ^ b.charCodeAt(i);
    }
    
    return result === 0;
  }
  
  // 检测潜在的恶意载荷
  static detectMaliciousPayload(input) {
    const patterns = [
      /<script[^>]*>.*?<\/script>/gi,
      /javascript:/gi,
      /on\w+\s*=/gi,
      /<iframe[^>]*>/gi,
      /eval\s*\(/gi,
      /document\.write/gi,
      /window\.location/gi
    ];
    
    return patterns.some(pattern => pattern.test(input));
  }
  
  // 安全的JSON解析
  static safeJSONParse(jsonString, defaultValue = null) {
    try {
      const parsed = JSON.parse(jsonString);
      
      // 检查是否包含潜在危险的内容
      const stringified = JSON.stringify(parsed);
      if (this.detectMaliciousPayload(stringified)) {
        console.warn('检测到潜在恶意JSON载荷');
        return defaultValue;
      }
      
      return parsed;
    } catch (error) {
      console.error('JSON解析失败:', error);
      return defaultValue;
    }
  }
  
  // 创建安全的事件监听器
  static addSecureEventListener(element, event, handler, options = {}) {
    const secureHandler = (e) => {
      // 添加基本的安全检查
      if (e.isTrusted === false) {
        console.warn('检测到不可信事件，已阻止处理');
        return;
      }
      
      try {
        handler(e);
      } catch (error) {
        console.error('事件处理器执行失败:', error);
      }
    };
    
    element.addEventListener(event, secureHandler, {
      passive: true,
      ...options
    });
    
    return () => element.removeEventListener(event, secureHandler);
  }
}

// 使用示例和最佳实践
class SecurityBestPractices {
  static init() {
    console.log('🔒 初始化前端安全防护系统');
    
    // 启动安全监控
    const monitor = new SecurityMonitor();
    monitor.startMonitoring();
    
    // 设置全局错误处理
    this.setupGlobalErrorHandling();
    
    // 设置安全头部检查
    this.checkSecurityHeaders();
    
    // 设置内容完整性检查
    this.setupIntegrityChecks();
    
    console.log('✅ 前端安全防护系统已启动');
  }
  
  static setupGlobalErrorHandling() {
    window.addEventListener('error', (event) => {
      // 记录脚本错误
      console.error('脚本错误:', {
        message: event.message,
        filename: event.filename,
        lineno: event.lineno,
        colno: event.colno,
        error: event.error
      });
    });
    
    window.addEventListener('unhandledrejection', (event) => {
      // 记录未处理的Promise拒绝
      console.error('未处理的Promise拒绝:', event.reason);
    });
  }
  
  static checkSecurityHeaders() {
    fetch(window.location.href, { method: 'HEAD' })
      .then(response => {
        const headers = {
          'Strict-Transport-Security': response.headers.get('Strict-Transport-Security'),
          'X-Content-Type-Options': response.headers.get('X-Content-Type-Options'),
          'X-Frame-Options': response.headers.get('X-Frame-Options'),
          'X-XSS-Protection': response.headers.get('X-XSS-Protection'),
          'Referrer-Policy': response.headers.get('Referrer-Policy')
        };
        
        console.log('安全头部检查:', headers);
      })
      .catch(error => {
        console.error('无法检查安全头部:', error);
      });
  }
  
  static setupIntegrityChecks() {
    // 检查所有脚本和样式表的完整性
    const resources = document.querySelectorAll('script[src], link[rel="stylesheet"]');
    
    resources.forEach(resource => {
      if (!resource.integrity) {
        console.warn('资源缺少完整性检查:', resource.src || resource.href);
      }
    });
  }
}

// 页面加载完成后自动初始化安全系统
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', SecurityBestPractices.init);
} else {
  SecurityBestPractices.init();
}
```

## 总结

### 安全检查清单

#### 开发阶段

-  实施内容安全策略 (CSP)
-  配置安全HTTP头部
-  使用HTTPS和安全Cookie
-  实施输入验证和输出编码
-  配置CORS策略
-  添加CSRF保护

#### 部署阶段

-  启用HSTS
-  配置X-Frame-Options
-  设置X-Content-Type-Options
-  实施完整性检查
-  配置安全的Referrer策略

#### 监控阶段

-  设置CSP报告
-  监控安全事件
-  定期安全评估
-  更新安全策略
-  响应安全事件

### 性能与安全平衡

在实施安全措施时，需要在安全性和性能之间找到平衡点：

1. **CSP策略**: 逐步收紧，避免一次性过于严格
2. **CORS配置**: 精确配置来源，避免使用通配符
3. **加密通信**: 使用现代TLS版本和密码套件
4. **资源完整性**: 对关键资源启用SRI检查
5. **监控报告**: 合理设置报告频率，避免过多噪音



