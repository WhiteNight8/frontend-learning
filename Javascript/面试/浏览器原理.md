# æ·±å…¥ç†è§£æµè§ˆå™¨æ¸²æŸ“æœºåˆ¶ä¸æ€§èƒ½ä¼˜åŒ–



## æµè§ˆå™¨æ¸²æŸ“å¼•æ“å·¥ä½œåŸç†ä¸å…³é”®æ¸²æŸ“è·¯å¾„

### æ¸²æŸ“å¼•æ“æ¶æ„

æµè§ˆå™¨æ¸²æŸ“å¼•æ“ï¼ˆå¦‚Blinkã€WebKitã€Geckoï¼‰è´Ÿè´£è§£æHTMLã€CSSå’ŒJavaScriptï¼Œå°†å…¶è½¬æ¢ä¸ºç”¨æˆ·å¯è§çš„é¡µé¢ã€‚

### å…³é”®æ¸²æŸ“è·¯å¾„ï¼ˆCritical Rendering Pathï¼‰

å…³é”®æ¸²æŸ“è·¯å¾„åŒ…å«6ä¸ªä¸»è¦æ­¥éª¤ï¼š

**1. HTMLè§£æ â†’ DOMæ ‘æ„å»º**

```html
<!-- HTMLæ–‡æ¡£ -->
<html>
  <head>
    <title>é¡µé¢æ ‡é¢˜</title>
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="container">
      <h1>æ ‡é¢˜</h1>
      <p>å†…å®¹</p>
    </div>
  </body>
</html>
```

**2. CSSè§£æ â†’ CSSOMæ ‘æ„å»º**

```css
/* CSSæ ·å¼ */
.container {
  width: 100%;
  padding: 20px;
}

h1 {
  color: #333;
  font-size: 24px;
}
```

**3. DOM + CSSOM â†’ æ¸²æŸ“æ ‘ï¼ˆRender Treeï¼‰** æ¸²æŸ“æ ‘åªåŒ…å«éœ€è¦æ˜¾ç¤ºçš„èŠ‚ç‚¹å’Œæ ·å¼ä¿¡æ¯ï¼Œä¸åŒ…å«`display: none`çš„å…ƒç´ ã€‚

**4. å¸ƒå±€ï¼ˆLayout/Reflowï¼‰** è®¡ç®—æ¯ä¸ªèŠ‚ç‚¹åœ¨å±å¹•ä¸Šçš„ç¡®åˆ‡ä½ç½®å’Œå°ºå¯¸ã€‚

**5. ç»˜åˆ¶ï¼ˆPaintï¼‰** å°†æ¸²æŸ“æ ‘ä¸­çš„æ¯ä¸ªèŠ‚ç‚¹è½¬æ¢ä¸ºå±å¹•ä¸Šçš„å®é™…åƒç´ ã€‚

**6. åˆæˆï¼ˆCompositeï¼‰** å°†å„ä¸ªå›¾å±‚åˆå¹¶åˆ°æœ€ç»ˆçš„å±å¹•å›¾åƒä¸­ã€‚

### ä¼˜åŒ–å…³é”®æ¸²æŸ“è·¯å¾„

```html
<!DOCTYPE html>
<html>
<head>
  <!-- å†…è”å…³é”®CSS -->
  <style>
    .above-fold { display: block; }
  </style>
  
  <!-- å¼‚æ­¥åŠ è½½éå…³é”®CSS -->
  <link rel="preload" href="non-critical.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
  
  <!-- é¢„åŠ è½½å…³é”®èµ„æº -->
  <link rel="preload" href="hero-image.jpg" as="image">
</head>
<body>
  <!-- å…³é”®å†…å®¹ -->
  <div class="above-fold">é¦–å±å†…å®¹</div>
  
  <!-- å»¶è¿ŸåŠ è½½JavaScript -->
  <script src="main.js" defer></script>
</body>
</html>
```



## æ·±å…¥ç†è§£å›æµä¸é‡ç»˜çš„è§¦å‘æœºåˆ¶åŠä¼˜åŒ–ç­–ç•¥

### å›æµï¼ˆReflowï¼‰è§¦å‘æ¡ä»¶

å›æµä¼šé‡æ–°è®¡ç®—å…ƒç´ çš„å‡ ä½•å±æ€§ï¼š

javascript

```javascript
// è§¦å‘å›æµçš„æ“ä½œ
const element = document.getElementById('box');

// 1. ä¿®æ”¹ç›’æ¨¡å‹ç›¸å…³å±æ€§
element.style.width = '200px';
element.style.height = '200px';
element.style.padding = '10px';
element.style.margin = '20px';
element.style.border = '1px solid red';

// 2. ä¿®æ”¹å®šä½ç›¸å…³å±æ€§
element.style.position = 'absolute';
element.style.top = '100px';
element.style.left = '100px';

// 3. ä¿®æ”¹å­—ä½“ç›¸å…³å±æ€§
element.style.fontSize = '16px';
element.style.fontFamily = 'Arial';
element.style.lineHeight = '1.5';

// 4. æ·»åŠ /åˆ é™¤DOMèŠ‚ç‚¹
document.body.appendChild(newElement);
element.parentNode.removeChild(element);

// 5. è·å–ç‰¹å®šå±æ€§æ—¶å¼ºåˆ¶å›æµ
const width = element.offsetWidth;
const height = element.offsetHeight;
const rect = element.getBoundingClientRect();
```

### é‡ç»˜ï¼ˆRepaintï¼‰è§¦å‘æ¡ä»¶

é‡ç»˜ä¸ä¼šæ”¹å˜å…ƒç´ å‡ ä½•å±æ€§ï¼Œåªæ”¹å˜å¤–è§‚ï¼š

javascript

```javascript
// åªè§¦å‘é‡ç»˜çš„æ“ä½œ
element.style.color = 'red';
element.style.backgroundColor = 'blue';
element.style.boxShadow = '0 0 10px rgba(0,0,0,0.5)';
element.style.borderRadius = '5px';
element.style.visibility = 'hidden'; // æ³¨æ„ï¼šdisplay:noneä¼šè§¦å‘å›æµ
```

### ä¼˜åŒ–ç­–ç•¥

**1. æ‰¹é‡DOMæ“ä½œ**

```javascript
// ä¸å¥½çš„åšæ³• - å¤šæ¬¡å›æµ
const list = document.getElementById('list');
for (let i = 0; i < 1000; i++) {
  const item = document.createElement('li');
  item.textContent = `Item ${i}`;
  list.appendChild(item); // æ¯æ¬¡éƒ½è§¦å‘å›æµ
}

// å¥½çš„åšæ³• - ä½¿ç”¨DocumentFragment
const fragment = document.createDocumentFragment();
for (let i = 0; i < 1000; i++) {
  const item = document.createElement('li');
  item.textContent = `Item ${i}`;
  fragment.appendChild(item);
}
list.appendChild(fragment); // åªè§¦å‘ä¸€æ¬¡å›æµ
```

**2. ä½¿ç”¨CSSç±»è€Œéå†…è”æ ·å¼**

```javascript
// ä¸å¥½çš„åšæ³•
element.style.width = '200px';
element.style.height = '200px';
element.style.backgroundColor = 'red';

// å¥½çš„åšæ³•
element.className = 'optimized-style';
```

**3. ç¼“å­˜DOMæŸ¥è¯¢ç»“æœ**

```javascript
// ä¸å¥½çš„åšæ³•
for (let i = 0; i < 1000; i++) {
  document.getElementById('box').style.left = i + 'px'; // æ¯æ¬¡éƒ½æŸ¥è¯¢DOM
}

// å¥½çš„åšæ³•
const box = document.getElementById('box');
for (let i = 0; i < 1000; i++) {
  box.style.left = i + 'px';
}
```

**4. ä½¿ç”¨transformå’Œopacityå®ç°åŠ¨ç”»**

```css
/* è§¦å‘å›æµé‡ç»˜çš„åŠ¨ç”» */
.element {
  transition: left 0.3s ease;
}
.element:hover {
  left: 100px; /* è§¦å‘å›æµ */
}

/* åªè§¦å‘åˆæˆå±‚çš„åŠ¨ç”» */
.element {
  transition: transform 0.3s ease;
}
.element:hover {
  transform: translateX(100px); /* åªè§¦å‘åˆæˆ */
}
```



##  Shadow DOM ä¸ Web Components çš„å®ç°åŸç†

### Shadow DOM åŸºç¡€æ¦‚å¿µ

Shadow DOM æä¾›äº†ç»„ä»¶çº§åˆ«çš„DOMå°è£…å’Œæ ·å¼éš”ç¦»ã€‚

```javascript
// åˆ›å»ºè‡ªå®šä¹‰å…ƒç´ 
class CustomButton extends HTMLElement {
  constructor() {
    super();
    
    // åˆ›å»ºShadow Root
    this.attachShadow({ mode: 'open' });
    
    // åˆ›å»ºæ¨¡æ¿
    const template = document.createElement('template');
    template.innerHTML = `
      <style>
        :host {
          display: inline-block;
          padding: 10px 20px;
          background: #007bff;
          color: white;
          border: none;
          border-radius: 4px;
          cursor: pointer;
        }
        
        :host(:hover) {
          background: #0056b3;
        }
        
        .button-content {
          display: flex;
          align-items: center;
          gap: 8px;
        }
        
        ::slotted(.icon) {
          width: 16px;
          height: 16px;
        }
      </style>
      
      <button class="button-content">
        <slot name="icon"></slot>
        <slot></slot>
      </button>
    `;
    
    // å°†æ¨¡æ¿å†…å®¹å…‹éš†åˆ°Shadow DOMä¸­
    this.shadowRoot.appendChild(template.content.cloneNode(true));
  }
  
  connectedCallback() {
    // å…ƒç´ è¢«æ’å…¥DOMæ—¶è°ƒç”¨
    this.addEventListener('click', this.handleClick);
  }
  
  disconnectedCallback() {
    // å…ƒç´ ä»DOMä¸­ç§»é™¤æ—¶è°ƒç”¨
    this.removeEventListener('click', this.handleClick);
  }
  
  handleClick = (event) => {
    // æ´¾å‘è‡ªå®šä¹‰äº‹ä»¶
    this.dispatchEvent(new CustomEvent('custom-click', {
      detail: { originalEvent: event },
      bubbles: true
    }));
  }
}

// æ³¨å†Œè‡ªå®šä¹‰å…ƒç´ 
customElements.define('custom-button', CustomButton);
```

### ä½¿ç”¨Web Components

```html
<!-- HTMLä¸­ä½¿ç”¨è‡ªå®šä¹‰å…ƒç´  -->
<custom-button>
  <span slot="icon">ğŸš€</span>
  ç‚¹å‡»æˆ‘
</custom-button>

<script>
// ç›‘å¬è‡ªå®šä¹‰äº‹ä»¶
document.addEventListener('custom-click', (event) => {
  console.log('æŒ‰é’®è¢«ç‚¹å‡»äº†', event.detail);
});
</script>
```

### é«˜çº§Web Componentsç‰¹æ€§

```javascript
class DataTable extends HTMLElement {
  static get observedAttributes() {
    return ['data-source', 'columns'];
  }
  
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
    this.data = [];
    this.columns = [];
  }
  
  attributeChangedCallback(name, oldValue, newValue) {
    if (name === 'data-source') {
      this.loadData(newValue);
    } else if (name === 'columns') {
      this.columns = JSON.parse(newValue);
      this.render();
    }
  }
  
  async loadData(url) {
    try {
      const response = await fetch(url);
      this.data = await response.json();
      this.render();
    } catch (error) {
      console.error('åŠ è½½æ•°æ®å¤±è´¥:', error);
    }
  }
  
  render() {
    const template = `
      <style>
        table {
          width: 100%;
          border-collapse: collapse;
        }
        th, td {
          padding: 8px 12px;
          border: 1px solid #ddd;
          text-align: left;
        }
        th {
          background-color: #f5f5f5;
          font-weight: bold;
        }
      </style>
      
      <table>
        <thead>
          <tr>
            ${this.columns.map(col => `<th>${col.title}</th>`).join('')}
          </tr>
        </thead>
        <tbody>
          ${this.data.map(row => `
            <tr>
              ${this.columns.map(col => `<td>${row[col.key] || ''}</td>`).join('')}
            </tr>
          `).join('')}
        </tbody>
      </table>
    `;
    
    this.shadowRoot.innerHTML = template;
  }
}

customElements.define('data-table', DataTable);
```



## å¤æ‚DOMæ“ä½œçš„é«˜æ€§èƒ½å®ç°ç­–ç•¥

### è™šæ‹Ÿæ»šåŠ¨å®ç°

```javascript
class VirtualScrollList {
  constructor(container, itemHeight, totalItems, renderItem) {
    this.container = container;
    this.itemHeight = itemHeight;
    this.totalItems = totalItems;
    this.renderItem = renderItem;
    
    this.viewportHeight = container.clientHeight;
    this.visibleCount = Math.ceil(this.viewportHeight / itemHeight) + 1;
    this.buffer = 5; // ç¼“å†²åŒºé¡¹ç›®æ•°
    
    this.init();
  }
  
  init() {
    // åˆ›å»ºæ»šåŠ¨å®¹å™¨
    this.scrollElement = document.createElement('div');
    this.scrollElement.style.height = `${this.totalItems * this.itemHeight}px`;
    this.scrollElement.style.position = 'relative';
    
    // åˆ›å»ºå¯è§åŒºåŸŸå®¹å™¨
    this.visibleContainer = document.createElement('div');
    this.visibleContainer.style.position = 'absolute';
    this.visibleContainer.style.top = '0';
    this.visibleContainer.style.width = '100%';
    
    this.scrollElement.appendChild(this.visibleContainer);
    this.container.appendChild(this.scrollElement);
    
    // ç›‘å¬æ»šåŠ¨äº‹ä»¶
    this.container.addEventListener('scroll', this.handleScroll.bind(this));
    
    this.render();
  }
  
  handleScroll() {
    // ä½¿ç”¨requestAnimationFrameä¼˜åŒ–æ»šåŠ¨æ€§èƒ½
    if (this.scrollRAF) {
      cancelAnimationFrame(this.scrollRAF);
    }
    
    this.scrollRAF = requestAnimationFrame(() => {
      this.render();
    });
  }
  
  render() {
    const scrollTop = this.container.scrollTop;
    const startIndex = Math.max(0, Math.floor(scrollTop / this.itemHeight) - this.buffer);
    const endIndex = Math.min(
      this.totalItems - 1,
      startIndex + this.visibleCount + this.buffer * 2
    );
    
    // æ¸…ç©ºå½“å‰å†…å®¹
    this.visibleContainer.innerHTML = '';
    
    // è®¾ç½®å®¹å™¨ä½ç½®
    this.visibleContainer.style.transform = `translateY(${startIndex * this.itemHeight}px)`;
    
    // æ¸²æŸ“å¯è§é¡¹ç›®
    for (let i = startIndex; i <= endIndex; i++) {
      const item = this.renderItem(i);
      item.style.height = `${this.itemHeight}px`;
      this.visibleContainer.appendChild(item);
    }
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const renderItem = (index) => {
  const div = document.createElement('div');
  div.textContent = `Item ${index}`;
  div.style.padding = '10px';
  div.style.borderBottom = '1px solid #eee';
  return div;
};

const virtualList = new VirtualScrollList(
  document.getElementById('list-container'),
  50, // æ¯é¡¹é«˜åº¦
  10000, // æ€»é¡¹ç›®æ•°
  renderItem
);
```

### é«˜æ•ˆçš„DOMæ›´æ–°ç­–ç•¥

```javascript
class DOMBatcher {
  constructor() {
    this.updates = [];
    this.rafId = null;
  }
  
  // æ‰¹é‡æ·»åŠ æ›´æ–°æ“ä½œ
  batch(updateFn) {
    this.updates.push(updateFn);
    
    if (!this.rafId) {
      this.rafId = requestAnimationFrame(() => {
        this.flush();
      });
    }
  }
  
  // æ‰§è¡Œæ‰€æœ‰æ‰¹é‡æ›´æ–°
  flush() {
    // å…ˆæ‰§è¡Œæ‰€æœ‰è¯»å–æ“ä½œ
    const reads = this.updates.filter(update => update.type === 'read');
    reads.forEach(update => update.fn());
    
    // å†æ‰§è¡Œæ‰€æœ‰å†™å…¥æ“ä½œ
    const writes = this.updates.filter(update => update.type === 'write');
    writes.forEach(update => update.fn());
    
    // æ¸…ç©ºé˜Ÿåˆ—
    this.updates = [];
    this.rafId = null;
  }
  
  // è¯»å–æ“ä½œ
  read(fn) {
    this.batch({ type: 'read', fn });
  }
  
  // å†™å…¥æ“ä½œ
  write(fn) {
    this.batch({ type: 'write', fn });
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const batcher = new DOMBatcher();

// æ‰¹é‡å¤„ç†å¤šä¸ªå…ƒç´ çš„æ ·å¼æ›´æ–°
const elements = document.querySelectorAll('.animate-element');
elements.forEach((el, index) => {
  batcher.read(() => {
    // è¯»å–å½“å‰çŠ¶æ€
    const rect = el.getBoundingClientRect();
  });
  
  batcher.write(() => {
    // æ›´æ–°æ ·å¼
    el.style.transform = `translateX(${index * 10}px)`;
  });
});
```



## æµè§ˆå™¨å¸ƒå±€ç³»ç»Ÿä¸CSSå¼•æ“å·¥ä½œæœºåˆ¶

### å¸ƒå±€ç®—æ³•ç†è§£

```css
/* Flexå¸ƒå±€è®¡ç®—æµç¨‹ */
.flex-container {
  display: flex;
  width: 800px;
  height: 200px;
}

.flex-item {
  flex: 1 1 auto; /* flex-grow: 1, flex-shrink: 1, flex-basis: auto */
  min-width: 100px;
  max-width: 300px;
}
```

### CSSå¼•æ“ä¼˜åŒ–æŠ€å·§

```css
/* 1. ä½¿ç”¨CSS containmentä¼˜åŒ– */
.component {
  contain: layout style paint;
}

/* 2. åˆ›å»ºæ–°çš„å±‚å ä¸Šä¸‹æ–‡ */
.gpu-layer {
  will-change: transform;
  transform: translateZ(0); /* æˆ–ä½¿ç”¨translate3d(0,0,0) */
}

/* 3. ä¼˜åŒ–é€‰æ‹©å™¨æ€§èƒ½ */
/* ä¸å¥½çš„é€‰æ‹©å™¨ */
div div div p span { color: red; }

/* å¥½çš„é€‰æ‹©å™¨ */
.specific-text { color: red; }

/* 4. ä½¿ç”¨CSS Gridè¿›è¡Œå¤æ‚å¸ƒå±€ */
.grid-layout {
  display: grid;
  grid-template-areas: 
    "header header header"
    "sidebar main aside"
    "footer footer footer";
  grid-template-columns: 200px 1fr 200px;
  grid-template-rows: auto 1fr auto;
}
```



## ä½¿ç”¨Performance APIä¸DevToolsåˆ†ææ¸²æŸ“æ€§èƒ½

### Performance APIå®æˆ˜åº”ç”¨

```javascript
class PerformanceMonitor {
  constructor() {
    this.observer = null;
    this.metrics = {};
    this.init();
  }
  
  init() {
    // ç›‘å¬æ€§èƒ½æ¡ç›®
    this.observer = new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        this.handlePerformanceEntry(entry);
      }
    });
    
    // ç›‘å¬ä¸åŒç±»å‹çš„æ€§èƒ½æ•°æ®
    try {
      this.observer.observe({ entryTypes: ['measure', 'navigation', 'paint', 'largest-contentful-paint'] });
    } catch (e) {
      // é™çº§å¤„ç†
      this.observer.observe({ entryTypes: ['measure', 'navigation'] });
    }
  }
  
  handlePerformanceEntry(entry) {
    switch (entry.entryType) {
      case 'navigation':
        this.handleNavigationTiming(entry);
        break;
      case 'paint':
        this.handlePaintTiming(entry);
        break;
      case 'largest-contentful-paint':
        this.handleLCP(entry);
        break;
      case 'measure':
        this.handleCustomMeasure(entry);
        break;
    }
  }
  
  handleNavigationTiming(entry) {
    this.metrics.domContentLoaded = entry.domContentLoadedEventEnd - entry.domContentLoadedEventStart;
    this.metrics.loadComplete = entry.loadEventEnd - entry.loadEventStart;
    this.metrics.domInteractive = entry.domInteractive - entry.fetchStart;
  }
  
  handlePaintTiming(entry) {
    this.metrics[entry.name] = entry.startTime;
  }
  
  handleLCP(entry) {
    this.metrics.lcp = entry.startTime;
  }
  
  // è‡ªå®šä¹‰æ€§èƒ½æµ‹é‡
  measureFunction(name, fn) {
    performance.mark(`${name}-start`);
    const result = fn();
    performance.mark(`${name}-end`);
    performance.measure(name, `${name}-start`, `${name}-end`);
    return result;
  }
  
  // æµ‹é‡DOMæ“ä½œæ€§èƒ½
  measureDOMOperation(operation) {
    return this.measureFunction('dom-operation', operation);
  }
  
  // è·å–FPS
  measureFPS() {
    let fps = 0;
    let lastTime = performance.now();
    let frames = 0;
    
    const measure = () => {
      frames++;
      const currentTime = performance.now();
      
      if (currentTime >= lastTime + 1000) {
        fps = Math.round((frames * 1000) / (currentTime - lastTime));
        frames = 0;
        lastTime = currentTime;
        
        console.log(`å½“å‰FPS: ${fps}`);
      }
      
      requestAnimationFrame(measure);
    };
    
    requestAnimationFrame(measure);
  }
  
  // è·å–æ‰€æœ‰æ€§èƒ½æŒ‡æ ‡
  getMetrics() {
    return {
      ...this.metrics,
      // Core Web Vitals
      fcp: this.metrics['first-contentful-paint'],
      lcp: this.metrics.lcp,
      // è‡ªå®šä¹‰è®¡ç®—çš„æŒ‡æ ‡
      renderTime: this.metrics.domInteractive,
      loadTime: this.metrics.loadComplete
    };
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const monitor = new PerformanceMonitor();

// æµ‹é‡DOMæ“ä½œæ€§èƒ½
const result = monitor.measureDOMOperation(() => {
  const fragment = document.createDocumentFragment();
  for (let i = 0; i < 1000; i++) {
    const div = document.createElement('div');
    div.textContent = `Item ${i}`;
    fragment.appendChild(div);
  }
  document.body.appendChild(fragment);
});

// å¼€å§‹FPSç›‘æ§
monitor.measureFPS();

// è·å–æ€§èƒ½æŠ¥å‘Š
setTimeout(() => {
  console.log('æ€§èƒ½æŒ‡æ ‡:', monitor.getMetrics());
}, 5000);
```



### DevToolsæ€§èƒ½åˆ†ææŠ€å·§

```javascript
// 1. ä½¿ç”¨console.timeè¿›è¡Œç®€å•æ€§èƒ½æµ‹é‡
console.time('DOMæ“ä½œ');
// æ‰§è¡ŒDOMæ“ä½œ
console.timeEnd('DOMæ“ä½œ');

// 2. ä½¿ç”¨profile API
console.profile('æ¸²æŸ“æ€§èƒ½åˆ†æ');
// æ‰§è¡Œéœ€è¦åˆ†æçš„ä»£ç 
console.profileEnd('æ¸²æŸ“æ€§èƒ½åˆ†æ');

// 3. æ ‡è®°æ—¶é—´çº¿
performance.mark('å¼€å§‹å¤æ‚è®¡ç®—');
// æ‰§è¡Œå¤æ‚è®¡ç®—
performance.mark('ç»“æŸå¤æ‚è®¡ç®—');
performance.measure('å¤æ‚è®¡ç®—è€—æ—¶', 'å¼€å§‹å¤æ‚è®¡ç®—', 'ç»“æŸå¤æ‚è®¡ç®—');
```



##  æ¸²æŸ“ç®¡é“ä¼˜åŒ–æŠ€æœ¯

### å±‚çº§ä¼˜åŒ–ç­–ç•¥

```css
/* åˆ›å»ºç‹¬ç«‹çš„åˆæˆå±‚ */
.optimized-animation {
  /* ä½¿ç”¨transformå’Œopacityï¼Œé¿å…è§¦å‘layoutå’Œpaint */
  transform: translateX(0);
  opacity: 1;
  
  /* æç¤ºæµè§ˆå™¨åˆ›å»ºåˆæˆå±‚ */
  will-change: transform, opacity;
  
  /* æˆ–è€…ä½¿ç”¨3Då˜æ¢å¼ºåˆ¶åˆ›å»ºå±‚ */
  transform: translate3d(0, 0, 0);
}

/* é¿å…ä¸å¿…è¦çš„å±‚åˆ›å»º */
.avoid-layer {
  /* åŠ¨ç”»ç»“æŸåç§»é™¤will-change */
  will-change: auto;
}
```

### JavaScriptä¼˜åŒ–å®ç°

```javascript
class RenderOptimizer {
  constructor() {
    this.scheduledAnimations = new Set();
    this.isAnimating = false;
  }
  
  // ä¼˜åŒ–åŠ¨ç”»è°ƒåº¦
  scheduleAnimation(element, animation) {
    this.scheduledAnimations.add({ element, animation });
    
    if (!this.isAnimating) {
      this.startAnimationLoop();
    }
  }
  
  startAnimationLoop() {
    this.isAnimating = true;
    
    const animate = (timestamp) => {
      // æ‰¹é‡æ‰§è¡Œæ‰€æœ‰åŠ¨ç”»
      for (const { element, animation } of this.scheduledAnimations) {
        animation(element, timestamp);
      }
      
      if (this.scheduledAnimations.size > 0) {
        requestAnimationFrame(animate);
      } else {
        this.isAnimating = false;
      }
    };
    
    requestAnimationFrame(animate);
  }
  
  // ä¼˜åŒ–å¤§é‡å…ƒç´ çš„æ ·å¼æ›´æ–°
  batchStyleUpdate(elements, styleUpdates) {
    // ä½¿ç”¨DocumentFragmentå‡å°‘DOMæ“ä½œ
    const fragment = document.createDocumentFragment();
    
    elements.forEach((element, index) => {
      // å…‹éš†å…ƒç´ ä»¥é¿å…å¤šæ¬¡å›æµ
      const clone = element.cloneNode(true);
      
      // åº”ç”¨æ ·å¼æ›´æ–°
      Object.assign(clone.style, styleUpdates[index]);
      
      fragment.appendChild(clone);
    });
    
    // ä¸€æ¬¡æ€§æ›¿æ¢æ‰€æœ‰å…ƒç´ 
    const parent = elements[0].parentNode;
    elements.forEach(el => el.remove());
    parent.appendChild(fragment);
  }
  
  // æ™ºèƒ½é˜²æŠ–æ»šåŠ¨å¤„ç†
  optimizeScrollHandler(handler, delay = 16) {
    let rafId;
    let lastKnownScrollPosition = 0;
    let ticking = false;
    
    return function(event) {
      lastKnownScrollPosition = window.scrollY;
      
      if (!ticking) {
        requestAnimationFrame(() => {
          handler(lastKnownScrollPosition);
          ticking = false;
        });
        ticking = true;
      }
    };
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const optimizer = new RenderOptimizer();

// ä¼˜åŒ–çš„æ»šåŠ¨å¤„ç†
const optimizedScrollHandler = optimizer.optimizeScrollHandler((scrollY) => {
  // å¤„ç†æ»šåŠ¨é€»è¾‘
  const elements = document.querySelectorAll('.parallax-element');
  elements.forEach((el, index) => {
    const speed = (index + 1) * 0.5;
    el.style.transform = `translateY(${scrollY * speed}px)`;
  });
});

window.addEventListener('scroll', optimizedScrollHandler);

// æ‰¹é‡æ ·å¼æ›´æ–°ç¤ºä¾‹
const elements = document.querySelectorAll('.batch-update');
const styleUpdates = elements.map((_, index) => ({
  transform: `translateX(${index * 10}px)`,
  opacity: Math.random()
}));

optimizer.batchStyleUpdate(elements, styleUpdates);
```



### å†…å­˜ä¼˜åŒ–ç­–ç•¥

```javascript
class MemoryOptimizer {
  constructor() {
    this.observers = new Map();
    this.eventListeners = new WeakMap();
  }
  
  // è‡ªåŠ¨æ¸…ç†Intersection Observer
  createIntersectionObserver(callback, options) {
    const observer = new IntersectionObserver(callback, options);
    
    // åŒ…è£…åŸå§‹æ–¹æ³•ä»¥è‡ªåŠ¨æ¸…ç†
    const originalObserve = observer.observe.bind(observer);
    const originalUnobserve = observer.unobserve.bind(observer);
    
    observer.observe = (target) => {
      originalObserve(target);
      
      if (!this.observers.has(observer)) {
        this.observers.set(observer, new Set());
      }
      this.observers.get(observer).add(target);
    };
    
    observer.unobserve = (target) => {
      originalUnobserve(target);
      
      if (this.observers.has(observer)) {
        this.observers.get(observer).delete(target);
        
        if (this.observers.get(observer).size === 0) {
          observer.disconnect();
          this.observers.delete(observer);
        }
      }
    };
    
    return observer;
  }
  
  // è‡ªåŠ¨æ¸…ç†äº‹ä»¶ç›‘å¬å™¨
  addEventListenerWithCleanup(element, event, handler, options) {
    element.addEventListener(event, handler, options);
    
    if (!this.eventListeners.has(element)) {
      this.eventListeners.set(element, []);
    }
    
    this.eventListeners.get(element).push({
      event,
      handler,
      options
    });
    
    // è¿”å›æ¸…ç†å‡½æ•°
    return () => {
      element.removeEventListener(event, handler, options);
      const listeners = this.eventListeners.get(element);
      if (listeners) {
        const index = listeners.findIndex(l => 
          l.event === event && l.handler === handler
        );
        if (index > -1) {
          listeners.splice(index, 1);
        }
      }
    };
  }
  
  // æ¸…ç†æ‰€æœ‰èµ„æº
  cleanup() {
    // æ¸…ç†æ‰€æœ‰è§‚å¯Ÿå™¨
    for (const [observer] of this.observers) {
      observer.disconnect();
    }
    this.observers.clear();
    
    // æ¸…ç†äº‹ä»¶ç›‘å¬å™¨
    for (const [element, listeners] of this.eventListeners) {
      listeners.forEach(({ event, handler, options }) => {
        element.removeEventListener(event, handler, options);
      });
    }
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const memoryOptimizer = new MemoryOptimizer();

// åˆ›å»ºè‡ªåŠ¨æ¸…ç†çš„è§‚å¯Ÿå™¨
const observer = memoryOptimizer.createIntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      // å…ƒç´ è¿›å…¥è§†å£
      entry.target.classList.add('visible');
    }
  });
});

// æ·»åŠ è‡ªåŠ¨æ¸…ç†çš„äº‹ä»¶ç›‘å¬å™¨
const cleanup = memoryOptimizer.addEventListenerWithCleanup(
  document,
  'click',
  (event) => {
    console.log('ç‚¹å‡»äº‹ä»¶', event.target);
  }
);

// é¡µé¢å¸è½½æ—¶æ¸…ç†èµ„æº
window.addEventListener('beforeunload', () => {
  memoryOptimizer.cleanup();
});
```



# æµè§ˆå™¨å­˜å‚¨ä¸ç¼“å­˜

## æµè§ˆå™¨å­˜å‚¨æœºåˆ¶ï¼šä» Cookie åˆ° IndexedDB çš„æŠ€æœ¯æ¼”è¿›

###  æŠ€æœ¯æ¼”è¿›å†ç¨‹

#### Cookie (1994å¹´)

- **å®¹é‡é™åˆ¶**ï¼š4KB
- **ç‰¹ç‚¹**ï¼šè‡ªåŠ¨éšHTTPè¯·æ±‚å‘é€ï¼Œæ”¯æŒè¿‡æœŸæ—¶é—´
- **é—®é¢˜**ï¼šå®¹é‡å°ã€å½±å“ç½‘ç»œæ€§èƒ½ã€å®‰å…¨æ€§æœ‰é™

javascript

```javascript
// Cookie æ“ä½œç¤ºä¾‹
document.cookie = "username=john; expires=Fri, 31 Dec 2024 23:59:59 GMT; path=/";
```

#### Web Storage (2009å¹´) - HTML5æ ‡å‡†

**localStorage**

- **å®¹é‡**ï¼š5-10MBï¼ˆå› æµè§ˆå™¨è€Œå¼‚ï¼‰
- **ç”Ÿå‘½å‘¨æœŸ**ï¼šæŒä¹…åŒ–å­˜å‚¨ï¼Œæ‰‹åŠ¨æ¸…é™¤
- **ä½œç”¨åŸŸ**ï¼šåŒæºç­–ç•¥é™åˆ¶

**sessionStorage**

- **å®¹é‡**ï¼š5-10MB
- **ç”Ÿå‘½å‘¨æœŸ**ï¼šä¼šè¯ç»“æŸå³æ¸…é™¤
- **ä½œç”¨åŸŸ**ï¼šæ ‡ç­¾é¡µçº§åˆ«

```javascript
// localStorage ç¤ºä¾‹
localStorage.setItem('userPrefs', JSON.stringify({theme: 'dark', lang: 'zh'}));
const prefs = JSON.parse(localStorage.getItem('userPrefs'));

// sessionStorage ç¤ºä¾‹
sessionStorage.setItem('tempData', 'session-specific-data');
```

#### IndexedDB (2010å¹´)

- **å®¹é‡**ï¼šç†è®ºä¸Šæ— é™åˆ¶ï¼ˆå—è®¾å¤‡å­˜å‚¨å½±å“ï¼‰
- **ç‰¹ç‚¹**ï¼šNoSQLæ•°æ®åº“ã€äº‹åŠ¡æ”¯æŒã€å¼‚æ­¥æ“ä½œ
- **é€‚ç”¨åœºæ™¯**ï¼šå¤§é‡ç»“æ„åŒ–æ•°æ®å­˜å‚¨

```javascript
// IndexedDB åŸºæœ¬æ“ä½œ
const request = indexedDB.open('MyDatabase', 1);
request.onsuccess = function(event) {
  const db = event.target.result;
  const transaction = db.transaction(['users'], 'readwrite');
  const store = transaction.objectStore('users');
  store.add({id: 1, name: 'Alice', email: 'alice@example.com'});
};
```



### æ¼”è¿›é©±åŠ¨å› ç´ 

1. **åº”ç”¨å¤æ‚åº¦å¢åŠ **ï¼šä»ç®€å•é¡µé¢åˆ°å¤æ‚Webåº”ç”¨
2. **ç¦»çº¿éœ€æ±‚**ï¼šPWAå’Œç¦»çº¿åº”ç”¨çš„å…´èµ·
3. **æ€§èƒ½è¦æ±‚**ï¼šå‡å°‘ç½‘ç»œè¯·æ±‚ï¼Œæå‡ç”¨æˆ·ä½“éªŒ
4. **æ•°æ®é‡å¢é•¿**ï¼šéœ€è¦å­˜å‚¨æ›´å¤šå®¢æˆ·ç«¯æ•°æ®



## Service Worker ç¼“å­˜ç­–ç•¥è®¾è®¡ä¸æœ€ä½³å®è·µ

### æ ¸å¿ƒç¼“å­˜ç­–ç•¥

#### Cache First (ç¼“å­˜ä¼˜å…ˆ)

```javascript
self.addEventListener('fetch', event => {
  event.respondWith(
    caches.match(event.request)
      .then(response => {
        // ç¼“å­˜å‘½ä¸­åˆ™è¿”å›ç¼“å­˜
        if (response) {
          return response;
        }
        // å¦åˆ™å‘èµ·ç½‘ç»œè¯·æ±‚
        return fetch(event.request);
      })
  );
});
```



#### Network First (ç½‘ç»œä¼˜å…ˆ)

```javascript
self.addEventListener('fetch', event => {
  event.respondWith(
    fetch(event.request)
      .then(response => {
        // ç½‘ç»œè¯·æ±‚æˆåŠŸï¼Œæ›´æ–°ç¼“å­˜
        const responseClone = response.clone();
        caches.open('dynamic-cache')
          .then(cache => cache.put(event.request, responseClone));
        return response;
      })
      .catch(() => {
        // ç½‘ç»œå¤±è´¥ï¼Œå›é€€åˆ°ç¼“å­˜
        return caches.match(event.request);
      })
  );
});
```



#### Stale While Revalidate (è¿‡æœŸé‡æ–°éªŒè¯)

```javascript
self.addEventListener('fetch', event => {
  event.respondWith(
    caches.match(event.request)
      .then(response => {
        // ç«‹å³è¿”å›ç¼“å­˜ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
        const fetchPromise = fetch(event.request)
          .then(networkResponse => {
            // åå°æ›´æ–°ç¼“å­˜
            caches.open('cache-v1')
              .then(cache => cache.put(event.request, networkResponse.clone()));
            return networkResponse;
          });
        
        return response || fetchPromise;
      })
  );
});
```



### æœ€ä½³å®è·µ

#### åˆ†å±‚ç¼“å­˜ç­–ç•¥

```javascript
const CACHE_STRATEGIES = {
  '/api/': 'networkFirst',
  '/assets/': 'cacheFirst',
  '/': 'staleWhileRevalidate'
};

self.addEventListener('fetch', event => {
  const url = new URL(event.request.url);
  const strategy = getStrategy(url.pathname);
  
  event.respondWith(executeStrategy(strategy, event.request));
});

function getStrategy(pathname) {
  for (const [pattern, strategy] of Object.entries(CACHE_STRATEGIES)) {
    if (pathname.startsWith(pattern)) {
      return strategy;
    }
  }
  return 'networkFirst'; // é»˜è®¤ç­–ç•¥
}
```



#### ç¼“å­˜ç‰ˆæœ¬ç®¡ç†

```javascript
const CACHE_NAME = 'app-cache-v2';
const urlsToCache = [
  '/',
  '/styles/main.css',
  '/scripts/app.js',
  '/offline.html'
];

self.addEventListener('install', event => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then(cache => cache.addAll(urlsToCache))
  );
});

self.addEventListener('activate', event => {
  event.waitUntil(
    caches.keys().then(cacheNames => {
      return Promise.all(
        cacheNames.map(cacheName => {
          if (cacheName !== CACHE_NAME) {
            return caches.delete(cacheName);
          }
        })
      );
    })
  );
});
```



## ç¼“å­˜ API ä¸ç¦»çº¿åº”ç”¨è®¾è®¡

### Cache API æ ¸å¿ƒæ“ä½œ

```javascript
// æ‰“å¼€ç¼“å­˜
const cache = await caches.open('my-cache-v1');

// æ·»åŠ èµ„æºåˆ°ç¼“å­˜
await cache.add('/api/data');
await cache.addAll(['/style.css', '/app.js']);

// æ‰‹åŠ¨ç¼“å­˜å“åº”
const response = await fetch('/api/user');
await cache.put('/api/user', response.clone());

// åŒ¹é…ç¼“å­˜
const cachedResponse = await cache.match('/api/data');

// åˆ é™¤ç¼“å­˜é¡¹
await cache.delete('/api/old-data');
```



### ç¦»çº¿åº”ç”¨æ¶æ„è®¾è®¡

#### ç¦»çº¿ä¼˜å…ˆæ¶æ„

```javascript
class OfflineFirstApp {
  constructor() {
    this.initServiceWorker();
    this.setupOfflineDetection();
  }

  async initServiceWorker() {
    if ('serviceWorker' in navigator) {
      try {
        const registration = await navigator.serviceWorker.register('/sw.js');
        console.log('SW registered:', registration);
      } catch (error) {
        console.log('SW registration failed:', error);
      }
    }
  }

  setupOfflineDetection() {
    window.addEventListener('online', this.handleOnline.bind(this));
    window.addEventListener('offline', this.handleOffline.bind(this));
  }

  handleOnline() {
    this.syncPendingData();
    this.showOnlineStatus();
  }

  handleOffline() {
    this.showOfflineStatus();
  }

  async syncPendingData() {
    const pendingRequests = await this.getPendingRequests();
    for (const request of pendingRequests) {
      try {
        await fetch(request.url, request.options);
        await this.removePendingRequest(request.id);
      } catch (error) {
        console.log('Sync failed:', error);
      }
    }
  }
}
```



#### æ•°æ®åŒæ­¥ç­–ç•¥

```javascript
class DataSyncManager {
  constructor() {
    this.pendingSync = new Map();
  }

  async saveData(key, data) {
    // æœ¬åœ°å­˜å‚¨
    await this.saveToIndexedDB(key, data);
    
    // å°è¯•åŒæ­¥åˆ°æœåŠ¡å™¨
    if (navigator.onLine) {
      try {
        await this.syncToServer(key, data);
      } catch (error) {
        // æ·»åŠ åˆ°å¾…åŒæ­¥é˜Ÿåˆ—
        this.addToPendingSync(key, data);
      }
    } else {
      this.addToPendingSync(key, data);
    }
  }

  async syncToServer(key, data) {
    const response = await fetch('/api/sync', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ key, data })
    });
    
    if (!response.ok) {
      throw new Error('Sync failed');
    }
  }

  addToPendingSync(key, data) {
    this.pendingSync.set(key, {
      data,
      timestamp: Date.now(),
      retryCount: 0
    });
  }
}
```



## æµè§ˆå™¨å­˜å‚¨é…é¢ç®¡ç†ä¸å­˜å‚¨ä¼˜åŒ–

### å­˜å‚¨é…é¢æŸ¥è¯¢

```javascript
// æŸ¥è¯¢å­˜å‚¨é…é¢ä¿¡æ¯
async function getStorageInfo() {
  if ('storage' in navigator && 'estimate' in navigator.storage) {
    try {
      const estimate = await navigator.storage.estimate();
      console.log('å·²ä½¿ç”¨å­˜å‚¨:', estimate.usage);
      console.log('å¯ç”¨é…é¢:', estimate.quota);
      console.log('ä½¿ç”¨ç‡:', (estimate.usage / estimate.quota * 100).toFixed(2) + '%');
      
      return {
        used: estimate.usage,
        total: estimate.quota,
        available: estimate.quota - estimate.usage
      };
    } catch (error) {
      console.error('è·å–å­˜å‚¨ä¿¡æ¯å¤±è´¥:', error);
    }
  }
}

// è¯·æ±‚æŒä¹…åŒ–å­˜å‚¨
async function requestPersistentStorage() {
  if ('storage' in navigator && 'persist' in navigator.storage) {
    const persistent = await navigator.storage.persist();
    console.log('æŒä¹…åŒ–å­˜å‚¨çŠ¶æ€:', persistent);
    return persistent;
  }
}
```

### å­˜å‚¨ä¼˜åŒ–ç­–ç•¥

#### æ™ºèƒ½æ¸…ç†æœºåˆ¶

```javascript
class StorageManager {
  constructor() {
    this.maxStorage = 50 * 1024 * 1024; // 50MB
    this.cleanupThreshold = 0.8; // 80%ä½¿ç”¨ç‡è§¦å‘æ¸…ç†
  }

  async checkAndCleanup() {
    const info = await getStorageInfo();
    const usageRatio = info.used / info.total;

    if (usageRatio > this.cleanupThreshold) {
      await this.performCleanup();
    }
  }

  async performCleanup() {
    // æŒ‰ä¼˜å…ˆçº§æ¸…ç†
    await this.cleanupExpiredCache();
    await this.cleanupOldUserData();
    await this.cleanupTemporaryFiles();
  }

  async cleanupExpiredCache() {
    const cacheNames = await caches.keys();
    for (const name of cacheNames) {
      const cache = await caches.open(name);
      const keys = await cache.keys();
      
      for (const request of keys) {
        const response = await cache.match(request);
        if (this.isExpired(response)) {
          await cache.delete(request);
        }
      }
    }
  }

  isExpired(response) {
    const cacheControl = response.headers.get('cache-control');
    const maxAge = this.parseMaxAge(cacheControl);
    const responseDate = new Date(response.headers.get('date'));
    
    return maxAge && (Date.now() - responseDate.getTime()) > maxAge * 1000;
  }
}
```



#### æ•°æ®å‹ç¼©å­˜å‚¨

```javascript
class CompressedStorage {
  // ä½¿ç”¨ LZ-string æˆ–ç±»ä¼¼åº“è¿›è¡Œå‹ç¼©
  async setItem(key, data) {
    const compressed = LZString.compress(JSON.stringify(data));
    localStorage.setItem(key, compressed);
  }

  async getItem(key) {
    const compressed = localStorage.getItem(key);
    if (compressed) {
      const decompressed = LZString.decompress(compressed);
      return JSON.parse(decompressed);
    }
    return null;
  }

  // åˆ†å—å­˜å‚¨å¤§æ•°æ®
  async setLargeItem(key, data) {
    const serialized = JSON.stringify(data);
    const chunkSize = 1024 * 1024; // 1MB chunks
    const chunks = [];
    
    for (let i = 0; i < serialized.length; i += chunkSize) {
      chunks.push(serialized.slice(i, i + chunkSize));
    }
    
    localStorage.setItem(`${key}_chunks`, chunks.length);
    chunks.forEach((chunk, index) => {
      localStorage.setItem(`${key}_${index}`, chunk);
    });
  }
}
```



## IndexedDB äº‹åŠ¡å¤„ç†ä¸æ€§èƒ½ä¼˜åŒ–

### äº‹åŠ¡å¤„ç†æœ€ä½³å®è·µ

```javascript
class IndexedDBManager {
  constructor(dbName, version) {
    this.dbName = dbName;
    this.version = version;
    this.db = null;
  }

  async init() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.version);
      
      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        this.db = request.result;
        resolve(this.db);
      };
      
      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        this.createObjectStores(db);
      };
    });
  }

  // æ‰¹é‡æ“ä½œäº‹åŠ¡
  async batchOperation(storeName, operations) {
    const transaction = this.db.transaction([storeName], 'readwrite');
    const store = transaction.objectStore(storeName);
    
    const promises = operations.map(op => {
      switch (op.type) {
        case 'add':
          return this.promisifyRequest(store.add(op.data));
        case 'put':
          return this.promisifyRequest(store.put(op.data));
        case 'delete':
          return this.promisifyRequest(store.delete(op.key));
        default:
          return Promise.resolve();
      }
    });

    return Promise.all(promises);
  }

  // äº‹åŠ¡é”™è¯¯å¤„ç†
  async safeTransaction(storeName, mode, operation) {
    try {
      const transaction = this.db.transaction([storeName], mode);
      const store = transaction.objectStore(storeName);
      
      // è®¾ç½®äº‹åŠ¡é”™è¯¯å¤„ç†
      transaction.onerror = (event) => {
        console.error('Transaction failed:', event.target.error);
      };
      
      const result = await operation(store);
      
      // ç­‰å¾…äº‹åŠ¡å®Œæˆ
      await new Promise((resolve, reject) => {
        transaction.oncomplete = () => resolve();
        transaction.onerror = () => reject(transaction.error);
      });
      
      return result;
    } catch (error) {
      console.error('Transaction error:', error);
      throw error;
    }
  }

  promisifyRequest(request) {
    return new Promise((resolve, reject) => {
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }
}
```



### æ€§èƒ½ä¼˜åŒ–æŠ€å·§

#### ç´¢å¼•ä¼˜åŒ–

```javascript
// åˆ›å»ºå¤åˆç´¢å¼•
request.onupgradeneeded = function(event) {
  const db = event.target.result;
  const store = db.createObjectStore('products', { keyPath: 'id' });
  
  // å•å­—æ®µç´¢å¼•
  store.createIndex('name', 'name', { unique: false });
  store.createIndex('category', 'category', { unique: false });
  
  // å¤åˆç´¢å¼•
  store.createIndex('category_price', ['category', 'price'], { unique: false });
};

// ä½¿ç”¨ç´¢å¼•æŸ¥è¯¢
async function searchProducts(category, maxPrice) {
  const transaction = db.transaction(['products'], 'readonly');
  const store = transaction.objectStore('products');
  const index = store.index('category_price');
  
  const range = IDBKeyRange.bound([category, 0], [category, maxPrice]);
  const request = index.openCursor(range);
  
  const results = [];
  return new Promise((resolve) => {
    request.onsuccess = function(event) {
      const cursor = event.target.result;
      if (cursor) {
        results.push(cursor.value);
        cursor.continue();
      } else {
        resolve(results);
      }
    };
  });
}
```



#### æ¸¸æ ‡ä¼˜åŒ–

```javascript
// é«˜æ•ˆæ¸¸æ ‡éå†
async function efficientCursorTraversal(storeName, processor) {
  const transaction = this.db.transaction([storeName], 'readonly');
  const store = transaction.objectStore(storeName);
  const request = store.openCursor();
  
  let processed = 0;
  
  return new Promise((resolve, reject) => {
    request.onsuccess = function(event) {
      const cursor = event.target.result;
      
      if (cursor) {
        processor(cursor.value);
        processed++;
        
        // æ‰¹é‡å¤„ç†ï¼Œå‡å°‘ä¸»çº¿ç¨‹é˜»å¡
        if (processed % 100 === 0) {
          setTimeout(() => cursor.continue(), 0);
        } else {
          cursor.continue();
        }
      } else {
        resolve(processed);
      }
    };
    
    request.onerror = () => reject(request.error);
  });
}
```



## ä¸»æµæµè§ˆå™¨çš„å­˜å‚¨éš”ç¦»ç­–ç•¥ä¸å®‰å…¨æœºåˆ¶

### åŒæºç­–ç•¥ (Same-Origin Policy)

```javascript
// å­˜å‚¨éš”ç¦»ç¤ºä¾‹
function demonstrateStorageIsolation() {
  // ä¸åŒæºçš„é¡µé¢æ— æ³•è®¿é—®å½¼æ­¤çš„å­˜å‚¨
  
  // https://example.com çš„å­˜å‚¨
  localStorage.setItem('user', 'alice');
  
  // https://app.example.com æ— æ³•è®¿é—®ä¸Šè¿°æ•°æ®
  // å³ä½¿æ˜¯åŒä¸€åŸŸåçš„ä¸åŒå­åŸŸä¹Ÿè¢«è§†ä¸ºä¸åŒæº
}

// å®‰å…¨çš„è·¨åŸŸå­˜å‚¨é€šä¿¡
function secureStorageCommunication() {
  // ä½¿ç”¨ postMessage è¿›è¡Œå®‰å…¨é€šä¿¡
  window.addEventListener('message', (event) => {
    // éªŒè¯æ¶ˆæ¯æ¥æº
    if (event.origin !== 'https://trusted-domain.com') {
      return;
    }
    
    // å¤„ç†å­˜å‚¨è¯·æ±‚
    if (event.data.type === 'STORAGE_REQUEST') {
      const data = localStorage.getItem(event.data.key);
      event.source.postMessage({
        type: 'STORAGE_RESPONSE',
        data: data
      }, event.origin);
    }
  });
}
```



###  æµè§ˆå™¨ç‰¹å®šçš„å®‰å…¨æœºåˆ¶

#### Chrome çš„ Storage Partitioning

```javascript
// Chrome 85+ å®ç°äº†å­˜å‚¨åˆ†åŒº
// ç¬¬ä¸‰æ–¹ä¸Šä¸‹æ–‡ä¸­çš„å­˜å‚¨ä¼šè¢«åˆ†åŒºéš”ç¦»

// æ£€æµ‹å­˜å‚¨åˆ†åŒºæ”¯æŒ
function detectStoragePartitioning() {
  if ('storage' in navigator && 'getDirectory' in navigator.storage) {
    // æ”¯æŒ Storage Partitioning
    return true;
  }
  return false;
}

// é€‚é…å­˜å‚¨åˆ†åŒºçš„ä»£ç 
class PartitionAwareStorage {
  constructor() {
    this.isPartitioned = this.detectPartitioning();
  }

  async setItem(key, data) {
    if (this.isPartitioned) {
      // ä½¿ç”¨åˆ†åŒºå®‰å…¨çš„å­˜å‚¨æ–¹å¼
      return this.setPartitionedItem(key, data);
    } else {
      // ä¼ ç»Ÿå­˜å‚¨æ–¹å¼
      return localStorage.setItem(key, JSON.stringify(data));
    }
  }

  async setPartitionedItem(key, data) {
    // ä½¿ç”¨ IndexedDB æˆ–å…¶ä»–åˆ†åŒºå®‰å…¨çš„å­˜å‚¨
    const db = await this.openDatabase();
    const transaction = db.transaction(['storage'], 'readwrite');
    const store = transaction.objectStore('storage');
    return store.put({ key, data });
  }
}
```



### Content Security Policy (CSP) å½±å“

```javascript
// CSP å¯¹å­˜å‚¨çš„å½±å“
function handleCSPRestrictions() {
  // unsafe-eval é™åˆ¶å½±å“ JSON åºåˆ—åŒ–
  try {
    const data = { user: 'alice', timestamp: Date.now() };
    
    // å®‰å…¨çš„åºåˆ—åŒ–æ–¹å¼
    const serialized = JSON.stringify(data);
    localStorage.setItem('userData', serialized);
    
    // é¿å…ä½¿ç”¨ eval æˆ– Function æ„é€ å™¨
    const parsed = JSON.parse(localStorage.getItem('userData'));
    
  } catch (error) {
    console.error('CSP restriction encountered:', error);
  }
}
```



## WebStorageã€IndexedDB ä¸ Cache API çš„é€‚ç”¨åœºæ™¯åˆ†æ

### ç”¨åœºæ™¯è¯¦è§£

#### localStorage é€‚ç”¨åœºæ™¯

```javascript
// 1. ç”¨æˆ·åå¥½è®¾ç½®
const userPreferences = {
  theme: 'dark',
  language: 'zh-CN',
  notifications: true
};
localStorage.setItem('preferences', JSON.stringify(userPreferences));

// 2. è´­ç‰©è½¦æ•°æ®
class ShoppingCart {
  addItem(item) {
    const cart = this.getCart();
    cart.push(item);
    localStorage.setItem('cart', JSON.stringify(cart));
  }

  getCart() {
    return JSON.parse(localStorage.getItem('cart') || '[]');
  }
}

// 3. è¡¨å•æ•°æ®è‡ªåŠ¨ä¿å­˜
function autoSaveForm() {
  const form = document.getElementById('userForm');
  form.addEventListener('input', (e) => {
    const formData = new FormData(form);
    const data = Object.fromEntries(formData.entries());
    localStorage.setItem('formDraft', JSON.stringify(data));
  });
}
```



#### sessionStorage é€‚ç”¨åœºæ™¯

```javascript
// 1. å•é¡µåº”ç”¨çŠ¶æ€ç®¡ç†
class SPAStateManager {
  saveState(state) {
    sessionStorage.setItem('appState', JSON.stringify(state));
  }

  restoreState() {
    const state = sessionStorage.getItem('appState');
    return state ? JSON.parse(state) : null;
  }
}

// 2. è¡¨å•å‘å¯¼æ•°æ®
class FormWizard {
  saveStep(stepData) {
    sessionStorage.setItem(`step_${stepData.step}`, JSON.stringify(stepData));
  }

  getStepData(step) {
    return JSON.parse(sessionStorage.getItem(`step_${step}`) || '{}');
  }
}

// 3. ä¸´æ—¶æ–‡ä»¶ä¸Šä¼ 
function tempFileUpload() {
  // å­˜å‚¨æ–‡ä»¶ä¸Šä¼ è¿›åº¦
  sessionStorage.setItem('uploadProgress', JSON.stringify({
    files: ['file1.jpg', 'file2.pdf'],
    progress: 75
  }));
}
```



#### ndexedDB é€‚ç”¨åœºæ™¯

```javascript
// 1. å¤§é‡ç»“æ„åŒ–æ•°æ®
class ProductCatalog {
  async addProducts(products) {
    const transaction = this.db.transaction(['products'], 'readwrite');
    const store = transaction.objectStore('products');
    
    for (const product of products) {
      await this.promisifyRequest(store.add(product));
    }
  }

  async searchProducts(query) {
    const transaction = this.db.transaction(['products'], 'readonly');
    const store = transaction.objectStore('products');
    const index = store.index('name');
    
    return this.promisifyRequest(index.getAll(query));
  }
}

// 2. ç¦»çº¿æ•°æ®åŒæ­¥
class OfflineDataManager {
  async cacheServerData(data) {
    const transaction = this.db.transaction(['cache'], 'readwrite');
    const store = transaction.objectStore('cache');
    
    await this.promisifyRequest(store.put({
      id: 'serverData',
      data: data,
      timestamp: Date.now()
    }));
  }

  async syncWithServer() {
    // è·å–ç¦»çº¿æœŸé—´çš„å˜æ›´
    const changes = await this.getPendingChanges();
    
    // ä¸Šä¼ åˆ°æœåŠ¡å™¨
    for (const change of changes) {
      await this.uploadChange(change);
    }
  }
}

// 3. å¤æ‚æŸ¥è¯¢å’Œåˆ†æ
class DataAnalytics {
  async analyzeUserBehavior() {
    const transaction = this.db.transaction(['events'], 'readonly');
    const store = transaction.objectStore('events');
    const index = store.index('timestamp');
    
    const lastWeek = Date.now() - 7 * 24 * 60 * 60 * 1000;
    const range = IDBKeyRange.lowerBound(lastWeek);
    
    return new Promise((resolve) => {
      const results = [];
      const request = index.openCursor(range);
      
      request.onsuccess = function(event) {
        const cursor = event.target.result;
        if (cursor) {
          results.push(cursor.value);
          cursor.continue();
        } else {
          resolve(this.processAnalytics(results));
        }
      };
    });
  }
}
```



#### Cache API é€‚ç”¨åœºæ™¯

```javascript
// 1. Service Worker èµ„æºç¼“å­˜
self.addEventListener('install', event => {
  event.waitUntil(
    caches.open('static-v1').then(cache => {
      return cache.addAll([
        '/',
        '/styles/app.css',
        '/scripts/app.js',
        '/images/logo.png'
      ]);
    })
  );
});

// 2. API å“åº”ç¼“å­˜
class APICache {
  async cacheResponse(request, response) {
    const cache = await caches.open('api-cache');
    await cache.put(request, response.clone());
  }

  async getCachedResponse(request) {
    const cache = await caches.open('api-cache');
    return await cache.match(request);
  }
}

// 3. åŠ¨æ€å†…å®¹ç¼“å­˜
self.addEventListener('fetch', event => {
  if (event.request.url.includes('/api/')) {
    event.respondWith(
      caches.open('dynamic-cache').then(cache => {
        return cache.match(event.request).then(response => {
          if (response) {
            // åå°æ›´æ–°
            fetch(event.request).then(fetchResponse => {
              cache.put(event.request, fetchResponse.clone());
            });
            return response;
          }
          
          return fetch(event.request).then(fetchResponse => {
            cache.put(event.request, fetchResponse.clone());
            return fetchResponse;
          });
        });
      })
    );
  }
});
```



### é€‰æ‹©å†³ç­–æ ‘

```javascript
class StorageSelector {
  static selectStorage(requirements) {
    const {
      dataSize,
      dataType,
      persistence,
      queryComplexity,
      offline,
      sync
    } = requirements;

    // å¤§æ•°æ®é‡ + å¤æ‚æŸ¥è¯¢ = IndexedDB
    if (dataSize > 10 * 1024 * 1024 || queryComplexity === 'high') {
      return 'IndexedDB';
    }

    // HTTP å“åº”ç¼“å­˜ = Cache API
    if (dataType === 'response' || offline) {
      return 'Cache API';
    }

    // ä¼šè¯çº§æ•°æ® = sessionStorage
    if (persistence === 'session') {
      return 'sessionStorage';
    }

    // ç®€å•æŒä¹…åŒ–æ•°æ® = localStorage
    if (dataSize < 5 * 1024 * 1024 && queryComplexity === 'low') {
      return 'localStorage';
    }

    return 'IndexedDB'; // é»˜è®¤æ¨è
  }

  static getRecommendation(scenario) {
    const scenarios = {
      'user-preferences': 'localStorage',
      'shopping-cart': 'localStorage',
      'form-draft': 'sessionStorage',
      'spa-state': 'sessionStorage',
      'product-catalog': 'IndexedDB',
      'offline-sync': 'IndexedDB',
      'static-assets': 'Cache API',
      'api-responses': 'Cache API'
    };

    return scenarios[scenario] || 'localStorage';
  }
}
```

## æ€»ç»“

æµè§ˆå™¨å­˜å‚¨æŠ€æœ¯çš„å‘å±•ä½“ç°äº†Webåº”ç”¨ä»ç®€å•é¡µé¢å‘å¤æ‚åº”ç”¨çš„æ¼”è¿›ã€‚æ¯ç§å­˜å‚¨æŠ€æœ¯éƒ½æœ‰å…¶ç‰¹å®šçš„é€‚ç”¨åœºæ™¯ï¼š

- **localStorage/sessionStorage**ï¼šé€‚åˆå°é‡æ•°æ®çš„ç®€å•å­˜å‚¨
- **IndexedDB**ï¼šå¤§é‡æ•°æ®å’Œå¤æ‚æŸ¥è¯¢çš„é¦–é€‰
- **Cache API**ï¼šä¸Service Workeré…åˆå®ç°ç¦»çº¿åŠŸèƒ½
- **Cookie**ï¼šä»ç„¶æ˜¯æœåŠ¡å™¨é€šä¿¡çš„é‡è¦æ‰‹æ®µ



# å‰ç«¯ç½‘ç»œé€šä¿¡ä¸å®‰å…¨



## Fetch API ä¸ XMLHttpRequest æ·±åº¦å¯¹æ¯”

### åŸºæœ¬è¯­æ³•å¯¹æ¯”

#### XMLHttpRequest ä¼ ç»Ÿæ–¹å¼

```javascript
// XMLHttpRequest æ–¹å¼
const xhr = new XMLHttpRequest();
xhr.open('GET', '/api/data');
xhr.onreadystatechange = function() {
  if (xhr.readyState === 4 && xhr.status === 200) {
    const data = JSON.parse(xhr.responseText);
    console.log(data);
  }
};
xhr.send();
```



#### Fetch API ç°ä»£æ–¹å¼

```javascript
// Fetch API æ–¹å¼
fetch('/api/data')
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error('Error:', error));

// ä½¿ç”¨ async/await
async function fetchData() {
  try {
    const response = await fetch('/api/data');
    const data = await response.json();
    console.log(data);
  } catch (error) {
    console.error('Error:', error);
  }
}
```



![image-20250529095930516](C:/Users/27019/AppData/Roaming/Typora/typora-user-images/image-20250529095930516.png)

### é«˜çº§ç”¨æ³•ç¤ºä¾‹

#### Fetch API é«˜çº§é…ç½®

```javascript
const controller = new AbortController();
const timeoutId = setTimeout(() => controller.abort(), 5000);

try {
  const response = await fetch('/api/data', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': 'Bearer token'
    },
    body: JSON.stringify({ key: 'value' }),
    credentials: 'include', // å‘é€ cookies
    signal: controller.signal, // æ”¯æŒå–æ¶ˆ
    cache: 'no-cache',
    mode: 'cors'
  });
  
  clearTimeout(timeoutId);
  
  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }
  
  const data = await response.json();
  return data;
} catch (error) {
  if (error.name === 'AbortError') {
    console.log('Request was aborted');
  } else {
    console.error('Fetch error:', error);
  }
}
```



## HTTP/2 ä¸ HTTP/3 åœ¨å‰ç«¯æ€§èƒ½ä¼˜åŒ–ä¸­çš„åº”ç”¨â€˜

### HTTP/2 æ ¸å¿ƒç‰¹æ€§

#### å¤šè·¯å¤ç”¨ (Multiplexing)

```javascript
// HTTP/1.1 éœ€è¦é™åˆ¶å¹¶å‘è¿æ¥æ•°
const MAX_CONCURRENT = 6;
const requestQueue = [];

// HTTP/2 å¯ä»¥å¹¶å‘å‘é€å¤šä¸ªè¯·æ±‚
async function loadResources() {
  const requests = [
    fetch('/api/user'),
    fetch('/api/posts'),
    fetch('/api/comments'),
    fetch('/api/notifications')
  ];
  
  const responses = await Promise.all(requests);
  return responses.map(r => r.json());
}
```

#### æœåŠ¡å™¨æ¨é€ (Server Push)

```javascript
// æ£€æµ‹èµ„æºæ˜¯å¦è¢«æ¨é€
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.addEventListener('message', event => {
    if (event.data.type === 'CACHE_UPDATED') {
      console.log('Resource pushed and cached:', event.data.url);
    }
  });
}
```



### HTTP/3 (QUIC) ä¼˜åŠ¿

#### è¿æ¥è¿ç§»ä¸å¿«é€Ÿæ¡æ‰‹

```javascript
// æ£€æµ‹ HTTP/3 æ”¯æŒ
function detectHTTP3Support() {
  return new Promise((resolve) => {
    const img = new Image();
    const start = performance.now();
    
    img.onload = () => {
      const loadTime = performance.now() - start;
      resolve({
        supported: true,
        loadTime,
        protocol: 'h3' // HTTP/3
      });
    };
    
    img.onerror = () => resolve({ supported: false });
    img.src = '/test-h3-image.jpg';
  });
}
```





### å‰ç«¯ä¼˜åŒ–ç­–ç•¥

#### èµ„æºä¼˜å…ˆçº§è®¾ç½®

```javascript
// ä½¿ç”¨ fetchpriority å±æ€§
const criticalCSS = document.createElement('link');
criticalCSS.rel = 'stylesheet';
criticalCSS.href = '/critical.css';
criticalCSS.fetchPriority = 'high';

const lazyImage = document.createElement('img');
lazyImage.src = '/hero-image.jpg';
lazyImage.fetchPriority = 'low';

// Fetch API ä¸­è®¾ç½®ä¼˜å…ˆçº§
fetch('/api/critical-data', {
  priority: 'high'
});
```



## æ·±å…¥ç†è§£è·¨åŸŸèµ„æºå…±äº« (CORS) ä¸å®‰å…¨ç­–ç•¥

###  CORS å·¥ä½œåŸç†

#### ç®€å•è¯·æ±‚æ¡ä»¶

```javascript
// ç®€å•è¯·æ±‚ - ä¸ä¼šè§¦å‘é¢„æ£€
fetch('/api/data', {
  method: 'GET', // GET, POST, HEAD
  headers: {
    'Content-Type': 'text/plain' // ç®€å•å¤´éƒ¨
  }
});

// å¤æ‚è¯·æ±‚ - ä¼šè§¦å‘é¢„æ£€
fetch('/api/data', {
  method: 'PUT', // éç®€å•æ–¹æ³•
  headers: {
    'Content-Type': 'application/json', // éç®€å•å¤´éƒ¨
    'X-Custom-Header': 'value'
  },
  body: JSON.stringify({ data: 'test' })
});
```



#### é¢„æ£€è¯·æ±‚å¤„ç†

```javascript
// å‰ç«¯æ— éœ€ç‰¹æ®Šå¤„ç†ï¼Œæµè§ˆå™¨è‡ªåŠ¨å‘é€ OPTIONS è¯·æ±‚
// æœåŠ¡ç«¯éœ€è¦æ­£ç¡®å“åº”é¢„æ£€è¯·æ±‚

// ç›‘å¬é¢„æ£€è¯·æ±‚çš„ç»“æœ
const observer = new PerformanceObserver((list) => {
  list.getEntries().forEach((entry) => {
    if (entry.name.includes('OPTIONS')) {
      console.log('Preflight request:', entry);
    }
  });
});
observer.observe({ entryTypes: ['navigation', 'resource'] });
```



### CORS é…ç½®ç­–ç•¥

#### åŠ¨æ€ CORS å¤„ç†

```javascript
// å®¢æˆ·ç«¯æ£€æµ‹ CORS æ”¯æŒ
function checkCORSSupport(url) {
  return new Promise((resolve) => {
    const xhr = new XMLHttpRequest();
    xhr.open('GET', url);
    xhr.onload = () => resolve(true);
    xhr.onerror = () => resolve(false);
    xhr.send();
  });
}

// è·¨åŸŸè¯·æ±‚å°è£…
class CORSFetcher {
  constructor(baseURL, options = {}) {
    this.baseURL = baseURL;
    this.defaultOptions = {
      credentials: 'include',
      mode: 'cors',
      ...options
    };
  }
  
  async request(endpoint, options = {}) {
    const url = `${this.baseURL}${endpoint}`;
    const config = { ...this.defaultOptions, ...options };
    
    try {
      const response = await fetch(url, config);
      
      if (!response.ok) {
        throw new Error(`CORS request failed: ${response.status}`);
      }
      
      return response;
    } catch (error) {
      if (error.name === 'TypeError') {
        throw new Error('CORS policy blocked the request');
      }
      throw error;
    }
  }
}
```



## WebSocket åè®®å®ç°åŸç†ä¸æ€§èƒ½è°ƒä¼˜

### WebSocket åŸºç¡€å®ç°

#### è¿æ¥ç®¡ç†

```javascript
class WebSocketManager {
  constructor(url, options = {}) {
    this.url = url;
    this.options = {
      reconnectInterval: 3000,
      maxReconnectAttempts: 5,
      heartbeatInterval: 30000,
      ...options
    };
    this.reconnectAttempts = 0;
    this.isConnecting = false;
    this.heartbeatTimer = null;
    this.messageQueue = [];
  }
  
  connect() {
    if (this.isConnecting || (this.ws && this.ws.readyState === WebSocket.OPEN)) {
      return Promise.resolve();
    }
    
    this.isConnecting = true;
    
    return new Promise((resolve, reject) => {
      this.ws = new WebSocket(this.url);
      
      this.ws.onopen = (event) => {
        console.log('WebSocket connected');
        this.isConnecting = false;
        this.reconnectAttempts = 0;
        this.startHeartbeat();
        this.flushMessageQueue();
        resolve(event);
      };
      
      this.ws.onmessage = (event) => {
        this.handleMessage(event);
      };
      
      this.ws.onclose = (event) => {
        console.log('WebSocket closed:', event.code, event.reason);
        this.stopHeartbeat();
        this.handleReconnect();
      };
      
      this.ws.onerror = (error) => {
        console.error('WebSocket error:', error);
        this.isConnecting = false;
        reject(error);
      };
    });
  }
  
  send(data) {
    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify(data));
    } else {
      // è¿æ¥æœªå»ºç«‹æ—¶å°†æ¶ˆæ¯åŠ å…¥é˜Ÿåˆ—
      this.messageQueue.push(data);
      this.connect();
    }
  }
  
  handleReconnect() {
    if (this.reconnectAttempts < this.options.maxReconnectAttempts) {
      this.reconnectAttempts++;
      console.log(`Attempting reconnect ${this.reconnectAttempts}/${this.options.maxReconnectAttempts}`);
      
      setTimeout(() => {
        this.connect();
      }, this.options.reconnectInterval);
    } else {
      console.error('Max reconnection attempts reached');
    }
  }
  
  startHeartbeat() {
    this.heartbeatTimer = setInterval(() => {
      if (this.ws && this.ws.readyState === WebSocket.OPEN) {
        this.ws.send(JSON.stringify({ type: 'ping' }));
      }
    }, this.options.heartbeatInterval);
  }
  
  stopHeartbeat() {
    if (this.heartbeatTimer) {
      clearInterval(this.heartbeatTimer);
      this.heartbeatTimer = null;
    }
  }
  
  flushMessageQueue() {
    while (this.messageQueue.length > 0) {
      const message = this.messageQueue.shift();
      this.send(message);
    }
  }
}
```

## 

### æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

#### æ¶ˆæ¯æ‰¹å¤„ç†

```javascript
class BatchedWebSocket extends WebSocketManager {
  constructor(url, options = {}) {
    super(url, options);
    this.batchSize = options.batchSize || 10;
    this.batchTimeout = options.batchTimeout || 100;
    this.pendingMessages = [];
    this.batchTimer = null;
  }
  
  sendBatched(data) {
    this.pendingMessages.push(data);
    
    if (this.pendingMessages.length >= this.batchSize) {
      this.flushBatch();
    } else if (!this.batchTimer) {
      this.batchTimer = setTimeout(() => {
        this.flushBatch();
      }, this.batchTimeout);
    }
  }
  
  flushBatch() {
    if (this.pendingMessages.length > 0) {
      const batch = {
        type: 'batch',
        messages: this.pendingMessages.splice(0)
      };
      this.send(batch);
    }
    
    if (this.batchTimer) {
      clearTimeout(this.batchTimer);
      this.batchTimer = null;
    }
  }
}
```



## æœåŠ¡ç«¯æ¨é€æŠ€æœ¯å¯¹æ¯”ï¼šSSEã€WebSocket ä¸é•¿è½®è¯¢

### Server-Sent Events (SSE)

#### SSE åŸºç¡€å®ç°

```javascript
class SSEClient {
  constructor(url, options = {}) {
    this.url = url;
    this.options = {
      reconnectInterval: 3000,
      maxReconnectAttempts: 5,
      ...options
    };
    this.reconnectAttempts = 0;
    this.eventSource = null;
  }
  
  connect() {
    this.eventSource = new EventSource(this.url);
    
    this.eventSource.onopen = () => {
      console.log('SSE connection opened');
      this.reconnectAttempts = 0;
    };
    
    this.eventSource.onmessage = (event) => {
      const data = JSON.parse(event.data);
      this.handleMessage(data);
    };
    
    this.eventSource.onerror = () => {
      console.error('SSE connection error');
      this.handleReconnect();
    };
    
    // ç›‘å¬è‡ªå®šä¹‰äº‹ä»¶
    this.eventSource.addEventListener('custom-event', (event) => {
      console.log('Custom event received:', event.data);
    });
  }
  
  handleReconnect() {
    if (this.reconnectAttempts < this.options.maxReconnectAttempts) {
      this.reconnectAttempts++;
      setTimeout(() => {
        this.connect();
      }, this.options.reconnectInterval);
    }
  }
  
  close() {
    if (this.eventSource) {
      this.eventSource.close();
    }
  }
}
```



### é•¿è½®è¯¢å®ç°

#### é•¿è½®è¯¢å®¢æˆ·ç«¯

```javascript
class LongPolling {
  constructor(url, options = {}) {
    this.url = url;
    this.options = {
      timeout: 30000,
      reconnectInterval: 1000,
      maxReconnectAttempts: Infinity,
      ...options
    };
    this.isPolling = false;
    this.reconnectAttempts = 0;
  }
  
  start() {
    if (this.isPolling) return;
    this.isPolling = true;
    this.poll();
  }
  
  stop() {
    this.isPolling = false;
  }
  
  async poll() {
    while (this.isPolling) {
      try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), this.options.timeout);
        
        const response = await fetch(this.url, {
          signal: controller.signal,
          headers: {
            'Cache-Control': 'no-cache'
          }
        });
        
        clearTimeout(timeoutId);
        
        if (response.ok) {
          const data = await response.json();
          if (data && Object.keys(data).length > 0) {
            this.handleMessage(data);
          }
          this.reconnectAttempts = 0;
        } else {
          throw new Error(`HTTP ${response.status}`);
        }
        
      } catch (error) {
        if (error.name === 'AbortError') {
          console.log('Long polling timeout, retrying...');
        } else {
          console.error('Long polling error:', error);
          await this.wait(this.options.reconnectInterval);
        }
      }
    }
  }
  
  wait(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```

![image-20250529100154402](C:/Users/27019/AppData/Roaming/Typora/typora-user-images/image-20250529100154402.png)



##  å†…å®¹å®‰å…¨ç­–ç•¥ (CSP) çš„è®¾è®¡ä¸å®æ–½

### CSP åŸºç¡€é…ç½®

#### CSP å¤´éƒ¨è®¾ç½®

```javascript
// åŸºç¡€ CSP ç­–ç•¥
const basicCSP = {
  'default-src': ["'self'"],
  'script-src': ["'self'", "'unsafe-inline'", 'https://cdn.example.com'],
  'style-src': ["'self'", "'unsafe-inline'", 'https://fonts.googleapis.com'],
  'img-src': ["'self'", 'data:', 'https:'],
  'font-src': ["'self'", 'https://fonts.gstatic.com'],
  'connect-src': ["'self'", 'https://api.example.com'],
  'frame-src': ["'none'"],
  'object-src': ["'none'"],
  'base-uri': ["'self'"],
  'form-action': ["'self'"]
};

// ç”Ÿæˆ CSP å­—ç¬¦ä¸²
function generateCSP(policy) {
  return Object.entries(policy)
    .map(([directive, sources]) => `${directive} ${sources.join(' ')}`)
    .join('; ');
}
```



#### åŠ¨æ€ CSP ç®¡ç†

```javascript
class CSPManager {
  constructor() {
    this.nonces = new Set();
    this.reportEndpoint = '/csp-report';
  }
  
  generateNonce() {
    const nonce = btoa(crypto.getRandomValues(new Uint8Array(16)));
    this.nonces.add(nonce);
    return nonce;
  }
  
  createSecureScript(code, nonce) {
    const script = document.createElement('script');
    script.nonce = nonce || this.generateNonce();
    script.textContent = code;
    return script;
  }
  
  reportViolation(violationReport) {
    fetch(this.reportEndpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(violationReport)
    });
  }
  
  setupReporting() {
    document.addEventListener('securitypolicyviolation', (event) => {
      const report = {
        documentURI: event.documentURI,
        referrer: event.referrer,
        blockedURI: event.blockedURI,
        violatedDirective: event.violatedDirective,
        originalPolicy: event.originalPolicy,
        sourceFile: event.sourceFile,
        lineNumber: event.lineNumber,
        columnNumber: event.columnNumber,
        timestamp: Date.now()
      };
      
      this.reportViolation(report);
    });
  }
}
```



### æ¸è¿›å¼ CSP éƒ¨ç½²

#### CSP å…¼å®¹æ€§æ£€æµ‹

```javascript
class CSPDeployment {
  constructor() {
    this.isReportOnlyMode = true;
    this.violations = [];
  }
  
  enableReportOnlyMode() {
    const meta = document.createElement('meta');
    meta.httpEquiv = 'Content-Security-Policy-Report-Only';
    meta.content = this.generateRestrictiveCSP();
    document.head.appendChild(meta);
  }
  
  generateRestrictiveCSP() {
    return [
      "default-src 'self'",
      "script-src 'self' 'unsafe-eval'",
      "style-src 'self' 'unsafe-inline'",
      "img-src 'self' data: https:",
      "report-uri /csp-report"
    ].join('; ');
  }
  
  analyzeViolations() {
    const violationStats = this.violations.reduce((stats, violation) => {
      const directive = violation.violatedDirective;
      stats[directive] = (stats[directive] || 0) + 1;
      return stats;
    }, {});
    
    return violationStats;
  }
  
  generateOptimizedCSP() {
    const stats = this.analyzeViolations();
    // åŸºäºè¿è§„ç»Ÿè®¡ç”Ÿæˆä¼˜åŒ–çš„ CSP
    // è¿™é‡Œéœ€è¦æ ¹æ®å®é™…è¿è§„æƒ…å†µè°ƒæ•´ç­–ç•¥
  }
}
```



## å‰ç«¯å®‰å…¨é˜²å¾¡ä½“ç³»æ„å»ºï¼šXSSã€CSRFã€ç‚¹å‡»åŠ«æŒç­‰

### XSS é˜²æŠ¤

#### è¾“å…¥éªŒè¯ä¸è¾“å‡ºç¼–ç 

```javascript
class XSSProtection {
  // HTML ç¼–ç 
  static escapeHTML(str) {
    const div = document.createElement('div');
    div.textContent = str;
    return div.innerHTML;
  }
  
  // JavaScript ç¼–ç 
  static escapeJS(str) {
    return str.replace(/[\\'"<>]/g, (match) => {
      const escapeMap = {
        '\\': '\\\\',
        "'": "\\'",
        '"': '\\"',
        '<': '\\u003c',
        '>': '\\u003e'
      };
      return escapeMap[match];
    });
  }
  
  // URL ç¼–ç 
  static escapeURL(str) {
    return encodeURIComponent(str);
  }
  
  // å®‰å…¨çš„ innerHTML æ›¿ä»£
  static safeInnerHTML(element, htmlString) {
    // ä½¿ç”¨ DOMPurify æˆ–ç±»ä¼¼åº“
    if (typeof DOMPurify !== 'undefined') {
      element.innerHTML = DOMPurify.sanitize(htmlString);
    } else {
      // ç®€å•çš„ç™½åå•è¿‡æ»¤
      const cleanHTML = this.sanitizeHTML(htmlString);
      element.innerHTML = cleanHTML;
    }
  }
  
  // ç®€å•çš„ HTML å‡€åŒ–
  static sanitizeHTML(html) {
    const allowedTags = ['p', 'br', 'strong', 'em', 'u', 'span'];
    const allowedAttributes = ['class', 'id'];
    
    // è¿™é‡Œåº”è¯¥ä½¿ç”¨ä¸“ä¸šçš„ HTML å‡€åŒ–åº“
    // ä»¥ä¸‹åªæ˜¯ç¤ºä¾‹ä»£ç 
    return html.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '');
  }
  
  // å†…å®¹å®‰å…¨ç­–ç•¥æ£€æŸ¥
  static checkCSP() {
    const cspMeta = document.querySelector('meta[http-equiv="Content-Security-Policy"]');
    if (cspMeta) {
      const cspContent = cspMeta.getAttribute('content');
      return cspContent.includes("script-src") && !cspContent.includes("'unsafe-inline'");
    }
    return false;
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const userInput = "<script>alert('XSS')</script>Hello World";
const safeOutput = XSSProtection.escapeHTML(userInput);
document.getElementById('output').textContent = safeOutput;
```



### CSRF é˜²æŠ¤

#### Token éªŒè¯æœºåˆ¶

```javascript
class CSRFProtection {
  constructor() {
    this.token = null;
    this.tokenExpiry = null;
    this.refreshThreshold = 5 * 60 * 1000; // 5åˆ†é’Ÿ
  }
  
  async getToken() {
    if (!this.token || this.isTokenExpiring()) {
      await this.refreshToken();
    }
    return this.token;
  }
  
  async refreshToken() {
    try {
      const response = await fetch('/api/csrf-token', {
        method: 'GET',
        credentials: 'same-origin'
      });
      
      const data = await response.json();
      this.token = data.token;
      this.tokenExpiry = Date.now() + data.expiresIn;
    } catch (error) {
      console.error('Failed to refresh CSRF token:', error);
    }
  }
  
  isTokenExpiring() {
    return !this.tokenExpiry || (Date.now() + this.refreshThreshold) > this.tokenExpiry;
  }
  
  async makeSecureRequest(url, options = {}) {
    const token = await this.getToken();
    
    const secureOptions = {
      ...options,
      headers: {
        ...options.headers,
        'X-CSRF-Token': token
      },
      credentials: 'same-origin'
    };
    
    return fetch(url, secureOptions);
  }
  
  // è‡ªåŠ¨ä¸ºè¡¨å•æ·»åŠ  CSRF token
  protectForms() {
    document.addEventListener('submit', async (event) => {
      const form = event.target;
      if (form.tagName === 'FORM' && !form.querySelector('input[name="csrf_token"]')) {
        event.preventDefault();
        
        const token = await this.getToken();
        const tokenInput = document.createElement('input');
        tokenInput.type = 'hidden';
        tokenInput.name = 'csrf_token';
        tokenInput.value = token;
        form.appendChild(tokenInput);
        
        form.submit();
      }
    });
  }
}

// å…¨å±€ CSRF ä¿æŠ¤å®ä¾‹
const csrfProtection = new CSRFProtection();
csrfProtection.protectForms();
```



### ç‚¹å‡»åŠ«æŒé˜²æŠ¤

#### Frame Busting ä¸ X-Frame-Options

```javascript
class ClickjackingProtection {
  constructor() {
    this.init();
  }
  
  init() {
    this.preventFraming();
    this.setupFrameKiller();
    this.monitorFrameChanges();
  }
  
  // æ£€æŸ¥æ˜¯å¦åœ¨ iframe ä¸­
  isInFrame() {
    return window.self !== window.top;
  }
  
  // é˜²æ­¢é¡µé¢è¢«åµŒå…¥ iframe
  preventFraming() {
    if (this.isInFrame()) {
      // å°è¯•è·³å‡º iframe
      try {
        window.top.location = window.location;
      } catch (e) {
        // å¦‚æœè·³å‡ºå¤±è´¥ï¼Œéšè—é¡µé¢å†…å®¹
        document.body.style.display = 'none';
        this.showWarning();
      }
    }
  }
  
  // è®¾ç½® frame killer
  setupFrameKiller() {
    let bust = false;
    
    if (window.top !== window.self) {
      try {
        if (window.top.location.hostname !== window.location.hostname) {
          bust = true;
        }
      } catch (ex) {
        bust = true;
      }
    }
    
    if (bust) {
      window.top.location = window.self.location;
    }
  }
  
  // ç›‘æ§ frame ç¯å¢ƒå˜åŒ–
  monitorFrameChanges() {
    setInterval(() => {
      if (this.isInFrame() && !this.isAllowedFrame()) {
        this.preventFraming();
      }
    }, 1000);
  }
  
  // æ£€æŸ¥æ˜¯å¦ä¸ºå…è®¸çš„ frame
  isAllowedFrame() {
    const allowedDomains = ['trusted-domain.com', 'partner-site.com'];
    
    try {
      const parentHostname = window.parent.location.hostname;
      return allowedDomains.includes(parentHostname);
    } catch (e) {
      return false;
    }
  }
  
  // æ˜¾ç¤ºè­¦å‘Šä¿¡æ¯
  showWarning() {
    const warning = document.createElement('div');
    warning.innerHTML = `
      <div style="
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: #f44336;
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 24px;
        z-index: 999999;
      ">
        å®‰å…¨è­¦å‘Šï¼šæ­¤é¡µé¢ä¸åº”åœ¨æ¡†æ¶ä¸­æ˜¾ç¤º
        <br>
        <a href="${window.location.href}" style="color: white; text-decoration: underline;">
          ç‚¹å‡»æ­¤å¤„åœ¨æ–°çª—å£ä¸­æ‰“å¼€
        </a>
      </div>
    `;
    document.body.appendChild(warning);
  }
}

// å¯ç”¨ç‚¹å‡»åŠ«æŒä¿æŠ¤
new ClickjackingProtection();
```



### ç»¼åˆå®‰å…¨é˜²æŠ¤

#### å®‰å…¨æ£€æŸ¥å™¨

```javascript
class SecurityChecker {
  constructor() {
    this.checks = [
      this.checkHTTPS,
      this.checkCSP,
      this.checkXFrameOptions,
      this.checkSecureCookies,
      this.checkMixedContent
    ];
  }
  
  async runAllChecks() {
    const results = await Promise.all(
      this.checks.map(check => this.runCheck(check))
    );
    
    return {
      passed: results.filter(r => r.passed).length,
      failed: results.filter(r => !r.passed).length,
      total: results.length,
      details: results
    };
  }
  
  async runCheck(checkFunction) {
    try {
      const result = await checkFunction.call(this);
      return { ...result, error: null };
    } catch (error) {
      return {
        name: checkFunction.name,
        passed: false,
        message: `æ£€æŸ¥å¤±è´¥: ${error.message}`,
        error: error
      };
    }
  }
  
  checkHTTPS() {
    const isHTTPS = location.protocol === 'https:';
    return {
      name: 'HTTPSæ£€æŸ¥',
      passed: isHTTPS,
      message: isHTTPS ? 'HTTPSå·²å¯ç”¨' : 'å»ºè®®ä½¿ç”¨HTTPSåè®®',
      severity: isHTTPS ? 'low' : 'high'
    };
  }
  
  checkCSP() {
    const cspHeader = document.querySelector('meta[http-equiv="Content-Security-Policy"]');
    const hasCSP = !!cspHeader;
    
    let cspQuality = 'none';
    if (hasCSP) {
      const content = cspHeader.getAttribute('content');
      if (content.includes("'unsafe-inline'") || content.includes("'unsafe-eval'")) {
        cspQuality = 'weak';
      } else {
        cspQuality = 'strong';
      }
    }
    
    return {
      name: 'CSPæ£€æŸ¥',
      passed: hasCSP && cspQuality === 'strong',
      message: `CSPçŠ¶æ€: ${cspQuality}`,
      severity: cspQuality === 'none' ? 'high' : cspQuality === 'weak' ? 'medium' : 'low'
    };
  }
  
  checkXFrameOptions() {
    return new Promise((resolve) => {
      // æ£€æŸ¥ X-Frame-Options é€šè¿‡å‘é€è¯·æ±‚åˆ°è‡ªèº«
      fetch(window.location.href, { method: 'HEAD' })
        .then(response => {
          const xFrameOptions = response.headers.get('X-Frame-Options');
          const hasProtection = !!xFrameOptions;
          
          resolve({
            name: 'X-Frame-Optionsæ£€æŸ¥',
            passed: hasProtection,
            message: hasProtection ? `X-Frame-Options: ${xFrameOptions}` : 'ç¼ºå°‘X-Frame-Optionså¤´éƒ¨',
            severity: hasProtection ? 'low' : 'medium'
          });
        })
        .catch(() => {
          resolve({
            name: 'X-Frame-Optionsæ£€æŸ¥',
            passed: false,
            message: 'æ— æ³•æ£€æŸ¥X-Frame-Options',
            severity: 'medium'
          });
        });
    });
  }
  
  checkSecureCookies() {
    const cookies = document.cookie.split(';');
    const insecureCookies = cookies.filter(cookie => {
      return cookie.trim() && !cookie.includes('Secure') && !cookie.includes('HttpOnly');
    });
    
    return {
      name: 'å®‰å…¨Cookieæ£€æŸ¥',
      passed: insecureCookies.length === 0,
      message: insecureCookies.length > 0 ? 
        `å‘ç° ${insecureCookies.length} ä¸ªä¸å®‰å…¨çš„Cookie` : 
        'æ‰€æœ‰Cookieéƒ½å…·æœ‰å®‰å…¨æ ‡å¿—',
      severity: insecureCookies.length > 0 ? 'medium' : 'low'
    };
  }
  
  checkMixedContent() {
    const insecureResources = [];
    
    // æ£€æŸ¥å›¾ç‰‡
    document.querySelectorAll('img[src^="http:"]').forEach(img => {
      insecureResources.push({ type: 'image', url: img.src });
    });
    
    // æ£€æŸ¥è„šæœ¬
    document.querySelectorAll('script[src^="http:"]').forEach(script => {
      insecureResources.push({ type: 'script', url: script.src });
    });
    
    // æ£€æŸ¥æ ·å¼è¡¨
    document.querySelectorAll('link[href^="http:"]').forEach(link => {
      insecureResources.push({ type: 'stylesheet', url: link.href });
    });
    
    return {
      name: 'æ··åˆå†…å®¹æ£€æŸ¥',
      passed: insecureResources.length === 0,
      message: insecureResources.length > 0 ? 
        `å‘ç° ${insecureResources.length} ä¸ªä¸å®‰å…¨çš„èµ„æº` : 
        'æœªå‘ç°æ··åˆå†…å®¹',
      details: insecureResources,
      severity: insecureResources.length > 0 ? 'high' : 'low'
    };
  }
  
  generateReport(results) {
    const report = {
      timestamp: new Date().toISOString(),
      url: window.location.href,
      userAgent: navigator.userAgent,
      summary: {
        total: results.total,
        passed: results.passed,
        failed: results.failed,
        score: Math.round((results.passed / results.total) * 100)
      },
      checks: results.details,
      recommendations: this.generateRecommendations(results.details)
    };
    
    return report;
  }
  
  generateRecommendations(checks) {
    const recommendations = [];
    
    checks.forEach(check => {
      if (!check.passed) {
        switch (check.name) {
          case 'HTTPSæ£€æŸ¥':
            recommendations.push({
              priority: 'high',
              action: 'å¯ç”¨HTTPS',
              description: 'ä½¿ç”¨SSL/TLSè¯ä¹¦ä¿æŠ¤æ•°æ®ä¼ è¾“'
            });
            break;
          case 'CSPæ£€æŸ¥':
            recommendations.push({
              priority: 'high',
              action: 'é…ç½®å†…å®¹å®‰å…¨ç­–ç•¥',
              description: 'å®æ–½ä¸¥æ ¼çš„CSPä»¥é˜²æ­¢XSSæ”»å‡»'
            });
            break;
          case 'X-Frame-Optionsæ£€æŸ¥':
            recommendations.push({
              priority: 'medium',
              action: 'è®¾ç½®X-Frame-Optionså¤´éƒ¨',
              description: 'é˜²æ­¢ç‚¹å‡»åŠ«æŒæ”»å‡»'
            });
            break;
          case 'å®‰å…¨Cookieæ£€æŸ¥':
            recommendations.push({
              priority: 'medium',
              action: 'ä¸ºCookieæ·»åŠ å®‰å…¨æ ‡å¿—',
              description: 'ä½¿ç”¨Secureå’ŒHttpOnlyæ ‡å¿—ä¿æŠ¤Cookie'
            });
            break;
          case 'æ··åˆå†…å®¹æ£€æŸ¥':
            recommendations.push({
              priority: 'high',
              action: 'ä¿®å¤æ··åˆå†…å®¹',
              description: 'å°†æ‰€æœ‰HTTPèµ„æºå‡çº§ä¸ºHTTPS'
            });
            break;
        }
      }
    });
    
    return recommendations.sort((a, b) => {
      const priority = { high: 3, medium: 2, low: 1 };
      return priority[b.priority] - priority[a.priority];
    });
  }
}

// å®‰å…¨ç›‘æ§å’ŒæŠ¥å‘Š
class SecurityMonitor {
  constructor() {
    this.checker = new SecurityChecker();
    this.alertThreshold = 60; // å®‰å…¨è¯„åˆ†é˜ˆå€¼
    this.monitoringInterval = 5 * 60 * 1000; // 5åˆ†é’Ÿ
    this.isMonitoring = false;
  }
  
  async startMonitoring() {
    if (this.isMonitoring) return;
    
    this.isMonitoring = true;
    console.log('å®‰å…¨ç›‘æ§å·²å¯åŠ¨');
    
    // ç«‹å³æ‰§è¡Œä¸€æ¬¡æ£€æŸ¥
    await this.performSecurityCheck();
    
    // å®šæœŸæ£€æŸ¥
    this.monitoringTimer = setInterval(async () => {
      await this.performSecurityCheck();
    }, this.monitoringInterval);
  }
  
  stopMonitoring() {
    this.isMonitoring = false;
    if (this.monitoringTimer) {
      clearInterval(this.monitoringTimer);
    }
    console.log('å®‰å…¨ç›‘æ§å·²åœæ­¢');
  }
  
  async performSecurityCheck() {
    try {
      const results = await this.checker.runAllChecks();
      const report = this.checker.generateReport(results);
      
      console.log('å®‰å…¨æ£€æŸ¥æŠ¥å‘Š:', report);
      
      if (report.summary.score < this.alertThreshold) {
        this.triggerSecurityAlert(report);
      }
      
      // å‘é€æŠ¥å‘Šåˆ°ç›‘æ§æœåŠ¡
      this.sendReport(report);
      
      return report;
    } catch (error) {
      console.error('å®‰å…¨æ£€æŸ¥å¤±è´¥:', error);
    }
  }
  
  triggerSecurityAlert(report) {
    const alert = {
      type: 'security_alert',
      severity: 'warning',
      score: report.summary.score,
      timestamp: report.timestamp,
      url: report.url,
      failedChecks: report.checks.filter(check => !check.passed),
      recommendations: report.recommendations.slice(0, 3) // å‰3ä¸ªä¼˜å…ˆçº§æœ€é«˜çš„å»ºè®®
    };
    
    console.warn('ğŸš¨ å®‰å…¨è­¦æŠ¥:', alert);
    
    // å¯ä»¥åœ¨è¿™é‡Œå®ç°é€šçŸ¥æœºåˆ¶
    this.showSecurityNotification(alert);
  }
  
  showSecurityNotification(alert) {
    // åˆ›å»ºå®‰å…¨é€šçŸ¥UI
    if (!document.getElementById('security-notification')) {
      const notification = document.createElement('div');
      notification.id = 'security-notification';
      notification.innerHTML = `
        <div style="
          position: fixed;
          top: 20px;
          right: 20px;
          background: #ff5722;
          color: white;
          padding: 15px;
          border-radius: 5px;
          box-shadow: 0 4px 6px rgba(0,0,0,0.1);
          z-index: 10000;
          max-width: 300px;
          font-family: Arial, sans-serif;
        ">
          <div style="font-weight: bold; margin-bottom: 10px;">
            ğŸš¨ å®‰å…¨è­¦æŠ¥
          </div>
          <div style="font-size: 14px; margin-bottom: 10px;">
            å®‰å…¨è¯„åˆ†: ${alert.score}%
          </div>
          <div style="font-size: 12px; margin-bottom: 10px;">
            å‘ç° ${alert.failedChecks.length} ä¸ªå®‰å…¨é—®é¢˜
          </div>
          <button onclick="this.parentElement.parentElement.remove()" style="
            background: white;
            color: #ff5722;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
          ">
            å…³é—­
          </button>
        </div>
      `;
      document.body.appendChild(notification);
      
      // 5ç§’åè‡ªåŠ¨ç§»é™¤
      setTimeout(() => {
        const elem = document.getElementById('security-notification');
        if (elem) elem.remove();
      }, 5000);
    }
  }
  
  async sendReport(report) {
    try {
      await fetch('/api/security-report', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(report)
      });
    } catch (error) {
      console.error('å‘é€å®‰å…¨æŠ¥å‘Šå¤±è´¥:', error);
    }
  }
}

// å®ç”¨å·¥å…·å‡½æ•°
class SecurityUtils {
  // ç”Ÿæˆå®‰å…¨çš„éšæœºå­—ç¬¦ä¸²
  static generateSecureRandom(length = 32) {
    const array = new Uint8Array(length);
    crypto.getRandomValues(array);
    return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
  }
  
  // å®‰å…¨çš„å­—ç¬¦ä¸²æ¯”è¾ƒï¼ˆé˜²æ­¢æ—¶åºæ”»å‡»ï¼‰
  static safeStringCompare(a, b) {
    if (a.length !== b.length) {
      return false;
    }
    
    let result = 0;
    for (let i = 0; i < a.length; i++) {
      result |= a.charCodeAt(i) ^ b.charCodeAt(i);
    }
    
    return result === 0;
  }
  
  // æ£€æµ‹æ½œåœ¨çš„æ¶æ„è½½è·
  static detectMaliciousPayload(input) {
    const patterns = [
      /<script[^>]*>.*?<\/script>/gi,
      /javascript:/gi,
      /on\w+\s*=/gi,
      /<iframe[^>]*>/gi,
      /eval\s*\(/gi,
      /document\.write/gi,
      /window\.location/gi
    ];
    
    return patterns.some(pattern => pattern.test(input));
  }
  
  // å®‰å…¨çš„JSONè§£æ
  static safeJSONParse(jsonString, defaultValue = null) {
    try {
      const parsed = JSON.parse(jsonString);
      
      // æ£€æŸ¥æ˜¯å¦åŒ…å«æ½œåœ¨å±é™©çš„å†…å®¹
      const stringified = JSON.stringify(parsed);
      if (this.detectMaliciousPayload(stringified)) {
        console.warn('æ£€æµ‹åˆ°æ½œåœ¨æ¶æ„JSONè½½è·');
        return defaultValue;
      }
      
      return parsed;
    } catch (error) {
      console.error('JSONè§£æå¤±è´¥:', error);
      return defaultValue;
    }
  }
  
  // åˆ›å»ºå®‰å…¨çš„äº‹ä»¶ç›‘å¬å™¨
  static addSecureEventListener(element, event, handler, options = {}) {
    const secureHandler = (e) => {
      // æ·»åŠ åŸºæœ¬çš„å®‰å…¨æ£€æŸ¥
      if (e.isTrusted === false) {
        console.warn('æ£€æµ‹åˆ°ä¸å¯ä¿¡äº‹ä»¶ï¼Œå·²é˜»æ­¢å¤„ç†');
        return;
      }
      
      try {
        handler(e);
      } catch (error) {
        console.error('äº‹ä»¶å¤„ç†å™¨æ‰§è¡Œå¤±è´¥:', error);
      }
    };
    
    element.addEventListener(event, secureHandler, {
      passive: true,
      ...options
    });
    
    return () => element.removeEventListener(event, secureHandler);
  }
}

// ä½¿ç”¨ç¤ºä¾‹å’Œæœ€ä½³å®è·µ
class SecurityBestPractices {
  static init() {
    console.log('ğŸ”’ åˆå§‹åŒ–å‰ç«¯å®‰å…¨é˜²æŠ¤ç³»ç»Ÿ');
    
    // å¯åŠ¨å®‰å…¨ç›‘æ§
    const monitor = new SecurityMonitor();
    monitor.startMonitoring();
    
    // è®¾ç½®å…¨å±€é”™è¯¯å¤„ç†
    this.setupGlobalErrorHandling();
    
    // è®¾ç½®å®‰å…¨å¤´éƒ¨æ£€æŸ¥
    this.checkSecurityHeaders();
    
    // è®¾ç½®å†…å®¹å®Œæ•´æ€§æ£€æŸ¥
    this.setupIntegrityChecks();
    
    console.log('âœ… å‰ç«¯å®‰å…¨é˜²æŠ¤ç³»ç»Ÿå·²å¯åŠ¨');
  }
  
  static setupGlobalErrorHandling() {
    window.addEventListener('error', (event) => {
      // è®°å½•è„šæœ¬é”™è¯¯
      console.error('è„šæœ¬é”™è¯¯:', {
        message: event.message,
        filename: event.filename,
        lineno: event.lineno,
        colno: event.colno,
        error: event.error
      });
    });
    
    window.addEventListener('unhandledrejection', (event) => {
      // è®°å½•æœªå¤„ç†çš„Promiseæ‹’ç»
      console.error('æœªå¤„ç†çš„Promiseæ‹’ç»:', event.reason);
    });
  }
  
  static checkSecurityHeaders() {
    fetch(window.location.href, { method: 'HEAD' })
      .then(response => {
        const headers = {
          'Strict-Transport-Security': response.headers.get('Strict-Transport-Security'),
          'X-Content-Type-Options': response.headers.get('X-Content-Type-Options'),
          'X-Frame-Options': response.headers.get('X-Frame-Options'),
          'X-XSS-Protection': response.headers.get('X-XSS-Protection'),
          'Referrer-Policy': response.headers.get('Referrer-Policy')
        };
        
        console.log('å®‰å…¨å¤´éƒ¨æ£€æŸ¥:', headers);
      })
      .catch(error => {
        console.error('æ— æ³•æ£€æŸ¥å®‰å…¨å¤´éƒ¨:', error);
      });
  }
  
  static setupIntegrityChecks() {
    // æ£€æŸ¥æ‰€æœ‰è„šæœ¬å’Œæ ·å¼è¡¨çš„å®Œæ•´æ€§
    const resources = document.querySelectorAll('script[src], link[rel="stylesheet"]');
    
    resources.forEach(resource => {
      if (!resource.integrity) {
        console.warn('èµ„æºç¼ºå°‘å®Œæ•´æ€§æ£€æŸ¥:', resource.src || resource.href);
      }
    });
  }
}

// é¡µé¢åŠ è½½å®Œæˆåè‡ªåŠ¨åˆå§‹åŒ–å®‰å…¨ç³»ç»Ÿ
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', SecurityBestPractices.init);
} else {
  SecurityBestPractices.init();
}
```

## æ€»ç»“

### å®‰å…¨æ£€æŸ¥æ¸…å•

#### å¼€å‘é˜¶æ®µ

-  å®æ–½å†…å®¹å®‰å…¨ç­–ç•¥ (CSP)
-  é…ç½®å®‰å…¨HTTPå¤´éƒ¨
-  ä½¿ç”¨HTTPSå’Œå®‰å…¨Cookie
-  å®æ–½è¾“å…¥éªŒè¯å’Œè¾“å‡ºç¼–ç 
-  é…ç½®CORSç­–ç•¥
-  æ·»åŠ CSRFä¿æŠ¤

#### éƒ¨ç½²é˜¶æ®µ

-  å¯ç”¨HSTS
-  é…ç½®X-Frame-Options
-  è®¾ç½®X-Content-Type-Options
-  å®æ–½å®Œæ•´æ€§æ£€æŸ¥
-  é…ç½®å®‰å…¨çš„Referrerç­–ç•¥

#### ç›‘æ§é˜¶æ®µ

-  è®¾ç½®CSPæŠ¥å‘Š
-  ç›‘æ§å®‰å…¨äº‹ä»¶
-  å®šæœŸå®‰å…¨è¯„ä¼°
-  æ›´æ–°å®‰å…¨ç­–ç•¥
-  å“åº”å®‰å…¨äº‹ä»¶

### æ€§èƒ½ä¸å®‰å…¨å¹³è¡¡

åœ¨å®æ–½å®‰å…¨æªæ–½æ—¶ï¼Œéœ€è¦åœ¨å®‰å…¨æ€§å’Œæ€§èƒ½ä¹‹é—´æ‰¾åˆ°å¹³è¡¡ç‚¹ï¼š

1. **CSPç­–ç•¥**: é€æ­¥æ”¶ç´§ï¼Œé¿å…ä¸€æ¬¡æ€§è¿‡äºä¸¥æ ¼
2. **CORSé…ç½®**: ç²¾ç¡®é…ç½®æ¥æºï¼Œé¿å…ä½¿ç”¨é€šé…ç¬¦
3. **åŠ å¯†é€šä¿¡**: ä½¿ç”¨ç°ä»£TLSç‰ˆæœ¬å’Œå¯†ç å¥—ä»¶
4. **èµ„æºå®Œæ•´æ€§**: å¯¹å…³é”®èµ„æºå¯ç”¨SRIæ£€æŸ¥
5. **ç›‘æ§æŠ¥å‘Š**: åˆç†è®¾ç½®æŠ¥å‘Šé¢‘ç‡ï¼Œé¿å…è¿‡å¤šå™ªéŸ³



