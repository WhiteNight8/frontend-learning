# JavaScript 引擎与优化



## V8 引擎架构与 JavaScript 代码执行流程

### 8 引擎整体架构

V8 是 Google 开发的高性能 JavaScript 引擎，采用了现代化的架构设计：

```
JavaScript 源代码
        ↓
    词法分析器 (Scanner)
        ↓
    语法分析器 (Parser)
        ↓
    抽象语法树 (AST)
        ↓
    Ignition 字节码解释器
        ↓
    TurboFan 优化编译器
        ↓
    机器码执行
```

### 代码执行流程详解

**第一阶段：解析 (Parsing)**

- **词法分析**：将 JavaScript 源代码分解为 Token 序列
- **语法分析**：根据 Token 构建抽象语法树 (AST)
- **作用域分析**：分析变量作用域和闭包关系

**第二阶段：字节码生成**

- Ignition 解释器将 AST 转换为字节码
- 字节码是介于源代码和机器码之间的中间表示
- 相比直接编译为机器码，字节码更紧凑，启动更快

**第三阶段：执行与优化**

- Ignition 解释器执行字节码
- 收集执行过程中的性能分析数据 (Profiling)
- 热点代码被标记并传递给 TurboFan 进行优化编译



##  JIT 编译器优化策略：隐藏类、内联缓存等

### 隐藏类 (Hidden Classes)

JavaScript 是动态类型语言，但 V8 通过隐藏类技术实现了类似静态类型的优化：

```javascript
// 示例：隐藏类的创建过程
function Point(x, y) {
    this.x = x;  // 创建隐藏类 C0 -> C1
    this.y = y;  // 隐藏类 C1 -> C2
}

let p1 = new Point(1, 2);  // 使用隐藏类 C2
let p2 = new Point(3, 4);  // 复用隐藏类 C2
```

**隐藏类工作原理**：

- 每个对象都关联一个隐藏类，描述对象的结构
- 相同结构的对象共享同一个隐藏类
- 属性访问可以通过固定偏移量实现，避免哈希表查找
- 隐藏类转换形成转换链，支持对象结构的动态变化

### 内联缓存 (Inline Caching)

内联缓存是一种运行时优化技术，用于加速属性访问和方法调用：

```javascript
// 示例：内联缓存的应用场景
function processPoints(points) {
    for (let i = 0; i < points.length; i++) {
        // 属性访问 points[i].x 会被内联缓存优化
        console.log(points[i].x + points[i].y);
    }
}
```

**内联缓存机制**：

- **单态 (Monomorphic)**：缓存一种类型的对象访问
- **多态 (Polymorphic)**：缓存多种类型的对象访问
- **超态 (Megamorphic)**：类型过多时放弃缓存，回退到通用访问方式

### 其他 JIT 优化策略

**函数内联 (Function Inlining)**

- 将小函数的代码直接嵌入到调用点
- 减少函数调用开销，增加其他优化机会

**循环优化**

- 循环不变式外提
- 循环展开
- 边界检查消除

**死代码消除**

- 移除永远不会执行的代码分支
- 消除无用的变量和计算



## V8 的垃圾回收机制与内存管理

### 内存布局

V8 将堆内存分为几个不同的区域：

```
V8 堆内存布局
├── 新生代 (New Space)
│   ├── From 空间
│   └── To 空间
├── 老生代 (Old Space)
│   ├── 老生代指针空间
│   └── 老生代数据空间
├── 大对象空间 (Large Object Space)
├── 代码空间 (Code Space)
└── Map 空间
```



**新生代垃圾回收 (Scavenge)**

- 采用 Cheney 算法的半空间复制策略
- 将存活对象从 From 空间复制到 To 空间
- 复制完成后交换 From 和 To 空间的角色
- 适合处理生命周期短的对象

**老生代垃圾回收 (Mark-Sweep-Compact)**

- **标记阶段**：标记所有可达对象
- **清扫阶段**：清理未标记的对象
- **整理阶段**：移动对象以消除内存碎片

### 增量标记与并发标记

**增量标记 (Incremental Marking)**

- 将标记工作分散到多个小的时间片中执行
- 避免长时间的垃圾回收暂停
- 与 JavaScript 执行交替进行

**并发标记 (Concurrent Marking)**

- 标记工作在后台线程中并发执行
- 主线程可以继续执行 JavaScript 代码
- 进一步减少垃圾回收对应用性能的影响

### 写屏障与对象晋升

**写屏障 (Write Barrier)**

- 监控新生代对象对老生代对象的引用
- 确保增量标记的正确性
- 维护跨代引用的记录集合

**对象晋升 (Object Promotion)**

- 新生代中存活一定次数的对象晋升到老生代
- 大对象直接分配在老生代
- 避免频繁的新生代垃圾回收



## V8 中的对象存储与属性访问优化

### 对象表示方式

**快属性 (Fast Properties)**

```javascript
// 快属性对象：属性存储在对象内部的固定槽位
const obj = {
    name: "Alice",
    age: 30,
    city: "Beijing"
};
```

**慢属性 (Slow Properties)**

```javascript
// 慢属性对象：属性存储在哈希表中
const obj = {};
for (let i = 0; i < 1000; i++) {
    obj[`prop${i}`] = i;  // 大量属性导致转为慢属性
}
```



### 元素存储策略

**快元素 (Fast Elements)**

- 密集数组使用连续内存存储
- 支持不同的元素类型特化存储
- 包括 PACKED_SMI_ELEMENTS、PACKED_DOUBLE_ELEMENTS 等

**慢元素 (Slow Elements)**

- 稀疏数组或包含空洞的数组
- 使用字典存储，访问性能较低

### 属性访问优化技术

**形状转换链 (Shape Transition Chain)**

```javascript
// 形状转换链示例
const obj = {};           // Shape S0
obj.x = 1;               // Shape S0 -> S1
obj.y = 2;               // Shape S1 -> S2
obj.z = 3;               // Shape S2 -> S3
```

**原型链优化**

- 原型链查找的内联缓存
- 原型链稳定性检查
- 原型形状的监控和优化



## 深入理解 V8 的字节码解释器 Ignition

### Ignition 的设计目标

Ignition 是 V8 的字节码解释器，具有以下特点：

- **内存效率**：字节码比机器码更紧凑
- **启动性能**：避免编译开销，快速执行
- **优化收集**：为 TurboFan 收集运行时信息



### 字节码指令集

Ignition 使用了精心设计的字节码指令集：

```javascript
// JavaScript 代码
function add(a, b) {
    return a + b;
}

// 对应的字节码（简化表示）
[
    Ldar r0,        // 加载参数 a 到累加器
    Add r1,         // 累加器与参数 b 相加
    Return          // 返回累加器中的值
]
```



**常见字节码指令类型**：

- **加载/存储指令**：Ldar, Star, LdaGlobal
- **算术运算指令**：Add, Sub, Mul, Div
- **比较指令**：TestEqual, TestLessThan
- **控制流指令**：Jump, JumpIfFalse, Return
- **对象操作指令**：LoadNamedProperty, StoreNamedProperty

### 字节码优化

**寄存器分配**

- Ignition 使用寄存器机器模型
- 通过寄存器分配减少内存访问
- 累加器寄存器用于临时计算结果

**字节码压缩**

- 操作数编码优化
- 常用操作的特化指令
- 减少字节码体积



## TurboFan 优化编译器的工作原理

### TurboFan 架构

TurboFan 是 V8 的优化编译器，采用了现代编译器的经典架构：

```
字节码
    ↓
图构建 (Graph Building)
    ↓
类型化 (Typing)
    ↓
优化过程 (Optimization Phases)
    ↓
指令选择 (Instruction Selection)
    ↓
寄存器分配 (Register Allocation)
    ↓
机器码生成 (Code Generation)
```

### 中间表示 (IR)

**Sea of Nodes**

- TurboFan 使用基于图的中间表示
- 节点表示操作，边表示数据和控制依赖
- 支持复杂的程序分析和优化

**类型系统**

- 精确的类型信息指导优化
- 类型特化和类型守卫
- 支持投机性优化



### 关键优化技术

**逃逸分析 (Escape Analysis)**

```javascript
// 示例：逃逸分析优化
function createPoint(x, y) {
    const point = { x, y };    // 对象可能被栈分配
    return point.x + point.y;  // 对象未逃逸，可以标量替换
}
```

**循环优化**

- 循环不变式代码外提
- 强度削减优化
- 循环向量化

**内联优化**

- 基于调用频率的内联决策
- 多态内联支持
- 内联预算管理



### 去优化 (Deoptimization)

当优化假设不再成立时，TurboFan 会触发去优化：

```javascript
// 示例：去优化场景
function add(a, b) {
    return a + b;  // 假设 a, b 都是数字
}

// 如果后来传入字符串，会触发去优化
add(1, 2);      // 数字相加，优化版本
add("a", "b");  // 字符串拼接，触发去优化
```

**去优化过程**：

1. 检测优化假设失效
2. 从优化代码回退到字节码
3. 更新类型反馈信息
4. 重新进入解释执行



## 如何编写 V8 友好的高性能 JavaScript 代码

### 对象结构优化

**保持对象形状稳定**

```javascript
// 好的做法：构造函数中初始化所有属性
function Point(x, y, z) {
    this.x = x || 0;
    this.y = y || 0;
    this.z = z || 0;
}

// 避免的做法：动态添加属性
function Point(x, y) {
    this.x = x;
    this.y = y;
    // 稍后动态添加 z 属性会改变对象形状
}
```

**避免属性删除**

```javascript
// 避免删除属性，会导致形状转换
delete obj.property;

// 更好的做法：设置为 undefined
obj.property = undefined;
```



### 数组优化策略

**保持数组元素类型一致**

```javascript
// 好的做法：同质数组
const numbers = [1, 2, 3, 4, 5];

// 避免的做法：异质数组
const mixed = [1, "hello", true, null];  // 类型混合影响性能
```



**避免稀疏数组**

```javascript
// 避免创建稀疏数组
const sparse = [];
sparse[1000] = 1;  // 创建了大量空洞

// 更好的做法：使用 Map 或压缩存储
const map = new Map();
map.set(1000, 1);
```



### 函数优化技巧

**避免多态调用**

```javascript
// 尽量保持函数参数类型一致
function calculate(obj) {
    return obj.value * 2;
}

// 避免传入不同形状的对象
calculate({ value: 10 });           // Shape A
calculate({ value: 20, name: "x" }); // Shape B - 导致多态
```



**利用内联优化**

```javascript
// 小函数更容易被内联
function add(a, b) {
    return a + b;
}

// 避免过大的函数，影响内联决策
function complexFunction() {
    // ... 大量代码
}
```



### 内存管理最佳实践

**减少对象分配**

```javascript
// 重用对象而不是创建新对象
const point = { x: 0, y: 0 };

function updatePoint(newX, newY) {
    point.x = newX;
    point.y = newY;
    return point;  // 重用现有对象
}
```



**及时释放引用**

```javascript
// 避免内存泄漏
let largeData = new Array(1000000);

function processData() {
    // 处理数据
    // ...
    
    // 处理完成后释放引用
    largeData = null;
}
```



### 性能监控与调试

**使用 V8 性能工具**

```bash
# 启用性能分析
node --prof script.js

# 分析性能数据
node --prof-process isolate-*.log

# 查看优化状态
node --trace-opt script.js

# 查看去优化信息
node --trace-deopt script.js
```



**代码热点识别**

```javascript
// 使用 performance API 测量关键代码段
function measurePerformance(fn, name) {
    const start = performance.now();
    fn();
    const end = performance.now();
    console.log(`${name}: ${end - start}ms`);
}

measurePerformance(() => {
    // 需要测量的代码
}, "Critical Function");
```



### 避免常见反模式

**避免 arguments 对象**

```javascript
// 避免使用 arguments
function oldWay() {
    const args = Array.prototype.slice.call(arguments);
    // ...
}

// 使用剩余参数
function newWay(...args) {
    // args 已经是数组
}
```



**避免 with 和 eval**

```javascript
// 避免使用 with 语句，影响作用域分析
with (obj) {
    property = value;
}

// 避免 eval，阻止优化
eval("x = 1");
```





**合理使用 try-catch**

```javascript
// 将 try-catch 隔离到单独函数中
function riskyOperation() {
    // 可能抛出异常的代码
}

function safeWrapper() {
    try {
        return riskyOperation();
    } catch (e) {
        return null;
    }
}

// 在热点代码路径中调用 safeWrapper
function hotPath() {
    const result = safeWrapper();
    // 其他优化友好的代码
```





# 性能优化策略

## JavaScript 性能分析工具与方法论

### 浏览器开发者工具

**Chrome DevTools Performance 面板**

```javascript
// 性能分析基本流程
function analyzePerformance() {
    // 1. 打开 DevTools -> Performance
    // 2. 点击录制按钮
    console.time('Performance Test');
    
    // 执行需要分析的代码
    performCriticalOperation();
    
    console.timeEnd('Performance Test');
    // 3. 停止录制并分析结果
}

function performCriticalOperation() {
    // 模拟复杂操作
    const data = [];
    for (let i = 0; i < 100000; i++) {
        data.push({
            id: i,
            value: Math.random(),
            processed: false
        });
    }
    return data;
}
```

**Memory 面板使用**

```javascript
// 内存快照分析示例
class MemoryAnalysis {
    constructor() {
        this.data = new Map();
        this.listeners = [];
    }
    
    // 在 Memory 面板中观察内存使用情况
    addData(key, value) {
        this.data.set(key, value);
    }
    
    // 检查内存泄漏
    addEventListener(element, event, handler) {
        element.addEventListener(event, handler);
        this.listeners.push({ element, event, handler });
    }
    
    // 清理资源
    cleanup() {
        this.listeners.forEach(({ element, event, handler }) => {
            element.removeEventListener(event, handler);
        });
        this.listeners.length = 0;
        this.data.clear();
    }
}
```

### Node.js 性能分析工具

**内置性能分析器**

```javascript
// 使用 --prof 标志
// node --prof app.js

// 性能分析代码
const { performance, PerformanceObserver } = require('perf_hooks');

// 创建性能观察器
const obs = new PerformanceObserver((list) => {
    const entries = list.getEntries();
    entries.forEach((entry) => {
        console.log(`${entry.name}: ${entry.duration}ms`);
    });
});

obs.observe({ entryTypes: ['measure', 'mark'] });

// 标记性能测量点
function measureFunction() {
    performance.mark('start-operation');
    
    // 执行复杂操作
    const result = heavyComputation();
    
    performance.mark('end-operation');
    performance.measure('operation-duration', 'start-operation', 'end-operation');
    
    return result;
}
```

**第三方性能分析工具**

```javascript
// 使用 benchmark.js 进行性能基准测试
const Benchmark = require('benchmark');
const suite = new Benchmark.Suite();

// 比较不同实现方案的性能
suite
    .add('Array.forEach', function() {
        const arr = [1, 2, 3, 4, 5];
        const result = [];
        arr.forEach(item => result.push(item * 2));
    })
    .add('for loop', function() {
        const arr = [1, 2, 3, 4, 5];
        const result = [];
        for (let i = 0; i < arr.length; i++) {
            result.push(arr[i] * 2);
        }
    })
    .add('Array.map', function() {
        const arr = [1, 2, 3, 4, 5];
        const result = arr.map(item => item * 2);
    })
    .on('cycle', function(event) {
        console.log(String(event.target));
    })
    .on('complete', function() {
        console.log('Fastest is ' + this.filter('fastest').map('name'));
    })
    .run({ async: true });
```

### 性能分析方法论

**RAIL 模型**

```javascript
// Response: 响应用户输入应在 100ms 内
function handleUserInput(event) {
    const startTime = performance.now();
    
    processUserInput(event);
    
    const endTime = performance.now();
    if (endTime - startTime > 100) {
        console.warn('Response time exceeded 100ms');
    }
}

// Animation: 动画帧应在 16ms 内完成
function animationFrame() {
    const startTime = performance.now();
    
    updateAnimation();
    
    const endTime = performance.now();
    if (endTime - startTime > 16) {
        console.warn('Animation frame exceeded 16ms');
    }
}

// Idle: 利用空闲时间执行非关键任务
function performIdleWork() {
    if (typeof requestIdleCallback !== 'undefined') {
        requestIdleCallback((deadline) => {
            while (deadline.timeRemaining() > 0) {
                performNonCriticalTask();
            }
        });
    }
}

// Load: 页面加载应在 1000ms 内完成关键路径
function measureLoadTime() {
    window.addEventListener('load', () => {
        const loadTime = performance.timing.loadEventEnd - 
                        performance.timing.navigationStart;
        if (loadTime > 1000) {
            console.warn('Page load time exceeded 1000ms');
        }
    });
}
```



## 内存管理与内存泄漏排查技术

### 常见内存泄漏模式

**全局变量泄漏**

```javascript
// 问题代码：意外创建全局变量
function createLeak() {
    // 忘记声明变量，创建了全局变量
    leakedVariable = new Array(1000000);
}

// 解决方案：使用严格模式和正确声明
'use strict';
function noLeak() {
    const localVariable = new Array(1000000);
    // 函数结束后自动回收
}
```

**闭包内存泄漏**

```javascript
// 问题代码：闭包持有大量数据
function createClosure() {
    const largeData = new Array(1000000).fill('data');
    
    return function() {
        // 即使不使用 largeData，闭包仍然持有引用
        console.log('Hello');
    };
}

// 解决方案：及时清理不需要的引用
function createOptimizedClosure() {
    let largeData = new Array(1000000).fill('data');
    
    const closure = function() {
        console.log('Hello');
    };
    
    // 清理大数据引用
    largeData = null;
    
    return closure;
}
```

**DOM 引用泄漏**

```javascript
// 问题代码：DOM 节点被 JavaScript 对象引用
class ProblematicComponent {
    constructor(element) {
        this.element = element;
        this.data = new Array(100000);
        
        // DOM 事件监听器持有组件引用
        this.element.addEventListener('click', () => {
            this.handleClick();
        });
    }
    
    handleClick() {
        console.log('Clicked');
    }
}

// 解决方案：实现正确的清理机制
class OptimizedComponent {
    constructor(element) {
        this.element = element;
        this.data = new Array(100000);
        
        // 绑定事件处理器，便于后续移除
        this.handleClick = this.handleClick.bind(this);
        this.element.addEventListener('click', this.handleClick);
    }
    
    handleClick() {
        console.log('Clicked');
    }
    
    // 清理方法
    destroy() {
        this.element.removeEventListener('click', this.handleClick);
        this.element = null;
        this.data = null;
    }
}
```



### WeakMap 和 WeakSet 的使用

**使用 WeakMap 避免内存泄漏**

```javascript
// 使用 WeakMap 存储私有数据
const privateData = new WeakMap();

class SecureClass {
    constructor(value) {
        // 使用 WeakMap 存储私有数据
        privateData.set(this, { value, secret: 'hidden' });
    }
    
    getValue() {
        return privateData.get(this).value;
    }
    
    // 对象被垃圾回收时，WeakMap 中的条目会自动清理
}

// 使用 WeakSet 跟踪对象状态
const processedObjects = new WeakSet();

function processObject(obj) {
    if (processedObjects.has(obj)) {
        return; // 已处理过
    }
    
    // 执行处理逻辑
    console.log('Processing object');
    
    // 标记为已处理
    processedObjects.add(obj);
}
```

### 内存泄漏检测工具

**自定义内存监控**

```javascript
class MemoryMonitor {
    constructor() {
        this.measurements = [];
        this.isMonitoring = false;
    }
    
    startMonitoring(interval = 1000) {
        if (this.isMonitoring) return;
        
        this.isMonitoring = true;
        this.monitorInterval = setInterval(() => {
            if (performance.memory) {
                const memory = {
                    timestamp: Date.now(),
                    used: performance.memory.usedJSHeapSize,
                    total: performance.memory.totalJSHeapSize,
                    limit: performance.memory.jsHeapSizeLimit
                };
                
                this.measurements.push(memory);
                this.checkForLeaks(memory);
            }
        }, interval);
    }
    
    stopMonitoring() {
        if (this.monitorInterval) {
            clearInterval(this.monitorInterval);
            this.isMonitoring = false;
        }
    }
    
    checkForLeaks(currentMemory) {
        if (this.measurements.length < 10) return;
        
        const recent = this.measurements.slice(-10);
        const trend = this.calculateTrend(recent);
        
        if (trend > 1024 * 1024) { // 1MB 增长趋势
            console.warn('Potential memory leak detected!', {
                trend: `${(trend / 1024 / 1024).toFixed(2)}MB/measurement`,
                current: `${(currentMemory.used / 1024 / 1024).toFixed(2)}MB`
            });
        }
    }
    
    calculateTrend(measurements) {
        const first = measurements[0].used;
        const last = measurements[measurements.length - 1].used;
        return (last - first) / measurements.length;
    }
    
    getReport() {
        return {
            totalMeasurements: this.measurements.length,
            currentUsage: this.measurements[this.measurements.length - 1],
            trend: this.calculateTrend(this.measurements.slice(-20))
        };
    }
}

// 使用示例
const monitor = new MemoryMonitor();
monitor.startMonitoring(5000); // 每5秒检查一次
```





## JavaScript 代码优化策略与最佳实践

### 算法优化

**时间复杂度优化**

```javascript
// 低效实现：O(n²)
function findDuplicates_slow(arr) {
    const duplicates = [];
    for (let i = 0; i < arr.length; i++) {
        for (let j = i + 1; j < arr.length; j++) {
            if (arr[i] === arr[j] && !duplicates.includes(arr[i])) {
                duplicates.push(arr[i]);
            }
        }
    }
    return duplicates;
}

// 高效实现：O(n)
function findDuplicates_fast(arr) {
    const seen = new Set();
    const duplicates = new Set();
    
    for (const item of arr) {
        if (seen.has(item)) {
            duplicates.add(item);
        } else {
            seen.add(item);
        }
    }
    
    return Array.from(duplicates);
}
```

**数据结构选择优化**

```javascript
// 场景1：频繁查找操作 - 使用 Map 而非 Object
class DataCache {
    constructor() {
        // Map 对于频繁的键查找更高效
        this.cache = new Map();
    }
    
    set(key, value) {
        this.cache.set(key, value);
    }
    
    get(key) {
        return this.cache.get(key);
    }
    
    has(key) {
        return this.cache.has(key);
    }
}

// 场景2：大量数值计算 - 使用 TypedArray
function processLargeNumbers(count) {
    // 使用 Float64Array 而非普通数组
    const data = new Float64Array(count);
    
    for (let i = 0; i < count; i++) {
        data[i] = Math.random() * 1000;
    }
    
    // 数值计算更高效
    let sum = 0;
    for (let i = 0; i < data.length; i++) {
        sum += data[i];
    }
    
    return sum / data.length;
}
```

### 循环优化策略

**循环展开与批处理**

```javascript
// 基础循环
function processArray_basic(arr) {
    for (let i = 0; i < arr.length; i++) {
        arr[i] = arr[i] * 2 + 1;
    }
}

// 循环展开优化
function processArray_unrolled(arr) {
    let i = 0;
    const len = arr.length;
    
    // 每次处理4个元素
    for (; i < len - 3; i += 4) {
        arr[i] = arr[i] * 2 + 1;
        arr[i + 1] = arr[i + 1] * 2 + 1;
        arr[i + 2] = arr[i + 2] * 2 + 1;
        arr[i + 3] = arr[i + 3] * 2 + 1;
    }
    
    // 处理剩余元素
    for (; i < len; i++) {
        arr[i] = arr[i] * 2 + 1;
    }
}

// 缓存数组长度
function processArray_cached(arr) {
    // 缓存长度避免重复访问 .length 属性
    for (let i = 0, len = arr.length; i < len; i++) {
        arr[i] = arr[i] * 2 + 1;
    }
}
```

### 函数优化技巧

**函数记忆化**

```javascript
// 通用记忆化装饰器
function memoize(fn, keyGenerator) {
    const cache = new Map();
    
    return function(...args) {
        const key = keyGenerator ? keyGenerator(...args) : JSON.stringify(args);
        
        if (cache.has(key)) {
            return cache.get(key);
        }
        
        const result = fn.apply(this, args);
        cache.set(key, result);
        return result;
    };
}

// 使用示例：斐波那契数列
const fibonacci = memoize(function(n) {
    if (n <= 1) return n;
    return fibonacci(n - 1) + fibonacci(n - 2);
});

// 复杂计算的记忆化
const expensiveCalculation = memoize(
    function(a, b, c) {
        console.log('Performing expensive calculation...');
        return Math.pow(a, b) + Math.sqrt(c);
    },
    (a, b, c) => `${a}-${b}-${c}` // 自定义键生成器
);
```

**函数防抖和节流**

```javascript
// 防抖实现
function debounce(func, wait, immediate = false) {
    let timeout;
    
    return function executedFunction(...args) {
        const later = () => {
            timeout = null;
            if (!immediate) func.apply(this, args);
        };
        
        const callNow = immediate && !timeout;
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
        
        if (callNow) func.apply(this, args);
    };
}

// 节流实现
function throttle(func, limit) {
    let inThrottle;
    
    return function(...args) {
        if (!inThrottle) {
            func.apply(this, args);
            inThrottle = true;
            setTimeout(() => inThrottle = false, limit);
        }
    };
}

// 使用示例
const debouncedSearch = debounce(function(query) {
    console.log('Searching for:', query);
}, 300);

const throttledScroll = throttle(function() {
    console.log('Scroll event handled');
}, 100);
```





## 大规模数据处理的优化技巧与设计模式

### 数据分页与虚拟化

**虚拟滚动实现**

```javascript
class VirtualScrollList {
    constructor(container, itemHeight, totalItems, renderItem) {
        this.container = container;
        this.itemHeight = itemHeight;
        this.totalItems = totalItems;
        this.renderItem = renderItem;
        
        this.visibleItems = Math.ceil(container.clientHeight / itemHeight) + 2;
        this.scrollTop = 0;
        
        this.setupContainer();
        this.bindEvents();
        this.render();
    }
    
    setupContainer() {
        this.container.style.position = 'relative';
        this.container.style.overflow = 'auto';
        
        // 创建占位容器
        this.spacer = document.createElement('div');
        this.spacer.style.height = `${this.totalItems * this.itemHeight}px`;
        this.container.appendChild(this.spacer);
        
        // 创建可见项容器
        this.viewport = document.createElement('div');
        this.viewport.style.position = 'absolute';
        this.viewport.style.top = '0';
        this.viewport.style.width = '100%';
        this.container.appendChild(this.viewport);
    }
    
    bindEvents() {
        this.container.addEventListener('scroll', () => {
            this.scrollTop = this.container.scrollTop;
            this.render();
        });
    }
    
    render() {
        const startIndex = Math.floor(this.scrollTop / this.itemHeight);
        const endIndex = Math.min(
            startIndex + this.visibleItems,
            this.totalItems
        );
        
        // 清空当前视图
        this.viewport.innerHTML = '';
        this.viewport.style.transform = `translateY(${startIndex * this.itemHeight}px)`;
        
        // 渲染可见项
        for (let i = startIndex; i < endIndex; i++) {
            const item = this.renderItem(i);
            item.style.height = `${this.itemHeight}px`;
            this.viewport.appendChild(item);
        }
    }
}

// 使用示例
const container = document.getElementById('scroll-container');
const virtualList = new VirtualScrollList(
    container,
    50, // 每项高度
    100000, // 总项数
    (index) => {
        const div = document.createElement('div');
        div.textContent = `Item ${index}`;
        div.style.borderBottom = '1px solid #ccc';
        return div;
    }
);
```

### 数据流处理

**Stream 模式实现**

```javascript
class DataStream {
    constructor() {
        this.processors = [];
    }
    
    // 添加处理器
    pipe(processor) {
        this.processors.push(processor);
        return this;
    }
    
    // 处理数据流
    async process(data) {
        let result = data;
        
        for (const processor of this.processors) {
            if (Array.isArray(result)) {
                result = await this.processChunk(result, processor);
            } else {
                result = await processor(result);
            }
        }
        
        return result;
    }
    
    // 分块处理大数组
    async processChunk(data, processor, chunkSize = 1000) {
        const results = [];
        
        for (let i = 0; i < data.length; i += chunkSize) {
            const chunk = data.slice(i, i + chunkSize);
            const processedChunk = await Promise.all(
                chunk.map(item => processor(item))
            );
            results.push(...processedChunk);
            
            // 让出控制权，避免阻塞UI
            await new Promise(resolve => setTimeout(resolve, 0));
        }
        
        return results;
    }
}

// 使用示例
const dataStream = new DataStream()
    .pipe(item => ({ ...item, processed: true }))
    .pipe(async item => {
        // 模拟异步处理
        await new Promise(resolve => setTimeout(resolve, 1));
        return { ...item, timestamp: Date.now() };
    })
    .pipe(item => {
        // 过滤逻辑
        return item.value > 0 ? item : null;
    });

// 处理大量数据
const largeDataset = Array.from({ length: 100000 }, (_, i) => ({
    id: i,
    value: Math.random() - 0.5
}));

dataStream.process(largeDataset).then(results => {
    console.log('Processing completed:', results.length);
});
```

### Web Worker 并行处理

**主线程代码**

```javascript
class ParallelProcessor {
    constructor(workerScript, workerCount = navigator.hardwareConcurrency || 4) {
        this.workerCount = workerCount;
        this.workers = [];
        this.taskQueue = [];
        this.activeWorkers = 0;
        
        this.initWorkers(workerScript);
    }
    
    initWorkers(workerScript) {
        for (let i = 0; i < this.workerCount; i++) {
            const worker = new Worker(workerScript);
            worker.onmessage = (e) => this.handleWorkerMessage(worker, e);
            worker.onerror = (e) => this.handleWorkerError(worker, e);
            this.workers.push({
                worker,
                busy: false,
                resolve: null,
                reject: null
            });
        }
    }
    
    async processData(data, chunkSize = 1000) {
        const chunks = this.chunkArray(data, chunkSize);
        const promises = chunks.map(chunk => this.processChunk(chunk));
        
        const results = await Promise.all(promises);
        return results.flat();
    }
    
    processChunk(chunk) {
        return new Promise((resolve, reject) => {
            const availableWorker = this.workers.find(w => !w.busy);
            
            if (availableWorker) {
                this.assignTask(availableWorker, chunk, resolve, reject);
            } else {
                this.taskQueue.push({ chunk, resolve, reject });
            }
        });
    }
    
    assignTask(workerInfo, chunk, resolve, reject) {
        workerInfo.busy = true;
        workerInfo.resolve = resolve;
        workerInfo.reject = reject;
        workerInfo.worker.postMessage({ data: chunk });
        this.activeWorkers++;
    }
    
    handleWorkerMessage(worker, event) {
        const workerInfo = this.workers.find(w => w.worker === worker);
        
        if (workerInfo) {
            workerInfo.busy = false;
            workerInfo.resolve(event.data.result);
            this.activeWorkers--;
            
            // 处理队列中的下一个任务
            if (this.taskQueue.length > 0) {
                const { chunk, resolve, reject } = this.taskQueue.shift();
                this.assignTask(workerInfo, chunk, resolve, reject);
            }
        }
    }
    
    handleWorkerError(worker, error) {
        const workerInfo = this.workers.find(w => w.worker === worker);
        if (workerInfo && workerInfo.reject) {
            workerInfo.reject(error);
            workerInfo.busy = false;
            this.activeWorkers--;
        }
    }
    
    chunkArray(array, chunkSize) {
        const chunks = [];
        for (let i = 0; i < array.length; i += chunkSize) {
            chunks.push(array.slice(i, i + chunkSize));
        }
        return chunks;
    }
    
    terminate() {
        this.workers.forEach(({ worker }) => worker.terminate());
        this.workers = [];
    }
}
```

**Worker 脚本 (data-processor.js)**

```javascript
// data-processor.js
self.onmessage = function(e) {
    const { data } = e.data;
    
    try {
        // 执行CPU密集型任务
        const result = processDataChunk(data);
        
        self.postMessage({
            success: true,
            result: result
        });
    } catch (error) {
        self.postMessage({
            success: false,
            error: error.message
        });
    }
};

function processDataChunk(data) {
    return data.map(item => {
        // 复杂的数据处理逻辑
        return {
            ...item,
            processed: true,
            square: item.value * item.value,
            sqrt: Math.sqrt(Math.abs(item.value)),
            timestamp: Date.now()
        };
    });
}
```



## DOM 操作性能优化与重绘回流控制

### 批量 DOM 操作

**DocumentFragment 优化**

```javascript
// 低效方式：逐个添加DOM元素
function addItems_inefficient(container, items) {
    items.forEach(item => {
        const div = document.createElement('div');
        div.textContent = item.text;
        div.className = item.className;
        container.appendChild(div); // 每次都触发重绘
    });
}

// 高效方式：使用DocumentFragment
function addItems_efficient(container, items) {
    const fragment = document.createDocumentFragment();
    
    items.forEach(item => {
        const div = document.createElement('div');
        div.textContent = item.text;
        div.className = item.className;
        fragment.appendChild(div); // 在内存中操作
    });
    
    container.appendChild(fragment); // 一次性添加，只触发一次重绘
}

// 使用innerHTML进行批量操作
function addItems_innerHTML(container, items) {
    const html = items.map(item => 
        `<div class="${item.className}">${item.text}</div>`
    ).join('');
    
    container.innerHTML = html; // 一次性设置
}
```

### 重绘回流优化

**CSS 类切换优化**

```javascript
// 避免逐个修改样式属性
function animateElement_bad(element) {
    element.style.width = '200px';     // 回流
    element.style.height = '200px';    // 回流
    element.style.background = 'red';  // 重绘
    element.style.opacity = '0.5';     // 重绘
}

// 使用CSS类一次性修改
function animateElement_good(element) {
    element.classList.add('animated-state'); // 一次回流
}

/* CSS */
.animated-state {
    width: 200px;
    height: 200px;
    background: red;
    opacity: 0.5;
    transition: all 0.3s ease;
}
```

**读写分离优化**

```javascript
// 问题代码：读写混合导致强制回流
function badLayout(elements) {
    elements.forEach(el => {
        el.style.height = el.offsetHeight + 10 + 'px'; // 读取后立即写入
    });
}

// 优化：读写分离
function goodLayout(elements) {
    // 批量读取
    const heights = elements.map(el => el.offsetHeight);
    
    // 批量写入
    elements.forEach((el, index) => {
        el.style.height = heights[index] + 10 + 'px';
    });
}
```

### 虚拟DOM模式实现

**轻量级虚拟DOM**

```javascript
class VirtualDOM {
    constructor() {
        this.vdom = null;
        this.container = null;
    }
    
    createElement(tag, props = {}, children = []) {
        return {
            tag,
            props,
            children: Array.isArray(children) ? children : [children]
        };
    }
    
    render(vdom, container) {
        if (!this.vdom) {
            // 首次渲染
            this.vdom = vdom;
            this.container = container;
            container.appendChild(this.createRealDOM(vdom));
        } else {
            // 差异更新
            this.updateDOM(container.firstChild, this.vdom, vdom);
            this.vdom = vdom;
        }
    }
    
    createRealDOM(vdom) {
        if (typeof vdom === 'string' || typeof vdom === 'number') {
            return document.createTextNode(vdom);
        }
        
        const element = document.createElement(vdom.tag);
        
        // 设置属性
        Object.keys(vdom.props).forEach(key => {
            if (key.startsWith('on')) {
                const eventType = key.slice(2).toLowerCase();
                element.addEventListener(eventType, vdom.props[key]);
            } else {
                element.setAttribute(key, vdom.props[key]);
            }
        });
        
     vdom.children.forEach(child => {
            element.appendChild(this.createRealDOM(child));
        });
        
        return element;
    }
    
    updateDOM(realDOM, oldVdom, newVdom) {
        // 节点类型完全不同，直接替换
        if (this.isDifferentType(oldVdom, newVdom)) {
            realDOM.parentNode.replaceChild(
                this.createRealDOM(newVdom),
                realDOM
            );
            return;
        }
        
        // 文本节点更新
        if (typeof newVdom === 'string' || typeof newVdom === 'number') {
            if (oldVdom !== newVdom) {
                realDOM.textContent = newVdom;
            }
            return;
        }
        
        // 更新属性
        this.updateAttributes(realDOM, oldVdom.props, newVdom.props);
        
        // 更新子元素
        this.updateChildren(realDOM, oldVdom.children, newVdom.children);
    }
    
    updateAttributes(element, oldProps, newProps) {
        // 删除旧属性
        Object.keys(oldProps).forEach(key => {
            if (!(key in newProps)) {
                if (key.startsWith('on')) {
                    const eventType = key.slice(2).toLowerCase();
                    element.removeEventListener(eventType, oldProps[key]);
                } else {
                    element.removeAttribute(key);
                }
            }
        });
        
        // 更新新属性
        Object.keys(newProps).forEach(key => {
            if (oldProps[key] !== newProps[key]) {
                if (key.startsWith('on')) {
                    const eventType = key.slice(2).toLowerCase();
                    if (oldProps[key]) {
                        element.removeEventListener(eventType, oldProps[key]);
                    }
                    element.addEventListener(eventType, newProps[key]);
                } else {
                    element.setAttribute(key, newProps[key]);
                }
            }
        });
    }
    
    updateChildren(element, oldChildren, newChildren) {
        const maxLength = Math.max(oldChildren.length, newChildren.length);
        
        for (let i = 0; i < maxLength; i++) {
            const oldChild = oldChildren[i];
            const newChild = newChildren[i];
            const childElement = element.childNodes[i];
            
            if (!newChild) {
                // 删除多余的子元素
                element.removeChild(childElement);
            } else if (!oldChild) {
                // 添加新的子元素
                element.appendChild(this.createRealDOM(newChild));
            } else if (childElement) {
                // 更新现有子元素
                this.updateDOM(childElement, oldChild, newChild);
            }
        }
    }
    
    isDifferentType(oldVdom, newVdom) {
        return typeof oldVdom !== typeof newVdom ||
               (typeof oldVdom === 'object' && oldVdom.tag !== newVdom.tag);
    }
}

// 使用示例
const vdom = new VirtualDOM();
const container = document.getElementById('app');

function TodoApp(todos) {
    return vdom.createElement('div', { class: 'todo-app' }, [
        vdom.createElement('h1', {}, 'Todo List'),
        vdom.createElement('ul', {}, 
            todos.map(todo => 
                vdom.createElement('li', 
                    { 
                        key: todo.id,
                        class: todo.completed ? 'completed' : ''
                    }, 
                    [
                        vdom.createElement('span', {}, todo.text),
                        vdom.createElement('button', {
                            onclick: () => toggleTodo(todo.id)
                        }, 'Toggle')
                    ]
                )
            )
        )
    ]);
}
```





## 使用 Performance API 进行精确的性能度量

### 基础性能测量

**Performance Timeline API**

```javascript
class PerformanceAnalyzer {
    constructor() {
        this.measurements = new Map();
        this.observers = new Map();
    }
    
    // 标记性能测量点
    mark(name) {
        performance.mark(name);
        return this;
    }
    
    // 测量两个标记之间的时间
    measure(name, startMark, endMark) {
        performance.measure(name, startMark, endMark);
        
        const measures = performance.getEntriesByName(name, 'measure');
        const latestMeasure = measures[measures.length - 1];
        
        this.measurements.set(name, {
            duration: latestMeasure.duration,
            startTime: latestMeasure.startTime,
            timestamp: Date.now()
        });
        
        return latestMeasure.duration;
    }
    
    // 创建性能观察器
    observe(entryTypes, callback) {
        const observer = new PerformanceObserver((list) => {
            const entries = list.getEntries();
            callback(entries);
        });
        
        observer.observe({ entryTypes });
        
        const observerId = `observer_${Date.now()}`;
        this.observers.set(observerId, observer);
        
        return observerId;
    }
    
    // 测量函数执行时间
    async measureFunction(fn, name) {
        const startMark = `${name}_start`;
        const endMark = `${name}_end`;
        
        this.mark(startMark);
        
        let result;
        try {
            result = await fn();
        } catch (error) {
            this.mark(endMark);
            this.measure(name, startMark, endMark);
            throw error;
        }
        
        this.mark(endMark);
        const duration = this.measure(name, startMark, endMark);
        
        return { result, duration };
    }
    
    // 获取导航性能信息
    getNavigationTiming() {
        const navigation = performance.getEntriesByType('navigation')[0];
        
        return {
            dnsLookup: navigation.domainLookupEnd - navigation.domainLookupStart,
            tcpConnect: navigation.connectEnd - navigation.connectStart,
            tlsHandshake: navigation.secureConnectionStart > 0 ? 
                         navigation.connectEnd - navigation.secureConnectionStart : 0,
            request: navigation.responseStart - navigation.requestStart,
            response: navigation.responseEnd - navigation.responseStart,
            domParsing: navigation.domComplete - navigation.domLoading,
            domReady: navigation.domContentLoadedEventEnd - navigation.navigationStart,
            pageLoad: navigation.loadEventEnd - navigation.navigationStart
        };
    }
    
    // 获取资源加载性能
    getResourceTiming() {
        const resources = performance.getEntriesByType('resource');
        
        return resources.map(resource => ({
            name: resource.name,
            duration: resource.duration,
            size: resource.transferSize,
            type: this.getResourceType(resource.name),
            cached: resource.transferSize === 0 && resource.decodedBodySize > 0
        }));
    }
    
    getResourceType(url) {
        if (url.match(/\.(js)$/)) return 'script';
        if (url.match(/\.(css)$/)) return 'stylesheet';
        if (url.match(/\.(png|jpg|jpeg|gif|webp|svg)$/)) return 'image';
        if (url.match(/\.(woff|woff2|ttf|eot)$/)) return 'font';
        return 'other';
    }
    
    // 生成性能报告
    generateReport() {
        const navigation = this.getNavigationTiming();
        const resources = this.getResourceTiming();
        const customMeasurements = Array.from(this.measurements.entries());
        
        return {
            timestamp: Date.now(),
            navigation,
            resources: {
                total: resources.length,
                totalSize: resources.reduce((sum, r) => sum + r.size, 0),
                cached: resources.filter(r => r.cached).length,
                byType: this.groupResourcesByType(resources)
            },
            customMeasurements: Object.fromEntries(customMeasurements)
        };
    }
    
    groupResourcesByType(resources) {
        return resources.reduce((groups, resource) => {
            const type = resource.type;
            if (!groups[type]) {
                groups[type] = { count: 0, totalSize: 0 };
            }
            groups[type].count++;
            groups[type].totalSize += resource.size;
            return groups;
        }, {});
    }
    
    // 清理观察器
    cleanup() {
        this.observers.forEach(observer => observer.disconnect());
        this.observers.clear();
        performance.clearMarks();
        performance.clearMeasures();
    }
}

// 使用示例
const analyzer = new PerformanceAnalyzer();

// 测量关键操作
async function criticalOperation() {
    const data = await fetchData();
    const processed = processData(data);
    return processed;
}

analyzer.measureFunction(criticalOperation, 'critical-operation')
    .then(({ result, duration }) => {
        console.log(`Operation completed in ${duration.toFixed(2)}ms`);
    });

// 监控长任务
analyzer.observe(['longtask'], (entries) => {
    entries.forEach(entry => {
        console.warn(`Long task detected: ${entry.duration.toFixed(2)}ms`);
    });
});
```

### 用户体验指标监控

**Core Web Vitals 监控**

```javascript
class WebVitalsMonitor {
    constructor() {
        this.metrics = {};
        this.callbacks = [];
    }
    
    // 监控 Largest Contentful Paint (LCP)
    measureLCP() {
        return new Promise((resolve) => {
            const observer = new PerformanceObserver((list) => {
                const entries = list.getEntries();
                const lastEntry = entries[entries.length - 1];
                
                this.metrics.lcp = {
                    value: lastEntry.startTime,
                    element: lastEntry.element,
                    timestamp: Date.now()
                };
                
                this.notifyCallbacks('lcp', this.metrics.lcp);
                resolve(this.metrics.lcp);
            });
            
            observer.observe({ entryTypes: ['largest-contentful-paint'] });
            
            // 在页面隐藏时停止观察
            document.addEventListener('visibilitychange', () => {
                if (document.visibilityState === 'hidden') {
                    observer.disconnect();
                }
            });
        });
    }
    
    // 监控 First Input Delay (FID)
    measureFID() {
        return new Promise((resolve) => {
            const observer = new PerformanceObserver((list) => {
                const entries = list.getEntries();
                entries.forEach(entry => {
                    this.metrics.fid = {
                        value: entry.processingStart - entry.startTime,
                        timestamp: Date.now()
                    };
                    
                    this.notifyCallbacks('fid', this.metrics.fid);
                    resolve(this.metrics.fid);
                });
                
                observer.disconnect();
            });
            
            observer.observe({ entryTypes: ['first-input'] });
        });
    }
    
    // 监控 Cumulative Layout Shift (CLS)
    measureCLS() {
        let clsValue = 0;
        let sessionValue = 0;
        let sessionEntries = [];
        
        const observer = new PerformanceObserver((list) => {
            const entries = list.getEntries();
            
            entries.forEach(entry => {
                // 只考虑非用户输入导致的布局偏移
                if (!entry.hadRecentInput) {
                    const firstSessionEntry = sessionEntries[0];
                    const lastSessionEntry = sessionEntries[sessionEntries.length - 1];
                    
                    // 如果entry与上一个entry相隔超过1秒，或者与第一个entry相隔超过5秒，
                    // 则开始新的会话
                    if (sessionValue &&
                        (entry.startTime - lastSessionEntry.startTime > 1000 ||
                         entry.startTime - firstSessionEntry.startTime > 5000)) {
                        
                        // 保存当前会话的最大CLS值
                        clsValue = Math.max(clsValue, sessionValue);
                        
                        // 开始新的会话
                        sessionValue = entry.value;
                        sessionEntries = [entry];
                    } else {
                        sessionValue += entry.value;
                        sessionEntries.push(entry);
                    }
                }
            });
            
            // 更新最终CLS值
            clsValue = Math.max(clsValue, sessionValue);
            
            this.metrics.cls = {
                value: clsValue,
                timestamp: Date.now()
            };
            
            this.notifyCallbacks('cls', this.metrics.cls);
        });
        
        observer.observe({ entryTypes: ['layout-shift'] });
        
        // 在页面隐藏时停止观察
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'hidden') {
                observer.disconnect();
            }
        });
    }
    
    // 添加回调函数
    onMetric(callback) {
        this.callbacks.push(callback);
    }
    
    // 通知所有回调函数
    notifyCallbacks(metricName, metric) {
        this.callbacks.forEach(callback => {
            try {
                callback(metricName, metric);
            } catch (error) {
                console.error('Error in Web Vitals callback:', error);
            }
        });
    }
    
    // 获取所有指标
    getAllMetrics() {
        return { ...this.metrics };
    }
}

// 使用示例
const vitalsMonitor = new WebVitalsMonitor();

vitalsMonitor.onMetric((metricName, metric) => {
    console.log(`${metricName.toUpperCase()}: ${metric.value}`);
    
    // 发送到分析服务
    sendToAnalytics({
        metric: metricName,
        value: metric.value,
        timestamp: metric.timestamp
    });
});

// 开始监控
vitalsMonitor.measureLCP();
vitalsMonitor.measureFID();
vitalsMonitor.measureCLS();
```





## 高性能 JavaScript 动画实现技术

### requestAnimationFrame 优化

**高性能动画循环**

```javascript
class AnimationManager {
    constructor() {
        this.animations = new Set();
        this.isRunning = false;
        this.lastTime = 0;
        this.deltaTime = 0;
    }
    
    // 添加动画
    add(animation) {
        this.animations.add(animation);
        if (!this.isRunning) {
            this.start();
        }
    }
    
    // 移除动画
    remove(animation) {
        this.animations.delete(animation);
        if (this.animations.size === 0) {
            this.stop();
        }
    }
    
    // 开始动画循环
    start() {
        if (this.isRunning) return;
        
        this.isRunning = true;
        this.lastTime = performance.now();
        this.tick();
    }
    
    // 停止动画循环
    stop() {
        this.isRunning = false;
        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
        }
    }
    
    // 动画循环
    tick() {
        if (!this.isRunning) return;
        
        const currentTime = performance.now();
        this.deltaTime = currentTime - this.lastTime;
        this.lastTime = currentTime;
        
        // 执行所有动画
        const animationsToRemove = [];
        this.animations.forEach(animation => {
            const shouldContinue = animation.update(this.deltaTime, currentTime);
            if (!shouldContinue) {
                animationsToRemove.push(animation);
            }
        });
        
        // 移除已完成的动画
        animationsToRemove.forEach(animation => {
            this.animations.delete(animation);
        });
        
        // 继续下一帧
        if (this.animations.size > 0) {
            this.animationId = requestAnimationFrame(() => this.tick());
        } else {
            this.isRunning = false;
        }
    }
}

// 基础动画类
class Animation {
    constructor(element, properties, duration, easing = 'easeInOut') {
        this.element = element;
        this.startValues = {};
        this.endValues = properties;
        this.duration = duration;
        this.easing = this.getEasingFunction(easing);
        this.elapsed = 0;
        this.isComplete = false;
        
        this.initializeStartValues();
    }
    
    initializeStartValues() {
        Object.keys(this.endValues).forEach(prop => {
            this.startValues[prop] = this.getCurrentValue(prop);
        });
    }
    
    getCurrentValue(property) {
        const computed = getComputedStyle(this.element);
        const value = computed.getPropertyValue(property);
        return parseFloat(value) || 0;
    }
    
    update(deltaTime) {
        if (this.isComplete) return false;
        
        this.elapsed += deltaTime;
        const progress = Math.min(this.elapsed / this.duration, 1);
        const easedProgress = this.easing(progress);
        
        // 更新所有属性
        Object.keys(this.endValues).forEach(prop => {
            const start = this.startValues[prop];
            const end = this.endValues[prop];
            const current = start + (end - start) * easedProgress;
            
            this.setProperty(prop, current);
        });
        
        if (progress >= 1) {
            this.isComplete = true;
            if (this.onComplete) {
                this.onComplete();
            }
        }
        
        return !this.isComplete;
    }
    
    setProperty(property, value) {
        if (property === 'opacity') {
            this.element.style.opacity = value;
        } else if (property.includes('translate')) {
            this.updateTransform(property, value);
        } else {
            this.element.style[property] = value + 'px';
        }
    }
    
    updateTransform(property, value) {
        const transform = this.element.style.transform || '';
        const regex = new RegExp(`${property}\\([^)]*\\)`, 'g');
        const newTransform = property === 'translateX' || property === 'translateY' ?
            `${property}(${value}px)` : `${property}(${value})`;
        
        if (regex.test(transform)) {
            this.element.style.transform = transform.replace(regex, newTransform);
        } else {
            this.element.style.transform = transform + ' ' + newTransform;
        }
    }
    
    getEasingFunction(name) {
        const easings = {
            linear: t => t,
            easeIn: t => t * t,
            easeOut: t => t * (2 - t),
            easeInOut: t => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t,
            easeInCubic: t => t * t * t,
            easeOutCubic: t => (--t) * t * t + 1,
            easeInOutCubic: t => t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1
        };
        
        return easings[name] || easings.easeInOut;
    }
}

// 使用示例
const animationManager = new AnimationManager();

function animateElement(element, properties, duration, easing) {
    const animation = new Animation(element, properties, duration, easing);
    animationManager.add(animation);
    return animation;
}

// 创建复杂动画序列
function createComplexAnimation(element) {
    const timeline = [
        () => animateElement(element, { translateX: 100 }, 500, 'easeOut'),
        () => animateElement(element, { translateY: 50, opacity: 0.5 }, 300, 'easeIn'),
        () => animateElement(element, { scale: 1.2 }, 200, 'easeInOut'),
        () => animateElement(element, { translateX: 0, translateY: 0, opacity: 1, scale: 1 }, 400, 'easeOut')
    ];
    
    return playSequence(timeline);
}

function playSequence(timeline) {
    return timeline.reduce((promise, animationFn) => {
        return promise.then(() => new Promise(resolve => {
            const animation = animationFn();
            animation.onComplete = resolve;
        }));
    }, Promise.resolve());
}
```

### CSS Transform 和 GPU 加速

**GPU 加速动画实现**

```javascript
class GPUAcceleratedAnimation {
    constructor(element) {
        this.element = element;
        this.transforms = {
            translateX: 0,
            translateY: 0,
            translateZ: 0,
            rotateX: 0,
            rotateY: 0,
            rotateZ: 0,
            scaleX: 1,
            scaleY: 1,
            scaleZ: 1
        };
        
        // 启用硬件加速
        this.element.style.willChange = 'transform, opacity';
        this.element.style.backfaceVisibility = 'hidden';
        this.element.style.perspective = '1000px';
        
        this.updateTransform();
    }
    
    // 设置变换属性
    setTransform(property, value) {
        if (property in this.transforms) {
            this.transforms[property] = value;
            this.updateTransform();
        }
    }
    
    // 批量设置变换属性
    setTransforms(transforms) {
        Object.assign(this.transforms, transforms);
        this.updateTransform();
    }
    
    // 更新元素的transform属性
    updateTransform() {
        const { translateX, translateY, translateZ, rotateX, rotateY, rotateZ, scaleX, scaleY, scaleZ } = this.transforms;
        
        const transform = [
            `translate3d(${translateX}px, ${translateY}px, ${translateZ}px)`,
            `rotateX(${rotateX}deg)`,
            `rotateY(${rotateY}deg)`,
            `rotateZ(${rotateZ}deg)`,
            `scale3d(${scaleX}, ${scaleY}, ${scaleZ})`
        ].join(' ');
        
        this.element.style.transform = transform;
    }
    
    // 动画到目标值
    animateTo(targetTransforms, duration = 1000, easing = 'easeInOut') {
        return new Promise(resolve => {
            const startTransforms = { ...this.transforms };
            const startTime = performance.now();
            
            const animate = (currentTime) => {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const easedProgress = this.easing(progress, easing);
                
                // 插值计算当前变换值
                Object.keys(targetTransforms).forEach(prop => {
                    const start = startTransforms[prop];
                    const end = targetTransforms[prop];
                    this.transforms[prop] = start + (end - start) * easedProgress;
                });
                
                this.updateTransform();
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    resolve();
                }
            };
            
            requestAnimationFrame(animate);
        });
    }
    
    easing(t, type) {
        const easings = {
            linear: t => t,
            easeIn: t => t * t,
            easeOut: t => t * (2 - t),
            easeInOut: t => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t
        };
        return easings[type] || easings.easeInOut;
    }
    
    // 清理资源
    destroy() {
        this.element.style.willChange = 'auto';
        this.element.style.backfaceVisibility = '';
        this.element.style.perspective = '';
        this.element.style.transform = '';
    }
}

// 使用示例
const element = document.getElementById('animated-element');
const gpuAnimation = new GPUAcceleratedAnimation(element);

// 创建复杂3D动画
async function create3DAnimation() {
    await gpuAnimation.animateTo({
        translateX: 100,
        rotateY: 180,
        scaleX: 1.2
    }, 800, 'easeOut');
    
    await gpuAnimation.animateTo({
        translateY: -50,
        rotateX: 45,
        scaleY: 0.8
    }, 600, 'easeInOut');
    
    await gpuAnimation.animateTo({
        translateX: 0,
        translateY: 0,
        rotateX: 0,
        rotateY: 0,
        scaleX: 1,
        scaleY: 1
    }, 1000, 'easeOut');
}
```

### 基于Web Workers的动画计算

**离线动画计算**

```javascript
// 主线程代码
class OffloadedAnimation {
    constructor() {
        this.worker = new Worker('animation-worker.js');
        this.animations = new Map();
        this.animationId = 0;
        
        this.worker.onmessage = (e) => {
            this.handleWorkerMessage(e);
        };
    }
    
    // 创建动画
    createAnimation(element, keyframes, options) {
        const id = ++this.animationId;
        
        const animation = {
            id,
            element,
            keyframes,
            options,
            isRunning: false
        };
        
        this.animations.set(id, animation);
        
        // 发送到Worker进行计算
        this.worker.postMessage({
            type: 'create',
            id,
            keyframes,
            options
        });
        
        return {
            play: () => this.playAnimation(id),
            pause: () => this.pauseAnimation(id),
            stop: () => this.stopAnimation(id)
        };
    }
    
    playAnimation(id) {
        const animation = this.animations.get(id);
        if (animation && !animation.isRunning) {
            animation.isRunning = true;
            this.worker.postMessage({
                type: 'play',
                id
            });
        }
    }
    
    pauseAnimation(id) {
        const animation = this.animations.get(id);
        if (animation && animation.isRunning) {
            animation.isRunning = false;
            this.worker.postMessage({
                type: 'pause',
                id
            });
        }
    }
    
    stopAnimation(id) {
        const animation = this.animations.get(id);
        if (animation) {
            animation.isRunning = false;
            this.worker.postMessage({
                type: 'stop',
                id
            });
        }
    }
    
    handleWorkerMessage(e) {
        const { type, id, frame } = e.data;
        
        if (type === 'frame') {
            const animation = this.animations.get(id);
            if (animation) {
                this.applyFrame(animation.element, frame);
            }
        } else if (type === 'complete') {
            const animation = this.animations.get(id);
            if (animation) {
                animation.isRunning = false;
            }
        }
    }
    
    applyFrame(element, frame) {
        Object.keys(frame).forEach(property => {
            if (property === 'transform') {
                element.style.transform = frame[property];
            } else {
                element.style[property] = frame[property];
            }
        });
    }
}

// Worker代码 (animation-worker.js)
class AnimationCalculator {
    constructor() {
        this.animations = new Map();
        this.isRunning = false;
        this.lastTime = 0;
    }
    
    createAnimation(id, keyframes, options) {
        const animation = {
            id,
            keyframes,
            duration: options.duration || 1000,
            easing: options.easing || 'linear',
            startTime: 0,
            elapsed: 0,
            isPlaying: false
        };
        
        this.animations.set(id, animation);
    }
    
    playAnimation(id) {
        const animation = this.animations.get(id);
        if (animation) {
            animation.isPlaying = true;
            animation.startTime = performance.now();
            this.startLoop();
        }
    }
    
    pauseAnimation(id) {
        const animation = this.animations.get(id);
        if (animation) {
            animation.isPlaying = false;
        }
    }
    
    stopAnimation(id) {
        const animation = this.animations.get(id);
        if (animation) {
            animation.isPlaying = false;
            animation.elapsed = 0;
        }
    }
    
    startLoop() {
        if (this.isRunning) return;
        
        this.isRunning = true;
        this.lastTime = performance.now();
        this.loop();
    }
    
    loop() {
        const currentTime = performance.now();
        const deltaTime = currentTime - this.lastTime;
        this.lastTime = currentTime;
        
        let hasActiveAnimations = false;
        
        this.animations.forEach(animation => {
            if (animation.isPlaying) {
                hasActiveAnimations = true;
                this.updateAnimation(animation, deltaTime, currentTime);
            }
        });
        
        if (hasActiveAnimations) {
            setTimeout(() => this.loop
```



## JavaScript 编译与解析优化

## JavaScript 的解析与预编译过程

### 1.1 JavaScript 引擎解析流程

JavaScript 引擎（如 V8）的解析过程包含多个阶段：

```
源代码 → 词法分析 → 语法分析 → AST → 字节码 → 优化编译 → 机器码
```

#### 1.1.1 解析阶段详解

**词法分析（Lexical Analysis）**

- 将源代码分解为 Token（标记）
- 识别关键字、标识符、字面量、操作符等
- 过滤空白符和注释

**语法分析（Syntax Analysis）**

- 将 Token 序列转换为抽象语法树（AST）
- 检查语法错误
- 建立代码结构关系

#### 1.1.2 预编译优化

```javascript
// 预编译阶段的变量提升示例
console.log(hoistedVar); // undefined，而不是报错
var hoistedVar = 'I am hoisted';

// 函数声明提升
console.log(hoistedFunction()); // "Hoisted!"
function hoistedFunction() {
    return "Hoisted!";
}

// 预编译阶段的处理过程：
// 1. 创建执行上下文
// 2. 创建变量对象
// 3. 建立作用域链
// 4. 确定 this 指向
```

### 1.2 V8 引擎的多层编译

V8 使用多层编译策略：

```javascript
// Ignition 解释器处理
function simpleFunction(a, b) {
    return a + b;
}

// TurboFan 优化编译器处理热点代码
function hotFunction(x) {
    let sum = 0;
    for (let i = 0; i < 1000000; i++) {
        sum += x * i;
    }
    return sum;
}

// 调用多次后会被 TurboFan 优化
for (let i = 0; i < 10000; i++) {
    hotFunction(2);
}
```



## AST 在 JavaScript 引擎中的应用

### 2.1 AST 结构与作用

抽象语法树是代码的树形表示，每个节点代表代码中的一个结构：

```javascript
// 原始代码
const add = (a, b) => a + b;

// 对应的 AST 结构（简化版）
{
  "type": "VariableDeclaration",
  "declarations": [{
    "type": "VariableDeclarator",
    "id": { "type": "Identifier", "name": "add" },
    "init": {
      "type": "ArrowFunctionExpression",
      "params": [
        { "type": "Identifier", "name": "a" },
        { "type": "Identifier", "name": "b" }
      ],
      "body": {
        "type": "BinaryExpression",
        "operator": "+",
        "left": { "type": "Identifier", "name": "a" },
        "right": { "type": "Identifier", "name": "b" }
      }
    }
  }]
}
```

### 2.2 AST 在优化中的应用

```javascript
// 死代码消除
function deadCodeExample() {
    const x = 10;
    const y = 20;
    if (false) { // AST 分析可以识别这段永远不会执行的代码
        console.log('This will never run');
    }
    return x + y;
}

// 常量折叠
function constantFolding() {
    const result = 2 + 3 * 4; // AST 可以在编译时计算为 14
    return result;
}

// 内联优化
function inlineOptimization() {
    function square(x) { return x * x; }
    return square(5); // 可以内联为 return 5 * 5;
}
```

### 2.3 AST 工具与实践

```javascript
// 使用 Babel 操作 AST
const babel = require('@babel/core');
const t = require('@babel/types');

// AST 转换插件示例
function consoleRemovalPlugin() {
    return {
        visitor: {
            CallExpression(path) {
                if (
                    t.isMemberExpression(path.node.callee) &&
                    t.isIdentifier(path.node.callee.object, { name: 'console' })
                ) {
                    path.remove(); // 移除 console 调用
                }
            }
        }
    };
}
```



## 词法分析与语法分析的优化技术

### 3.1 词法分析优化

#### 3.1.1 预扫描技术

```javascript
// 预扫描可以快速识别函数边界
function outerFunction() {
    // 预扫描阶段只识别函数结构，不解析内部代码
    function innerFunction() {
        // 只有在需要时才完全解析
        const complexLogic = performComplexCalculation();
        return complexLogic;
    }
    
    // 只有调用时才触发完整解析
    if (someCondition) {
        return innerFunction();
    }
}
```

#### 3.1.2 延迟解析策略

```javascript
// 立即执行函数 - 立即解析
(function() {
    console.log('Immediately parsed and executed');
})();

// 函数声明 - 延迟解析
function delayedParsing() {
    // 只有在首次调用时才完全解析
    console.log('Parsed only when called');
}

// 箭头函数 - 根据上下文决定解析时机
const arrowFunction = () => {
    console.log('Context-dependent parsing');
};
```

### 3.2 语法分析优化

#### 3.2.1 增量解析

```javascript
// 代码编辑时的增量解析示例
class IncrementalParser {
    constructor() {
        this.cachedAST = null;
        this.lastSource = '';
    }
    
    parse(source) {
        if (this.canUseIncremental(source)) {
            return this.incrementalParse(source);
        }
        return this.fullParse(source);
    }
    
    canUseIncremental(source) {
        // 检查是否可以使用增量解析
        const diff = this.getDifference(this.lastSource, source);
        return diff.isMinor;
    }
    
    incrementalParse(source) {
        // 只重新解析变更的部分
        const changes = this.identifyChanges(source);
        return this.applyChangesToAST(this.cachedAST, changes);
    }
}
```



## JavaScript 模块加载与执行优化

### 4.1 ES6 模块优化

#### 4.1.1 静态分析与 Tree Shaking

```javascript
// utils.js - 工具模块
export function usedFunction() {
    return 'This function is used';
}

export function unusedFunction() {
    return 'This function is never used';
}

export const CONSTANT = 'Some constant';

// main.js - 主模块
import { usedFunction } from './utils.js';
// unusedFunction 和 CONSTANT 会被 Tree Shaking 移除

console.log(usedFunction());
```

#### 4.1.2 模块预加载优化

```javascript
// 动态导入优化
async function optimizedModuleLoading() {
    // 条件性加载
    if (needsSpecialFeature) {
        const { specialModule } = await import('./special-feature.js');
        return specialModule.process();
    }
    
    // 并行加载多个模块
    const [moduleA, moduleB] = await Promise.all([
        import('./module-a.js'),
        import('./module-b.js')
    ]);
    
    return processModules(moduleA, moduleB);
}

// 预加载关键模块
const criticalModulePromise = import('./critical-module.js');

async function useCriticalModule() {
    const { criticalFunction } = await criticalModulePromise;
    return criticalFunction();
}
```

### 4.2 CommonJS 模块优化

```javascript
// 优化的 CommonJS 模块加载
const moduleCache = new Map();

function optimizedRequire(modulePath) {
    // 检查缓存
    if (moduleCache.has(modulePath)) {
        return moduleCache.get(modulePath);
    }
    
    // 异步加载模块
    const modulePromise = loadModuleAsync(modulePath);
    moduleCache.set(modulePath, modulePromise);
    
    return modulePromise;
}

// 模块懒加载
const lazyModule = {
    get processor() {
        return require('./heavy-processor.js');
    }
};
```



## cript 标签的 async 与 defer 深度解析

### 5.1 加载策略对比

```html
<!-- 默认同步加载 - 阻塞解析 -->
<script src="blocking-script.js"></script>

<!-- async 异步加载 - 下载完成后立即执行 -->
<script async src="analytics.js"></script>

<!-- defer 延迟执行 - DOMContentLoaded 前按顺序执行 -->
<script defer src="main.js"></script>
<script defer src="secondary.js"></script>

<!-- 内联脚本的处理 -->
<script>
    // 内联脚本总是阻塞的
    console.log('Inline script execution');
</script>
```

### 5.2 最佳实践策略

```html
<!DOCTYPE html>
<html>
<head>
    <!-- 关键CSS内联或预加载 -->
    <style>
        /* 关键样式内联 */
        .critical { display: block; }
    </style>
    
    <!-- 预加载关键资源 -->
    <link rel="preload" href="critical-script.js" as="script">
    <link rel="preload" href="webfont.woff2" as="font" type="font/woff2" crossorigin>
    
    <!-- 预连接到重要域名 -->
    <link rel="preconnect" href="https://api.analytics.com">
</head>
<body>
    <!-- 页面内容 -->
    <main>Content here</main>
    
    <!-- 关键脚本使用 defer -->
    <script defer src="critical-script.js"></script>
    
    <!-- 独立的分析脚本使用 async -->
    <script async src="https://api.analytics.com/track.js"></script>
    
    <!-- 优化的加载顺序 -->
    <script>
        // 内联关键初始化代码
        window.APP_CONFIG = {
            apiUrl: 'https://api.example.com',
            version: '1.0.0'
        };
    </script>
</body>
</html>
```

### 5.3 动态脚本加载优化

```javascript
// 优化的动态脚本加载器
class ScriptLoader {
    constructor() {
        this.loadedScripts = new Set();
        this.loadingPromises = new Map();
    }
    
    async loadScript(src, options = {}) {
        if (this.loadedScripts.has(src)) {
            return Promise.resolve();
        }
        
        if (this.loadingPromises.has(src)) {
            return this.loadingPromises.get(src);
        }
        
        const promise = this.createScriptPromise(src, options);
        this.loadingPromises.set(src, promise);
        
        try {
            await promise;
            this.loadedScripts.add(src);
        } finally {
            this.loadingPromises.delete(src);
        }
        
        return promise;
    }
    
    createScriptPromise(src, options) {
        return new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = src;
            script.async = options.async !== false;
            script.defer = options.defer || false;
            
            script.onload = resolve;
            script.onerror = reject;
            
            // 选择最佳插入位置
            const target = options.target || document.head;
            target.appendChild(script);
        });
    }
}

// 使用示例
const loader = new ScriptLoader();

// 并行加载多个脚本
await Promise.all([
    loader.loadScript('/js/vendor.js'),
    loader.loadScript('/js/utils.js'),
    loader.loadScript('/js/main.js')
]);
```



## 预加载与预解析技术的实际应用

###  资源提示指令

```html
<!-- DNS 预解析 -->
<link rel="dns-prefetch" href="//cdn.example.com">

<!-- 预连接 -->
<link rel="preconnect" href="https://api.example.com" crossorigin>

<!-- 资源预加载 -->
<link rel="preload" href="/critical.css" as="style">
<link rel="preload" href="/hero-image.jpg" as="image">
<link rel="preload" href="/app.js" as="script">

<!-- 资源预获取 -->
<link rel="prefetch" href="/next-page.js">
<link rel="prefetch" href="/user-avatar.jpg">

<!-- 页面预渲染 -->
<link rel="prerender" href="/next-page.html
```



### 智能预加载策略

```javascript
// 基于用户行为的智能预加载
class IntelligentPreloader {
    constructor() {
        this.hoverTimer = null;
        this.intersectionObserver = null;
        this.setupObservers();
    }
    
    setupObservers() {
        // 鼠标悬停预加载
        document.addEventListener('mouseover', (e) => {
            const link = e.target.closest('a[href]');
            if (link) {
                this.hoverTimer = setTimeout(() => {
                    this.preloadPage(link.href);
                }, 100); // 100ms 延迟避免误触发
            }
        });
        
        document.addEventListener('mouseout', () => {
            clearTimeout(this.hoverTimer);
        });
        
        // 视口预加载
        this.intersectionObserver = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    const link = entry.target;
                    this.preloadPage(link.href);
                }
            });
        }, { rootMargin: '100px' });
        
        // 观察即将进入视口的链接
        document.querySelectorAll('a[data-preload]').forEach(link => {
            this.intersectionObserver.observe(link);
        });
    }
    
    async preloadPage(url) {
        try {
            // 预加载关键资源
            await this.preloadCriticalResources(url);
            
            // 可选：预渲染页面
            if (this.shouldPrerender(url)) {
                this.prerenderPage(url);
            }
        } catch (error) {
            console.warn('Preload failed:', error);
        }
    }
    
    async preloadCriticalResources(url) {
        const response = await fetch(url);
        const html = await response.text();
        
        // 解析HTML并预加载关键资源
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');
        
        const criticalResources = doc.querySelectorAll(
            'link[rel="stylesheet"], script[src], img[data-critical]'
        );
        
        criticalResources.forEach(resource => {
            const link = document.createElement('link');
            link.rel = 'preload';
            link.href = resource.src || resource.href;
            link.as = this.getResourceType(resource);
            document.head.appendChild(link);
        });
    }
    
    getResourceType(element) {
        if (element.tagName === 'SCRIPT') return 'script';
        if (element.tagName === 'LINK') return 'style';
        if (element.tagName === 'IMG') return 'image';
        return 'fetch';
    }
}

// 初始化智能预加载
const preloader = new IntelligentPreloader();
```



### Service Worker 预缓存

```javascript
// sw.js - Service Worker 预缓存策略
const CACHE_NAME = 'app-cache-v1';
const PRECACHE_URLS = [
    '/',
    '/css/critical.css',
    '/js/app.js',
    '/js/vendor.js',
    '/images/logo.svg'
];

// 安装时预缓存关键资源
self.addEventListener('install', (event) => {
    event.waitUntil(
        caches.open(CACHE_NAME)
            .then(cache => cache.addAll(PRECACHE_URLS))
            .then(() => self.skipWaiting())
    );
});

// 网络优先策略用于动态内容
self.addEventListener('fetch', (event) => {
    if (event.request.url.includes('/api/')) {
        event.respondWith(
            fetch(event.request)
                .then(response => {
                    // 缓存API响应
                    const responseClone = response.clone();
                    caches.open(CACHE_NAME)
                        .then(cache => cache.put(event.request, responseClone));
                    return response;
                })
                .catch(() => caches.match(event.request))
        );
    } else {
        // 缓存优先策略用于静态资源
        event.respondWith(
            caches.match(event.request)
                .then(response => response || fetch(event.request))
        );
    }
});
```



## 现代构建工具的编译优化策略

### Webpack 优化配置

```javascript
// webpack.config.js
const path = require('path');
const TerserPlugin = require('terser-webpack-plugin');
const { BundleAnalyzerPlugin } = require('webpack-bundle-analyzer');

module.exports = {
    mode: 'production',
    
    // 入口点优化
    entry: {
        main: './src/index.js',
        vendor: ['react', 'react-dom', 'lodash'],
        polyfills: './src/polyfills.js'
    },
    
    // 输出优化
    output: {
        path: path.resolve(__dirname, 'dist'),
        filename: '[name].[contenthash].js',
        chunkFilename: '[name].[contenthash].chunk.js',
        clean: true
    },
    
    // 代码分割优化
    optimization: {
        splitChunks: {
            chunks: 'all',
            cacheGroups: {
                vendor: {
                    test: /[\\/]node_modules[\\/]/,
                    name: 'vendors',
                    chunks: 'all',
                },
                common: {
                    name: 'common',
                    minChunks: 2,
                    chunks: 'all',
                    enforce: true
                }
            }
        },
        
        // 压缩优化
        minimizer: [
            new TerserPlugin({
                terserOptions: {
                    compress: {
                        drop_console: true, // 移除console
                        drop_debugger: true, // 移除debugger
                        pure_funcs: ['console.log'], // 移除特定函数调用
                    },
                    mangle: {
                        safari10: true, // Safari 10兼容性
                    },
                },
                extractComments: false, // 不提取注释到单独文件
            }),
        ],
        
        // 运行时优化
        runtimeChunk: {
            name: 'runtime'
        }
    },
    
    // 模块解析优化
    resolve: {
        extensions: ['.js', '.jsx', '.ts', '.tsx'],
        alias: {
            '@': path.resolve(__dirname, 'src'),
        },
        // 减少解析开销
        modules: [path.resolve(__dirname, 'src'), 'node_modules'],
    },
    
    // 构建性能优化
    module: {
        rules: [
            {
                test: /\.(js|jsx)$/,
                exclude: /node_modules/,
                use: [
                    {
                        loader: 'babel-loader',
                        options: {
                            cacheDirectory: true, // 启用缓存
                            presets: [
                                ['@babel/preset-env', {
                                    targets: 'last 2 versions',
                                    modules: false, // 保留ES模块用于tree shaking
                                    useBuiltIns: 'usage',
                                    corejs: 3
                                }],
                                '@babel/preset-react'
                            ]
                        }
                    }
                ]
            }
        ]
    },
    
    plugins: [
        // 分析包大小
        new BundleAnalyzerPlugin({
            analyzerMode: 'static',
            openAnalyzer: false,
            reportFilename: 'bundle-report.html'
        })
    ]
};
```



### Vite 优化策略

```javascript
// vite.config.js
import { defineConfig } from 'vite';
import { resolve } from 'path';
import { visualizer } from 'rollup-plugin-visualizer';

export default defineConfig({
    // 开发服务器优化
    server: {
        fs: {
            strict: false,
        },
    },
    
    // 构建优化
    build: {
        // 目标环境
        target: 'esnext',
        
        // 代码分割
        rollupOptions: {
            input: {
                main: resolve(__dirname, 'index.html'),
                admin: resolve(__dirname, 'admin.html'),
            },
            output: {
                manualChunks: {
                    vendor: ['react', 'react-dom'],
                    ui: ['@mui/material', '@emotion/react'],
                    utils: ['lodash', 'date-fns'],
                }
            }
        },
        
        // 压缩选项
        minify: 'terser',
        terserOptions: {
            compress: {
                drop_console: true,
                drop_debugger: true,
            },
        },
        
        // 生成源映射
        sourcemap: true,
        
        // 报告压缩详情
        reportCompressedSize: false,
    },
    
    // 依赖预构建优化
    optimizeDeps: {
        include: ['react', 'react-dom'],
        exclude: ['some-esm-dep'],
    },
    
    plugins: [
        // 构建分析
        visualizer({
            filename: 'dist/stats.html',
            open: true,
            gzipSize: true,
        })
    ]
});
```

### 7.3 自定义优化插件

```javascript
// 自定义Webpack插件：代码分析优化
class PerformanceAnalysisPlugin {
    constructor(options = {}) {
        this.options = {
            threshold: 100 * 1024, // 100KB
            ...options
        };
    }
    
    apply(compiler) {
        compiler.hooks.emit.tapAsync('PerformanceAnalysisPlugin', (compilation, callback) => {
            const assets = compilation.assets;
            const analysis = {
                totalSize: 0,
                largeAssets: [],
                duplicates: new Map(),
            };
            
            // 分析资源大小
            Object.keys(assets).forEach(filename => {
                const asset = assets[filename];
                const size = asset.size();
                analysis.totalSize += size;
                
                if (size > this.options.threshold) {
                    analysis.largeAssets.push({ filename, size });
                }
            });
            
            // 生成分析报告
            const report = this.generateReport(analysis);
            compilation.assets['performance-analysis.json'] = {
                source: () => JSON.stringify(report, null, 2),
                size: () => JSON.stringify(report).length
            };
            
            callback();
        });
    }
    
    generateReport(analysis) {
        return {
            summary: {
                totalSize: analysis.totalSize,
                totalAssets: Object.keys(analysis).length,
                largeAssetsCount: analysis.largeAssets.length,
            },
            recommendations: this.generateRecommendations(analysis),
            details: analysis,
            timestamp: new Date().toISOString(),
        };
    }
    
    generateRecommendations(analysis) {
        const recommendations = [];
        
        if (analysis.largeAssets.length > 0) {
            recommendations.push({
                type: 'warning',
                message: `Found ${analysis.largeAssets.length} large assets`,
                suggestion: 'Consider code splitting or lazy loading'
            });
        }
        
        return recommendations;
    }
}

// 使用自定义插件
module.exports = {
    plugins: [
        new PerformanceAnalysisPlugin({
            threshold: 50 * 1024 // 50KB
        })
    ]
};
```



### 性能优化清单

1. 解析优化
   - 使用延迟解析策略
   - 实施代码分割
   - 优化AST生成
2. 模块优化
   - 启用Tree Shaking
   - 使用动态导入
   - 优化模块解析路径
3. 加载优化
   - 合理使用async/defer
   - 实施资源预加载
   - 配置Service Worker缓存
4. 构建优化
   - 配置代码压缩
   - 启用缓存策略
   - 分析构建产物

### 监控与测量

```javascript
// 性能监控示例
class PerformanceMonitor {
    static measureScriptLoading() {
        const observer = new PerformanceObserver((list) => {
            list.getEntries().forEach((entry) => {
                if (entry.entryType === 'navigation') {
                    console.log('页面加载性能:', {
                        domContentLoaded: entry.domContentLoadedEventEnd - entry.fetchStart,
                        loadComplete: entry.loadEventEnd - entry.fetchStart,
                        firstPaint: performance.getEntriesByType('paint')[0]?.startTime
                    });
                }
            });
        });
        
        observer.observe({ entryTypes: ['navigation', 'paint'] });
    }
    
    static measureScriptParsing() {
        const scripts = document.querySelectorAll('script[src]');
        scripts.forEach(script => {
            const start = performance.now();
            script.addEventListener('load', () => {
                const end = performance.now();
                console.log(`脚本 ${script.src} 解析耗时: ${end - start}ms`);
            });
        });
    }
}

// 初始化性能监控
PerformanceMonitor.measureScriptLoading();
PerformanceMonitor.measureScriptParsing();
```
