# 设计模式与架构

## 单例模式在前端中的实现与应用场景

单例模式确保一个类只有一个实例，并提供全局访问点。

### 基础实现

```javascript
// ES6 类实现
class Singleton {
  constructor() {
    if (Singleton.instance) {
      return Singleton.instance;
    }
    Singleton.instance = this;
    this.data = {};
  }
  
  setData(key, value) {
    this.data[key] = value;
  }
  
  getData(key) {
    return this.data[key];
  }
}

// 使用
const instance1 = new Singleton();
const instance2 = new Singleton();
console.log(instance1 === instance2); // true
```



### 懒汉式单例（推荐）

```javascript
class ConfigManager {
  constructor() {
    this.config = {};
  }
  
  static getInstance() {
    if (!ConfigManager.instance) {
      ConfigManager.instance = new ConfigManager();
    }
    return ConfigManager.instance;
  }
  
  setConfig(key, value) {
    this.config[key] = value;
  }
  
  getConfig(key) {
    return this.config[key];
  }
}

// 使用
const config = ConfigManager.getInstance();
config.setConfig('apiUrl', 'https://api.example.com');
```



### 实际应用场景

```javascript
// 1. 全局状态管理
class GlobalStore {
  constructor() {
    this.state = {};
    this.listeners = [];
  }
  
  static getInstance() {
    if (!GlobalStore.instance) {
      GlobalStore.instance = new GlobalStore();
    }
    return GlobalStore.instance;
  }
  
  setState(newState) {
    this.state = { ...this.state, ...newState };
    this.listeners.forEach(listener => listener(this.state));
  }
  
  subscribe(listener) {
    this.listeners.push(listener);
    return () => {
      this.listeners = this.listeners.filter(l => l !== listener);
    };
  }
}

// 2. 日志管理器
class Logger {
  constructor() {
    this.logs = [];
  }
  
  static getInstance() {
    if (!Logger.instance) {
      Logger.instance = new Logger();
    }
    return Logger.instance;
  }
  
  log(level, message) {
    const timestamp = new Date().toISOString();
    this.logs.push({ level, message, timestamp });
    console.log(`[${level}] ${timestamp}: ${message}`);
  }
  
  getLogs() {
    return this.logs;
  }
}
```



## 工厂模式与依赖注入在大型应用中的应用

工厂模式创建对象而不暴露创建逻辑，依赖注入则管理对象间的依赖关系。

### 简单工厂模式

```javascript
// 组件工厂
class ComponentFactory {
  static createComponent(type, props = {}) {
    switch (type) {
      case 'button':
        return new Button(props);
      case 'input':
        return new Input(props);
      case 'modal':
        return new Modal(props);
      default:
        throw new Error(`Unknown component type: ${type}`);
    }
  }
}

class Button {
  constructor({ text, onClick, variant = 'primary' }) {
    this.text = text;
    this.onClick = onClick;
    this.variant = variant;
  }
  
  render() {
    return `<button class="${this.variant}" onclick="${this.onClick}">${this.text}</button>`;
  }
}
```





### 抽象工厂模式

```javascript
// 主题工厂
class ThemeFactory {
  createButton() {
    throw new Error('createButton must be implemented');
  }
  
  createInput() {
    throw new Error('createInput must be implemented');
  }
}

class DarkThemeFactory extends ThemeFactory {
  createButton(props) {
    return new DarkButton(props);
  }
  
  createInput(props) {
    return new DarkInput(props);
  }
}

class LightThemeFactory extends ThemeFactory {
  createButton(props) {
    return new LightButton(props);
  }
  
  createInput(props) {
    return new LightInput(props);
  }
}

// 主题管理器
class ThemeManager {
  constructor() {
    this.currentTheme = 'light';
    this.factories = {
      light: new LightThemeFactory(),
      dark: new DarkThemeFactory()
    };
  }
  
  setTheme(theme) {
    this.currentTheme = theme;
  }
  
  createComponent(type, props) {
    const factory = this.factories[this.currentTheme];
    return factory[`create${type.charAt(0).toUpperCase()}${type.slice(1)}`](props);
  }
}
```



### 依赖注入容器

```javascript
class DIContainer {
  constructor() {
    this.services = new Map();
    this.singletons = new Map();
  }
  
  // 注册服务
  register(name, definition, options = {}) {
    this.services.set(name, {
      definition,
      singleton: options.singleton || false,
      dependencies: options.dependencies || []
    });
  }
  
  // 解析依赖
  resolve(name) {
    const serviceConfig = this.services.get(name);
    if (!serviceConfig) {
      throw new Error(`Service ${name} not found`);
    }
    
    // 单例检查
    if (serviceConfig.singleton && this.singletons.has(name)) {
      return this.singletons.get(name);
    }
    
    // 解析依赖
    const dependencies = serviceConfig.dependencies.map(dep => this.resolve(dep));
    
    // 创建实例
    const instance = new serviceConfig.definition(...dependencies);
    
    // 缓存单例
    if (serviceConfig.singleton) {
      this.singletons.set(name, instance);
    }
    
    return instance;
  }
}

// 使用示例
class ApiService {
  constructor(httpClient, logger) {
    this.httpClient = httpClient;
    this.logger = logger;
  }
  
  async fetchData(url) {
    this.logger.log('info', `Fetching data from ${url}`);
    return await this.httpClient.get(url);
  }
}

class HttpClient {
  async get(url) {
    return fetch(url).then(res => res.json());
  }
}

// 配置依赖注入
const container = new DIContainer();
container.register('httpClient', HttpClient, { singleton: true });
container.register('logger', Logger, { singleton: true });
container.register('apiService', ApiService, { 
  dependencies: ['httpClient', 'logger'] 
});

const api = container.resolve('apiService');
```



## 观察者模式与发布订阅模式的区别及实现



### 观察者模式

观察者模式中，观察者直接订阅主题对象。

```javascript
// 主题（被观察者）
class Subject {
  constructor() {
    this.observers = [];
  }
  
  addObserver(observer) {
    this.observers.push(observer);
  }
  
  removeObserver(observer) {
    this.observers = this.observers.filter(obs => obs !== observer);
  }
  
  notify(data) {
    this.observers.forEach(observer => observer.update(data));
  }
}

// 观察者
class Observer {
  constructor(name) {
    this.name = name;
  }
  
  update(data) {
    console.log(`${this.name} received:`, data);
  }
}

// 具体应用：状态管理
class StateManager extends Subject {
  constructor() {
    super();
    this.state = {};
  }
  
  setState(newState) {
    this.state = { ...this.state, ...newState };
    this.notify(this.state);
  }
  
  getState() {
    return this.state;
  }
}

// 使用
const stateManager = new StateManager();
const observer1 = new Observer('Component1');
const observer2 = new Observer('Component2');

stateManager.addObserver(observer1);
stateManager.addObserver(observer2);
stateManager.setState({ user: 'John', count: 1 });
```



### 发布订阅模式

发布订阅模式通过事件中心解耦发布者和订阅者。

```javascript
class EventBus {
  constructor() {
    this.events = {};
  }
  
  // 订阅事件
  subscribe(eventName, callback) {
    if (!this.events[eventName]) {
      this.events[eventName] = [];
    }
    
    this.events[eventName].push(callback);
    
    // 返回取消订阅函数
    return () => {
      this.events[eventName] = this.events[eventName].filter(cb => cb !== callback);
    };
  }
  
  // 发布事件
  publish(eventName, data) {
    if (this.events[eventName]) {
      this.events[eventName].forEach(callback => callback(data));
    }
  }
  
  // 一次性订阅
  once(eventName, callback) {
    const unsubscribe = this.subscribe(eventName, (data) => {
      callback(data);
      unsubscribe();
    });
    return unsubscribe;
  }
}

// 全局事件总线
const eventBus = new EventBus();

// 使用示例
class UserService {
  login(userData) {
    // 登录逻辑
    eventBus.publish('user:login', userData);
  }
  
  logout() {
    eventBus.publish('user:logout');
  }
}

class HeaderComponent {
  constructor() {
    eventBus.subscribe('user:login', (userData) => {
      this.updateUserInfo(userData);
    });
    
    eventBus.subscribe('user:logout', () => {
      this.clearUserInfo();
    });
  }
  
  updateUserInfo(userData) {
    console.log('Header: User logged in', userData);
  }
  
  clearUserInfo() {
    console.log('Header: User logged out');
  }
}
```



![image-20250527100240583](C:/Users/27019/AppData/Roaming/Typora/typora-user-images/image-20250527100240583.png)





## 装饰器模式在 ES6+ 中的实现与应用

装饰器模式动态地给对象添加新功能，而不改变其原有结构。

### 函数装饰器

```javascript
// 日志装饰器
function logDecorator(target, name, descriptor) {
  const originalMethod = descriptor.value;
  
  descriptor.value = function(...args) {
    console.log(`Calling ${name} with arguments:`, args);
    const result = originalMethod.apply(this, args);
    console.log(`${name} returned:`, result);
    return result;
  };
  
  return descriptor;
}

// 性能监控装饰器
function performanceDecorator(target, name, descriptor) {
  const originalMethod = descriptor.value;
  
  descriptor.value = function(...args) {
    const start = performance.now();
    const result = originalMethod.apply(this, args);
    const end = performance.now();
    console.log(`${name} executed in ${end - start} milliseconds`);
    return result;
  };
  
  return descriptor;
}

// 缓存装饰器
function cacheDecorator(target, name, descriptor) {
  const originalMethod = descriptor.value;
  const cache = new Map();
  
  descriptor.value = function(...args) {
    const key = JSON.stringify(args);
    
    if (cache.has(key)) {
      console.log(`Cache hit for ${name}`);
      return cache.get(key);
    }
    
    const result = originalMethod.apply(this, args);
    cache.set(key, result);
    return result;
  };
  
  return descriptor;
}

// 使用装饰器（需要 Babel 支持）
class MathService {
  @logDecorator
  @performanceDecorator
  @cacheDecorator
  fibonacci(n) {
    if (n <= 1) return n;
    return this.fibonacci(n - 1) + this.fibonacci(n - 2);
  }
}
```



### 高阶函数实现装饰器

```javascript
// 函数式装饰器
const withLogging = (fn) => {
  return function(...args) {
    console.log(`Calling function with args:`, args);
    const result = fn.apply(this, args);
    console.log(`Function returned:`, result);
    return result;
  };
};

const withRetry = (maxRetries = 3) => (fn) => {
  return async function(...args) {
    let lastError;
    
    for (let i = 0; i < maxRetries; i++) {
      try {
        return await fn.apply(this, args);
      } catch (error) {
        lastError = error;
        console.log(`Attempt ${i + 1} failed:`, error.message);
        if (i < maxRetries - 1) {
          await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));
        }
      }
    }
    
    throw lastError;
  };
};

const withThrottle = (delay) => (fn) => {
  let lastCall = 0;
  
  return function(...args) {
    const now = Date.now();
    if (now - lastCall >= delay) {
      lastCall = now;
      return fn.apply(this, args);
    }
  };
};

// 组合装饰器
const fetchData = withLogging(
  withRetry(3)(
    withThrottle(1000)(
      async (url) => {
        const response = await fetch(url);
        if (!response.ok) throw new Error('Network error');
        return response.json();
      }
    )
  )
);
```



### 类装饰器

```javascript
// 可观察对象装饰器
function observable(target) {
  return class extends target {
    constructor(...args) {
      super(...args);
      this._observers = [];
    }
    
    addObserver(observer) {
      this._observers.push(observer);
    }
    
    removeObserver(observer) {
      this._observers = this._observers.filter(obs => obs !== observer);
    }
    
    notify(data) {
      this._observers.forEach(observer => observer.update(data));
    }
  };
}

// 使用
@observable
class UserModel {
  constructor() {
    this.data = {};
  }
  
  setData(key, value) {
    this.data[key] = value;
    this.notify({ key, value, data: this.data });
  }
}
```





## 策略模式在表单验证中的实践

策略模式定义一系列算法，把它们封装起来，并且使它们可以相互替换。

```javascript
// 验证策略接口
class ValidationStrategy {
  validate(value) {
    throw new Error('validate method must be implemented');
  }
}

// 具体验证策略
class RequiredStrategy extends ValidationStrategy {
  validate(value) {
    return {
      isValid: value !== null && value !== undefined && value.toString().trim() !== '',
      message: 'This field is required'
    };
  }
}

class EmailStrategy extends ValidationStrategy {
  validate(value) {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return {
      isValid: emailRegex.test(value),
      message: 'Please enter a valid email address'
    };
  }
}

class MinLengthStrategy extends ValidationStrategy {
  constructor(minLength) {
    super();
    this.minLength = minLength;
  }
  
  validate(value) {
    return {
      isValid: value && value.length >= this.minLength,
      message: `Minimum length is ${this.minLength} characters`
    };
  }
}

class MaxLengthStrategy extends ValidationStrategy {
  constructor(maxLength) {
    super();
    this.maxLength = maxLength;
  }
  
  validate(value) {
    return {
      isValid: !value || value.length <= this.maxLength,
      message: `Maximum length is ${this.maxLength} characters`
    };
  }
}

class PasswordStrengthStrategy extends ValidationStrategy {
  validate(value) {
    const hasUpper = /[A-Z]/.test(value);
    const hasLower = /[a-z]/.test(value);
    const hasNumber = /\d/.test(value);
    const hasSpecial = /[!@#$%^&*]/.test(value);
    const isLongEnough = value && value.length >= 8;
    
    const isValid = hasUpper && hasLower && hasNumber && hasSpecial && isLongEnough;
    
    return {
      isValid,
      message: 'Password must contain uppercase, lowercase, number, special character and be at least 8 characters long'
    };
  }
}

// 表单验证器
class FormValidator {
  constructor() {
    this.fields = new Map();
  }
  
  addField(fieldName, strategies) {
    this.fields.set(fieldName, strategies);
  }
  
  validate(formData) {
    const errors = {};
    let isValid = true;
    
    for (const [fieldName, strategies] of this.fields) {
      const value = formData[fieldName];
      const fieldErrors = [];
      
      for (const strategy of strategies) {
        const result = strategy.validate(value);
        if (!result.isValid) {
          fieldErrors.push(result.message);
          isValid = false;
        }
      }
      
      if (fieldErrors.length > 0) {
        errors[fieldName] = fieldErrors;
      }
    }
    
    return { isValid, errors };
  }
}

// 使用示例
const validator = new FormValidator();

// 配置验证规则
validator.addField('email', [
  new RequiredStrategy(),
  new EmailStrategy()
]);

validator.addField('password', [
  new RequiredStrategy(),
  new PasswordStrengthStrategy()
]);

validator.addField('username', [
  new RequiredStrategy(),
  new MinLengthStrategy(3),
  new MaxLengthStrategy(20)
]);

// 验证表单
const formData = {
  email: 'user@example.com',
  password: 'WeakPass',
  username: 'jo'
};

const result = validator.validate(formData);
console.log('Validation result:', result);
```





### 动态验证策略工厂

```javascript
class ValidationStrategyFactory {
  static strategies = {
    required: () => new RequiredStrategy(),
    email: () => new EmailStrategy(),
    minLength: (length) => new MinLengthStrategy(length),
    maxLength: (length) => new MaxLengthStrategy(length),
    passwordStrength: () => new PasswordStrengthStrategy(),
    pattern: (regex, message) => new PatternStrategy(regex, message),
    custom: (validatorFn, message) => new CustomStrategy(validatorFn, message)
  };
  
  static create(type, ...args) {
    const strategyFactory = this.strategies[type];
    if (!strategyFactory) {
      throw new Error(`Unknown validation strategy: ${type}`);
    }
    return strategyFactory(...args);
  }
}

class PatternStrategy extends ValidationStrategy {
  constructor(pattern, message) {
    super();
    this.pattern = pattern;
    this.message = message;
  }
  
  validate(value) {
    return {
      isValid: this.pattern.test(value),
      message: this.message
    };
  }
}

class CustomStrategy extends ValidationStrategy {
  constructor(validatorFn, message) {
    super();
    this.validatorFn = validatorFn;
    this.message = message;
  }
  
  validate(value) {
    return {
      isValid: this.validatorFn(value),
      message: this.message
    };
  }
}

// 配置驱动的验证
const validationConfig = {
  email: [
    { type: 'required' },
    { type: 'email' }
  ],
  phone: [
    { type: 'required' },
    { 
      type: 'pattern', 
      args: [/^\d{10,11}$/, 'Please enter a valid phone number'] 
    }
  ],
  age: [
    { type: 'required' },
    { 
      type: 'custom', 
      args: [
        (value) => value >= 18 && value <= 120,
        'Age must be between 18 and 120'
      ] 
    }
  ]
};

// 根据配置创建验证器
function createValidatorFromConfig(config) {
  const validator = new FormValidator();
  
  for (const [fieldName, rules] of Object.entries(config)) {
    const strategies = rules.map(rule => 
      ValidationStrategyFactory.create(rule.type, ...(rule.args || []))
    );
    validator.addField(fieldName, strategies);
  }
  
  return validator;
}

const configValidator = createValidatorFromConfig(validationConfig);
```



## 代理模式在数据响应式系统中的应用

代理模式为其他对象提供一种代理以控制对这个对象的访问。

### 基础响应式系统

```javascript
// 响应式代理
function createReactive(target, callback) {
  return new Proxy(target, {
    get(obj, prop) {
      console.log(`Getting property: ${String(prop)}`);
      return Reflect.get(obj, prop);
    },
    
    set(obj, prop, value) {
      console.log(`Setting property: ${String(prop)} = ${value}`);
      const oldValue = obj[prop];
      const result = Reflect.set(obj, prop, value);
      
      if (oldValue !== value) {
        callback(prop, value, oldValue);
      }
      
      return result;
    },
    
    deleteProperty(obj, prop) {
      console.log(`Deleting property: ${String(prop)}`);
      const oldValue = obj[prop];
      const result = Reflect.deleteProperty(obj, prop);
      callback(prop, undefined, oldValue);
      return result;
    }
  });
}

// 使用示例
const data = { name: 'John', age: 30 };
const reactiveData = createReactive(data, (prop, newValue, oldValue) => {
  console.log(`Property ${String(prop)} changed from ${oldValue} to ${newValue}`);
});

reactiveData.name = 'Jane'; // 触发回调
reactiveData.age = 25;      // 触发回调
```



### 深度响应式系统

```javascript
class ReactiveSystem {
  constructor() {
    this.observers = new Map();
  }
  
  // 观察属性变化
  observe(obj, path, callback) {
    if (!this.observers.has(path)) {
      this.observers.set(path, []);
    }
    this.observers.get(path).push(callback);
  }
  
  // 触发观察者
  notify(path, newValue, oldValue) {
    const callbacks = this.observers.get(path) || [];
    callbacks.forEach(callback => callback(newValue, oldValue, path));
  }
  
  // 创建深度响应式对象
  createReactive(obj, basePath = '') {
    const self = this;
    
    return new Proxy(obj, {
      get(target, prop) {
        const value = target[prop];
        
        // 如果值是对象，也要创建响应式代理
        if (value && typeof value === 'object') {
          const currentPath = basePath ? `${basePath}.${String(prop)}` : String(prop);
          return self.createReactive(value, currentPath);
        }
        
        return value;
      },
      
      set(target, prop, value) {
        const currentPath = basePath ? `${basePath}.${String(prop)}` : String(prop);
        const oldValue = target[prop];
        
        // 如果新值是对象，创建响应式代理
        if (value && typeof value === 'object') {
          value = self.createReactive(value, currentPath);
        }
        
        target[prop] = value;
        
        if (oldValue !== value) {
          self.notify(currentPath, value, oldValue);
        }
        
        return true;
      }
    });
  }
}

// 使用示例
const reactiveSystem = new ReactiveSystem();

const user = reactiveSystem.createReactive({
  profile: {
    name: 'John',
    address: {
      city: 'New York',
      country: 'USA'
    }
  },
  settings: {
    theme: 'dark'
  }
});

// 观察不同层级的属性
reactiveSystem.observe('profile.name', (newValue, oldValue) => {
  console.log(`Name changed: ${oldValue} -> ${newValue}`);
});

reactiveSystem.observe('profile.address.city', (newValue, oldValue) => {
  console.log(`City changed: ${oldValue} -> ${newValue}`);
});

// 测试
user.profile.name = 'Jane';           // 触发 profile.name 观察者
user.profile.address.city = 'Boston'; // 触发 profile.address.city 观察者
```



### 计算属性实现

```javascript
class ComputedProperty {
  constructor(getter, dependencies = []) {
    this.getter = getter;
    this.dependencies = dependencies;
    this.cached = true;
    this._value = undefined;
    this.dirty = true;
  }
  
  get value() {
    if (this.dirty) {
      this._value = this.getter();
      this.dirty = false;
    }
    return this._value;
  }
  
  invalidate() {
    this.dirty = true;
  }
}

class AdvancedReactiveSystem extends ReactiveSystem {
  constructor() {
    super();
    this.computedProps = new Map();
  }
  
  // 创建计算属性
  computed(getter, dependencies) {
    const computed = new ComputedProperty(getter, dependencies);
    
    // 监听依赖变化
    dependencies.forEach(dep => {
      this.observe(dep, () => {
        computed.invalidate();
        this.notify(`computed:${computed.id}`, computed.value);
      });
    });
    
    return computed;
  }
  
  createReactive(obj, basePath = '') {
    const proxy = super.createReactive(obj, basePath);
    
    // 添加计算属性支持
    return new Proxy(proxy, {
      get(target, prop) {
        // 如果是计算属性
        if (prop.startsWith('$computed_')) {
          const computedProp = this.computedProps.get(prop);
          return computedProp ? computedProp.value : undefined;
        }
        
        return Reflect.get(target, prop);
      }
    });
  }
}

// 使用示例
const advancedSystem = new AdvancedReactiveSystem();

const store = advancedSystem.createReactive({
  user: {
    firstName: 'John',
    lastName: 'Doe'
  },
  cart: {
    items: [
      { name: 'Book', price: 10, quantity: 2 },
      { name: 'Pen', price: 5, quantity: 3 }
    ]
  }
});

// 创建计算属性
const fullName = advancedSystem.computed(
  () => `${store.user.firstName} ${store.user.lastName}`,
  ['user.firstName', 'user.lastName']
);

const totalPrice = advancedSystem.computed(
  () => store.cart.items.reduce((sum, item) => sum + (item.price * item.quantity), 0),
  ['cart.items']
);

console.log(fullName.value); // "John Doe"
console.log(totalPrice.value); // 35

// 修改数据，计算属性自动更新
store.user.firstName = 'Jane';
console.log(fullName.value); // "Jane Doe"
```



## 命令模式在前端应用状态管理中的实现

命令模式将请求封装成对象，从而使你可以用不同的请求对客户进行参数化。

### 基础命令模式

```javascript
// 命令接口
class Command {
  execute() {
    throw new Error('execute method must be implemented');
  }
  
  undo() {
    throw new Error('undo method must be implemented');
  }
}

// 具体命令
class SetValueCommand extends Command {
  constructor(target, property, newValue) {
    super();
    this.target = target;
    this.property = property;
    this.newValue = newValue;
    this.oldValue = target[property];
  }
  
  execute() {
    this.target[this.property] = this.newValue;
  }
  
  undo() {
    this.target[this.property] = this.oldValue;
  }
}

class AddItemCommand extends Command {
  constructor(array, item) {
    super();
    this.array = array;
    this.item = item;
  }
  
  execute() {
    this.array.push(this.item);
  }
  
  undo() {
    this.array.pop();
  }
}

class RemoveItemCommand extends Command {
  constructor(array, index) {
    super();
    this.array = array;
    this.index = index;
    this.removedItem = null;
  }
  
  execute() {
    this.removedItem = this.array.splice(this.index, 1)[0];
  }
  
  undo() {
    this.array.splice(this.index, 0, this.removedItem);
  }
}

// 命令调用者
class CommandInvoker {
  constructor() {
    this.history = [];
    this.currentIndex = -1;
  }
  
  execute(command) {
    // 清除当前位置之后的历史记录
    this.history = this.history.slice(0, this.currentIndex + 1);
    
    // 执行命令
    command.execute();
    
    // 添加到历史记录
    this.history.push(command);
    this.currentIndex++;
  }
  
  undo() {
    if (this.currentIndex >= 0) {
      const command = this.history[this.currentIndex];
      command.undo();
      this.currentIndex--;
      return true;
    }
    return false;
  }
  
  redo() {
    if (this.currentIndex < this.history.length - 1) {
      this.currentIndex++;
      const command = this.history[this.currentIndex];
      command.execute();
      return true;
    }
    return false;
  }
  
  canUndo() {
    return this.currentIndex >= 0;
  }
  
  canRedo() {
    return this.currentIndex < this.history.length - 1;
  }
  
  getHistory() {
    return this.history.map((cmd, index) => ({
      command: cmd.constructor.name,
      executed: index <= this.currentIndex
    }));
  }
}

// 使用示例
const state = { counter: 0, items: [] };
const invoker = new CommandInvoker();

// 执行一系列命令
invoker.execute(new SetValueCommand(state, 'counter', 1));
invoker.execute(new SetValueCommand(state, 'counter', 2));
invoker.execute(new AddItemCommand(state.items, 'item1'));
invoker.execute(new AddItemCommand(state.items, 'item2'));

console.log('Current state:', state); // { counter: 2, items: ['item1', 'item2'] }

// 撤销操作
invoker.undo();
console.log('After undo:', state); // { counter: 2, items: ['item1'] }

invoker.undo();
invoker.undo();
console.log('After 2 more undos:', state); // { counter: 1, items: [] }

// 重做操作
invoker.redo();
console.log('After redo:', state); // { counter: 2, items: [] }
```



### 状态管理系统实现

```javascript
// 状态管理中的命令模式
class StateCommand extends Command {
  constructor(statePath, newValue, oldValue) {
    super();
    this.statePath = statePath;
    this.newValue = newValue;
    this.oldValue = oldValue;
  }
}

class UpdateStateCommand extends StateCommand {
  constructor(store, statePath, newValue) {
    const oldValue = store.getState(statePath);
    super(statePath, newValue, oldValue);
    this.store = store;
  }
  
  execute() {
    this.store.setState(this.statePath, this.newValue, false); // 不记录到历史
  }
  
  undo() {
    this.store.setState(this.statePath, this.oldValue, false);
  }
}

class BatchCommand extends Command {
  constructor(commands) {
    super();
    this.commands = commands;
  }
  
  execute() {
    this.commands.forEach(command => command.execute());
  }
  
  undo() {
    // 逆序撤销
    for (let i = this.commands.length - 1; i >= 0; i--) {
      this.commands[i].undo();
    }
  }
}

// 状态存储
class StateStore {
  constructor(initialState = {}) {
    this.state = { ...initialState };
    this.invoker = new CommandInvoker();
    this.listeners = [];
  }
  
  // 获取状态值
  getState(path = '') {
    if (!path) return this.state;
    
    return path.split('.').reduce((obj, key) => obj && obj[key], this.state);
  }
  
  // 设置状态值
  setState(path, value, recordHistory = true) {
    if (recordHistory) {
      const command = new UpdateStateCommand(this, path, value);
      this.invoker.execute(command);
    } else {
      // 直接更新状态
      this._updateState(path, value);
    }
    
    this._notifyListeners();
  }
  
  // 内部状态更新方法
  _updateState(path, value) {
    const keys = path.split('.');
    const lastKey = keys.pop();
    const target = keys.reduce((obj, key) => {
      if (!obj[key]) obj[key] = {};
      return obj[key];
    }, this.state);
    
    target[lastKey] = value;
  }
  
  // 批量更新
  batchUpdate(updates) {
    const commands = updates.map(({ path, value }) => 
      new UpdateStateCommand(this, path, value)
    );
    
    const batchCommand = new BatchCommand(commands);
    this.invoker.execute(batchCommand);
    this._notifyListeners();
  }
  
  // 撤销/重做
  undo() {
    if (this.invoker.undo()) {
      this._notifyListeners();
      return true;
    }
    return false;
  }
  
  redo() {
    if (this.invoker.redo()) {
      this._notifyListeners();
      return true;
    }
    return false;
  }
  
  // 订阅状态变更
  subscribe(listener) {
    this.listeners.push(listener);
    return () => {
      this.listeners = this.listeners.filter(l => l !== listener);
    };
  }
  
  _notifyListeners() {
    this.listeners.forEach(listener => listener(this.state));
  }
  
  // 获取历史记录
  getHistory() {
    return this.invoker.getHistory();
  }
  
  canUndo() {
    return this.invoker.canUndo();
  }
  
  canRedo() {
    return this.invoker.canRedo();
  }
}

// 使用示例
const store = new StateStore({
  user: { name: '', email: '' },
  cart: { items: [], total: 0 },
  ui: { loading: false, theme: 'light' }
});

// 订阅状态变更
const unsubscribe = store.subscribe((state) => {
  console.log('State updated:', state);
});

// 单个更新
store.setState('user.name', 'John');
store.setState('user.email', 'john@example.com');

// 批量更新
store.batchUpdate([
  { path: 'cart.items', value: [{ id: 1, name: 'Book', price: 10 }] },
  { path: 'cart.total', value: 10 },
  { path: 'ui.loading', value: false }
]);

console.log('Current state:', store.getState());
console.log('Can undo:', store.canUndo());

// 撤销操作
store.undo();
console.log('After undo:', store.getState());

// 重做操作
store.redo();
console.log('After redo:', store.getState());
```



### 异步命令处理

```javascript
// 异步命令基类
class AsyncCommand extends Command {
  constructor() {
    super();
    this.status = 'pending'; // pending, executing, completed, failed
    this.error = null;
  }
  
  async execute() {
    this.status = 'executing';
    try {
      await this.doExecute();
      this.status = 'completed';
    } catch (error) {
      this.status = 'failed';
      this.error = error;
      throw error;
    }
  }
  
  async undo() {
    if (this.status === 'completed') {
      await this.doUndo();
    }
  }
  
  doExecute() {
    throw new Error('doExecute must be implemented');
  }
  
  doUndo() {
    throw new Error('doUndo must be implemented');
  }
}

// 异步API调用命令
class ApiCallCommand extends AsyncCommand {
  constructor(apiCall, onSuccess, onError) {
    super();
    this.apiCall = apiCall;
    this.onSuccess = onSuccess;
    this.onError = onError;
    this.result = null;
  }
  
  async doExecute() {
    this.result = await this.apiCall();
    if (this.onSuccess) {
      this.onSuccess(this.result);
    }
    return this.result;
  }
  
  async doUndo() {
    // API调用的撤销通常需要调用相反的API
    if (this.onError) {
      this.onError(new Error('Command undone'));
    }
  }
}

// 异步命令调用者
class AsyncCommandInvoker {
  constructor() {
    this.commands = [];
    this.executing = false;
  }
  
  async execute(command) {
    this.commands.push(command);
    
    if (!this.executing) {
      await this.processQueue();
    }
  }
  
  async processQueue() {
    this.executing = true;
    
    while (this.commands.length > 0) {
      const command = this.commands.shift();
      try {
        await command.execute();
      } catch (error) {
        console.error('Command execution failed:', error);
      }
    }
    
    this.executing = false;
  }
}

// 使用示例
const asyncInvoker = new AsyncCommandInvoker();

// 模拟API调用
const fetchUserCommand = new ApiCallCommand(
  () => new Promise(resolve => setTimeout(() => resolve({ id: 1, name: 'John' }), 1000)),
  (result) => console.log('User fetched:', result),
  (error) => console.error('Failed to fetch user:', error)
);

const updateUserCommand = new ApiCallCommand(
  () => new Promise(resolve => setTimeout(() => resolve({ success: true }), 500)),
  (result) => console.log('User updated:', result),
  (error) => console.error('Failed to update user:', error)
);

// 执行异步命令
asyncInvoker.execute(fetchUserCommand);
asyncInvoker.execute(updateUserCommand);
```



### 宏命令与快照

```javascript
// 快照命令
class SnapshotCommand extends Command {
  constructor(target) {
    super();
    this.target = target;
    this.snapshot = JSON.parse(JSON.stringify(target));
  }
  
  execute() {
    // 快照命令的执行就是保存当前状态
    this.snapshot = JSON.parse(JSON.stringify(this.target));
  }
  
  undo() {
    // 恢复到快照状态
    Object.keys(this.target).forEach(key => delete this.target[key]);
    Object.assign(this.target, this.snapshot);
  }
}

// 宏命令 - 复合命令
class MacroCommand extends Command {
  constructor(name, commands = []) {
    super();
    this.name = name;
    this.commands = commands;
  }
  
  add(command) {
    this.commands.push(command);
  }
  
  execute() {
    this.commands.forEach(command => command.execute());
  }
  
  undo() {
    // 逆序撤销所有命令
    for (let i = this.commands.length - 1; i >= 0; i--) {
      this.commands[i].undo();
    }
  }
}

// 智能命令管理器
class SmartCommandManager {
  constructor(maxHistorySize = 50) {
    this.history = [];
    this.currentIndex = -1;
    this.maxHistorySize = maxHistorySize;
    this.snapshots = new Map();
  }
  
  execute(command) {
    // 清理未来的历史
    this.history = this.history.slice(0, this.currentIndex + 1);
    
    // 执行命令
    command.execute();
    
    // 添加到历史
    this.history.push(command);
    this.currentIndex++;
    
    // 限制历史大小
    if (this.history.length > this.maxHistorySize) {
      this.history.shift();
      this.currentIndex--;
    }
    
    // 定期创建快照
    if (this.currentIndex % 10 === 0) {
      this.createSnapshot();
    }
  }
  
  createSnapshot() {
    const snapshotIndex = this.currentIndex;
    this.snapshots.set(snapshotIndex, {
      commands: [...this.history],
      index: this.currentIndex
    });
  }
  
  undo() {
    if (this.currentIndex >= 0) {
      const command = this.history[this.currentIndex];
      command.undo();
      this.currentIndex--;
      return true;
    }
    return false;
  }
  
  redo() {
    if (this.currentIndex < this.history.length - 1) {
      this.currentIndex++;
      const command = this.history[this.currentIndex];
      command.execute();
      return true;
    }
    return false;
  }
  
  // 跳转到特定历史点
  jumpTo(index) {
    if (index < 0 || index >= this.history.length) return false;
    
    // 如果有快照，优先使用快照
    const snapshot = this.findNearestSnapshot(index);
    if (snapshot) {
      this.restoreFromSnapshot(snapshot, index);
    } else {
      // 否则逐步执行/撤销
      while (this.currentIndex !== index) {
        if (this.currentIndex < index) {
          this.redo();
        } else {
          this.undo();
        }
      }
    }
    
    return true;
  }
  
  findNearestSnapshot(index) {
    let nearestIndex = -1;
    for (const snapshotIndex of this.snapshots.keys()) {
      if (snapshotIndex <= index && snapshotIndex > nearestIndex) {
        nearestIndex = snapshotIndex;
      }
    }
    return nearestIndex >= 0 ? this.snapshots.get(nearestIndex) : null;
  }
  
  restoreFromSnapshot(snapshot, targetIndex) {
    // 恢复快照状态
    this.history = [...snapshot.commands];
    this.currentIndex = snapshot.index;
    
    // 从快照点执行到目标点
    while (this.currentIndex < targetIndex) {
      this.redo();
    }
  }
  
  getStats() {
    return {
      historySize: this.history.length,
      currentIndex: this.currentIndex,
      snapshotCount: this.snapshots.size,
      canUndo: this.currentIndex >= 0,
      canRedo: this.currentIndex < this.history.length - 1
    };
  }
}

// 完整使用示例
const appState = {
  todos: [],
  filters: { completed: false, search: '' },
  user: { name: '', preferences: {} }
};

const commandManager = new SmartCommandManager();

// 创建一个复杂的宏命令
const addTodoMacro = new MacroCommand('Add Todo with Settings');
addTodoMacro.add(new AddItemCommand(appState.todos, { 
  id: Date.now(), 
  text: 'New Todo', 
  completed: false 
}));
addTodoMacro.add(new SetValueCommand(appState.filters, 'search', ''));

// 执行命令
commandManager.execute(addTodoMacro);
commandManager.execute(new SetValueCommand(appState.user, 'name', 'John'));

console.log('Current state:', appState);
console.log('Command stats:', commandManager.getStats());

// 撤销和重做
commandManager.undo();
console.log('After undo:', appState);

commandManager.redo();
console.log('After redo:', appState);
```



## 总结

这七种设计模式在前端开发中的应用各有特色：

1. **单例模式**：适用于全局状态管理、配置管理、日志系统等需要唯一实例的场景。
2. **工厂模式**：在组件创建、主题切换、依赖注入等场景中发挥重要作用，提高代码的可扩展性。
3. **观察者模式 vs 发布订阅模式**：观察者模式适合简单的一对多关系，发布订阅模式通过事件中心实现更松散的耦合。
4. **装饰器模式**：通过高阶函数或ES装饰器语法，为函数和类添加额外功能，如日志、缓存、性能监控等。
5. **策略模式**：在表单验证、算法选择等场景中提供灵活的解决方案，支持运行时切换不同策略。
6. **代理模式**：在Vue.js等框架的响应式系统中广泛应用，实现数据拦截和响应式更新。
7. **命令模式**：在状态管理、撤销重做功能、异步操作队列等场景中提供优雅的解决方案。





# JavaScript 函数式编程

## 函数式编程核心概念及其在 JavaScript 中的实现



### 核心概念

函数式编程基于数学中的函数概念，强调以下原则：

- **纯函数 (Pure Functions)**: 相同输入总是产生相同输出，无副作用
- **不可变性 (Immutability)**: 数据一旦创建就不能修改
- **函数是一等公民**: 函数可以作为参数传递、作为返回值、赋值给变量
- **高阶函数**: 接收或返回函数的函数
- **函数组合**: 将简单函数组合成复杂功能

### JavaScript 中的实现

```javascript
// 纯函数示例
const add = (a, b) => a + b;
const multiply = (a, b) => a * b;

// 不纯函数（有副作用）
let count = 0;
const impureIncrement = () => ++count; // 修改外部状态

// 纯函数版本
const pureIncrement = (value) => value + 1;

// 函数作为一等公民
const operations = {
  add: (a, b) => a + b,
  subtract: (a, b) => a - b,
  multiply: (a, b) => a * b,
  divide: (a, b) => a / b
};

const calculate = (operation, a, b) => operation(a, b);
console.log(calculate(operations.add, 5, 3)); // 8
```



## 不可变数据 (Immutability) 的实现策略与性能优化



### 基础不可变操作

```javascript
// 数组不可变操作
const originalArray = [1, 2, 3, 4, 5];

// 添加元素
const addElement = (arr, element) => [...arr, element];
const withNewElement = addElement(originalArray, 6);

// 删除元素
const removeElement = (arr, index) => [
  ...arr.slice(0, index),
  ...arr.slice(index + 1)
];

// 更新元素
const updateElement = (arr, index, newValue) => 
  arr.map((item, i) => i === index ? newValue : item);

// 对象不可变操作
const originalObject = { name: '张三', age: 25, city: '北京' };

// 更新属性
const updateProperty = (obj, key, value) => ({
  ...obj,
  [key]: value
});

// 删除属性
const removeProperty = (obj, key) => {
  const { [key]: removed, ...rest } = obj;
  return rest;
};

// 嵌套对象更新
const updateNestedProperty = (obj, path, value) => {
  const [head, ...tail] = path;
  return {
    ...obj,
    [head]: tail.length === 0 ? value : updateNestedProperty(obj[head], tail, value)
  };
};
```





### 高级不可变数据结构

```javascript
// 实现不可变的 Map
class ImmutableMap {
  constructor(data = {}) {
    this._data = Object.freeze({ ...data });
  }
  
  set(key, value) {
    return new ImmutableMap({
      ...this._data,
      [key]: value
    });
  }
  
  get(key) {
    return this._data[key];
  }
  
  delete(key) {
    const { [key]: deleted, ...rest } = this._data;
    return new ImmutableMap(rest);
  }
  
  has(key) {
    return key in this._data;
  }
  
  keys() {
    return Object.keys(this._data);
  }
  
  values() {
    return Object.values(this._data);
  }
  
  entries() {
    return Object.entries(this._data);
  }
  
  toJS() {
    return { ...this._data };
  }
}

// 使用示例
const map1 = new ImmutableMap({ a: 1, b: 2 });
const map2 = map1.set('c', 3);
const map3 = map2.delete('a');

console.log(map1.toJS()); // { a: 1, b: 2 }
console.log(map2.toJS()); // { a: 1, b: 2, c: 3 }
console.log(map3.toJS()); // { b: 2, c: 3 }
```



### 性能优化策略

```javascript
// 结构共享优化
class StructuralSharingArray {
  constructor(data = [], metadata = {}) {
    this.data = data;
    this.metadata = metadata;
  }
  
  push(element) {
    // 只创建新的引用，共享原有数据
    return new StructuralSharingArray(
      [...this.data, element],
      { ...this.metadata, length: this.data.length + 1 }
    );
  }
  
  // 使用 Proxy 进行懒计算
  static lazy(generator) {
    return new Proxy({}, {
      get(target, prop) {
        if (!(prop in target)) {
          target[prop] = generator();
        }
        return target[prop];
      }
    });
  }
}

// 缓存和记忆化
const memoize = (fn) => {
  const cache = new Map();
  return (...args) => {
    const key = JSON.stringify(args);
    if (cache.has(key)) {
      return cache.get(key);
    }
    const result = fn(...args);
    cache.set(key, result);
    return result;
  };
};

// 深度冻结优化
const deepFreeze = (obj) => {
  if (obj === null || typeof obj !== 'object') return obj;
  
  Object.getOwnPropertyNames(obj).forEach(prop => {
    if (obj[prop] !== null && typeof obj[prop] === 'object') {
      deepFreeze(obj[prop]);
    }
  });
  
  return Object.freeze(obj);
};
```



## 高阶函数设计与装饰器模式实践



### 基础高阶函数

```javascript
// 函数工厂
const createValidator = (rule) => (value) => rule(value);

const isRequired = createValidator(value => value != null && value !== '');
const isEmail = createValidator(value => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value));
const minLength = (min) => createValidator(value => value.length >= min);

// 函数增强器
const withLogging = (fn) => (...args) => {
  console.log(`调用 ${fn.name} 参数:`, args);
  const result = fn(...args);
  console.log(`返回结果:`, result);
  return result;
};

const withTiming = (fn) => (...args) => {
  const start = performance.now();
  const result = fn(...args);
  const end = performance.now();
  console.log(`${fn.name} 执行时间: ${end - start}ms`);
  return result;
};

const withRetry = (maxRetries) => (fn) => (...args) => {
  let retries = 0;
  while (retries <= maxRetries) {
    try {
      return fn(...args);
    } catch (error) {
      if (retries === maxRetries) throw error;
      retries++;
      console.log(`重试 ${retries}/${maxRetries}`);
    }
  }
};
```



### 装饰器模式实践

```javascript
// 通用装饰器系统
class DecoratorSystem {
  static compose(...decorators) {
    return (target) => decorators.reduceRight((decorated, decorator) => 
      decorator(decorated), target);
  }
  
  static cache(ttl = Infinity) {
    return (target) => {
      const cache = new Map();
      return function(...args) {
        const key = JSON.stringify(args);
        const cached = cache.get(key);
        
        if (cached && Date.now() - cached.timestamp < ttl) {
          return cached.value;
        }
        
        const result = target.apply(this, args);
        cache.set(key, { value: result, timestamp: Date.now() });
        return result;
      };
    };
  }
  
  static throttle(delay) {
    return (target) => {
      let isThrottled = false;
      return function(...args) {
        if (isThrottled) return;
        
        isThrottled = true;
        const result = target.apply(this, args);
        setTimeout(() => isThrottled = false, delay);
        return result;
      };
    };
  }
  
  static validate(schema) {
    return (target) => {
      return function(...args) {
        const isValid = schema.every((validator, index) => 
          validator(args[index]));
        
        if (!isValid) {
          throw new Error('参数验证失败');
        }
        
        return target.apply(this, args);
      };
    };
  }
}

// 使用装饰器
const expensiveCalculation = DecoratorSystem.compose(
  withLogging,
  withTiming,
  DecoratorSystem.cache(5000),
  DecoratorSystem.validate([
    value => typeof value === 'number',
    value => value > 0
  ])
)((n) => {
  // 模拟耗时计算
  let result = 0;
  for (let i = 0; i < n * 1000000; i++) {
    result += Math.random();
  }
  return result;
});
```



### 高级装饰器模式

```javascript
// 异步装饰器
const asyncDecorators = {
  timeout: (ms) => (fn) => async (...args) => {
    return Promise.race([
      fn(...args),
      new Promise((_, reject) => 
        setTimeout(() => reject(new Error('超时')), ms))
    ]);
  },
  
  retry: (maxRetries, delay = 1000) => (fn) => async (...args) => {
    for (let i = 0; i <= maxRetries; i++) {
      try {
        return await fn(...args);
      } catch (error) {
        if (i === maxRetries) throw error;
        await new Promise(resolve => setTimeout(resolve, delay * Math.pow(2, i)));
      }
    }
  },
  
  circuit: (threshold = 5, timeout = 60000) => (fn) => {
    let failures = 0;
    let nextAttempt = Date.now();
    
    return async (...args) => {
      if (failures >= threshold && Date.now() < nextAttempt) {
        throw new Error('熔断器开启');
      }
      
      try {
        const result = await fn(...args);
        failures = 0; // 重置失败计数
        return result;
      } catch (error) {
        failures++;
        if (failures >= threshold) {
          nextAttempt = Date.now() + timeout;
        }
        throw error;
      }
    };
  }
};

// 组合异步装饰器
const robustApiCall = asyncDecorators.timeout(5000)(
  asyncDecorators.retry(3, 1000)(
    asyncDecorators.circuit(5, 30000)(
      async (url) => {
        const response = await fetch(url);
        if (!response.ok) throw new Error('请求失败');
        return response.json();
      }
    )
  )
);
```



## 函数组合与管道 (Pipeline) 的实现与应用

### 基础函数组合

```javascript
// 右到左组合
const compose = (...fns) => (value) => 
  fns.reduceRight((acc, fn) => fn(acc), value);

// 左到右管道
const pipe = (...fns) => (value) => 
  fns.reduce((acc, fn) => fn(acc), value);

// 使用示例
const add1 = x => x + 1;
const multiply2 = x => x * 2;
const subtract3 = x => x - 3;

const composed = compose(subtract3, multiply2, add1);
const piped = pipe(add1, multiply2, subtract3);

console.log(composed(5)); // (5 + 1) * 2 - 3 = 9
console.log(piped(5));    // (5 + 1) * 2 - 3 = 9
```



### 高级管道实现

```javascript
// 支持异步的管道
const asyncPipe = (...fns) => (value) =>
  fns.reduce(async (acc, fn) => fn(await acc), value);

// 支持条件的管道
const conditionalPipe = (...operations) => (value) => {
  return operations.reduce((acc, operation) => {
    if (typeof operation === 'function') {
      return operation(acc);
    }
    
    if (operation.condition && operation.condition(acc)) {
      return operation.transform(acc);
    }
    
    return acc;
  }, value);
};

// 支持分支的管道
const branchingPipe = (condition, truePipe, falsePipe) => (value) => {
  return condition(value) ? truePipe(value) : falsePipe(value);
};

// 实际应用示例
const processUserData = pipe(
  // 验证用户数据
  (data) => {
    if (!data.email || !data.name) {
      throw new Error('缺少必要字段');
    }
    return data;
  },
  
  // 标准化数据
  (data) => ({
    ...data,
    email: data.email.toLowerCase().trim(),
    name: data.name.trim(),
    createdAt: new Date().toISOString()
  }),
  
  // 添加默认值
  (data) => ({
    role: 'user',
    active: true,
    ...data
  }),
  
  // 生成ID
  (data) => ({
    ...data,
    id: Math.random().toString(36).substr(2, 9)
  })
);

// 使用条件管道处理不同类型的数据
const processData = conditionalPipe(
  data => ({ ...data, processed: true }),
  {
    condition: data => data.type === 'user',
    transform: data => ({ ...data, role: 'user' })
  },
  {
    condition: data => data.type === 'admin',
    transform: data => ({ ...data, role: 'admin', permissions: ['read', 'write'] })
  },
  data => ({ ...data, timestamp: Date.now() })
);
```



### 实用管道工具

```javascript
// 管道工具集
const PipelineUtils = {
  // 调试管道
  debug: (label) => (value) => {
    console.log(`[${label}]:`, value);
    return value;
  },
  
  // 条件执行
  when: (predicate, fn) => (value) => 
    predicate(value) ? fn(value) : value,
  
  // 捕获错误
  tryCatch: (fn, errorHandler) => (value) => {
    try {
      return fn(value);
    } catch (error) {
      return errorHandler ? errorHandler(error, value) : value;
    }
  },
  
  // 并行处理
  parallel: (...fns) => async (value) => {
    const results = await Promise.all(fns.map(fn => fn(value)));
    return results;
  },
  
  // 分支处理
  branch: (predicate, trueFn, falseFn) => (value) =>
    predicate(value) ? trueFn(value) : falseFn(value),
  
  // 累积处理
  scan: (fn, initial) => (values) => {
    const results = [];
    let acc = initial;
    for (const value of values) {
      acc = fn(acc, value);
      results.push(acc);
    }
    return results;
  }
};

// 复杂数据处理管道
const processOrderData = pipe(
  PipelineUtils.debug('原始数据'),
  
  // 验证订单数据
  PipelineUtils.tryCatch(
    (order) => {
      if (!order.items || order.items.length === 0) {
        throw new Error('订单必须包含商品');
      }
      return order;
    },
    (error, order) => ({ ...order, error: error.message })
  ),
  
  // 计算总价
  PipelineUtils.when(
    order => !order.error,
    (order) => ({
      ...order,
      total: order.items.reduce((sum, item) => sum + item.price * item.quantity, 0)
    })
  ),
  
  // 应用折扣
  PipelineUtils.when(
    order => order.coupon && !order.error,
    (order) => ({
      ...order,
      discountAmount: order.total * order.coupon.discount,
      finalTotal: order.total * (1 - order.coupon.discount)
    })
  ),
  
  PipelineUtils.debug('处理结果')
);
```



##  深入理解并实现函数式编程中的 Monad 模式

### Maybe Monad 实现

```javascript
// Maybe Monad - 处理可能为空的值
class Maybe {
  constructor(value) {
    this.value = value;
  }
  
  static of(value) {
    return new Maybe(value);
  }
  
  static none() {
    return new Maybe(null);
  }
  
  isNone() {
    return this.value === null || this.value === undefined;
  }
  
  map(fn) {
    return this.isNone() ? Maybe.none() : Maybe.of(fn(this.value));
  }
  
  flatMap(fn) {
    return this.isNone() ? Maybe.none() : fn(this.value);
  }
  
  filter(predicate) {
    return this.isNone() || !predicate(this.value) ? Maybe.none() : this;
  }
  
  getOrElse(defaultValue) {
    return this.isNone() ? defaultValue : this.value;
  }
  
  fold(noneHandler, someHandler) {
    return this.isNone() ? noneHandler() : someHandler(this.value);
  }
}

// 使用示例
const safeDivide = (a, b) => 
  b === 0 ? Maybe.none() : Maybe.of(a / b);

const result = Maybe.of(10)
  .flatMap(x => safeDivide(x, 2))
  .map(x => x * 2)
  .map(x => x + 1)
  .getOrElse(0);

console.log(result); // 11
```



### Either Monad 实现

```javascript
// Either Monad - 处理可能失败的操作
class Either {
  constructor(value, isRight = true) {
    this.value = value;
    this.isRight = isRight;
  }
  
  static right(value) {
    return new Either(value, true);
  }
  
  static left(value) {
    return new Either(value, false);
  }
  
  map(fn) {
    return this.isRight ? Either.right(fn(this.value)) : this;
  }
  
  flatMap(fn) {
    return this.isRight ? fn(this.value) : this;
  }
  
  mapLeft(fn) {
    return this.isRight ? this : Either.left(fn(this.value));
  }
  
  fold(leftFn, rightFn) {
    return this.isRight ? rightFn(this.value) : leftFn(this.value);
  }
  
  getOrElse(defaultValue) {
    return this.isRight ? this.value : defaultValue;
  }
  
  orElse(alternative) {
    return this.isRight ? this : alternative;
  }
}

// 实际应用示例
const parseJSON = (str) => {
  try {
    return Either.right(JSON.parse(str));
  } catch (error) {
    return Either.left(`JSON解析错误: ${error.message}`);
  }
};

const validateUser = (user) => {
  if (!user.name) return Either.left('用户名不能为空');
  if (!user.email) return Either.left('邮箱不能为空');
  return Either.right(user);
};

const processUserData = (jsonString) =>
  parseJSON(jsonString)
    .flatMap(validateUser)
    .map(user => ({ ...user, id: Date.now() }))
    .fold(
      error => ({ error }),
      user => ({ success: true, user })
    );
```





### IO Monad 实现

```javascript
// IO Monad - 处理副作用
class IO {
  constructor(effect) {
    this.effect = effect;
  }
  
  static of(value) {
    return new IO(() => value);
  }
  
  map(fn) {
    return new IO(() => fn(this.effect()));
  }
  
  flatMap(fn) {
    return new IO(() => fn(this.effect()).effect());
  }
  
  run() {
    return this.effect();
  }
}

// IO 操作封装
const IOOperations = {
  log: (message) => new IO(() => {
    console.log(message);
    return message;
  }),
  
  readFile: (filename) => new IO(() => {
    // 模拟文件读取
    return `文件内容: ${filename}`;
  }),
  
  httpGet: (url) => new IO(async () => {
    const response = await fetch(url);
    return response.json();
  }),
  
  getCurrentTime: () => new IO(() => new Date()),
  
  randomNumber: () => new IO(() => Math.random())
};

// 组合 IO 操作
const program = IOOperations.getCurrentTime()
  .flatMap(time => IOOperations.log(`当前时间: ${time}`))
  .flatMap(() => IOOperations.randomNumber())
  .flatMap(num => IOOperations.log(`随机数: ${num}`));

// 延迟执行直到调用 run()
program.run();
```

### Task Monad 实现

```javascript
// Task Monad - 处理异步操作
class Task {
  constructor(computation) {
    this.computation = computation;
  }
  
  static of(value) {
    return new Task((resolve) => resolve(value));
  }
  
  static rejected(error) {
    return new Task((_, reject) => reject(error));
  }
  
  map(fn) {
    return new Task((resolve, reject) => {
      this.computation(
        value => resolve(fn(value)),
        reject
      );
    });
  }
  
  flatMap(fn) {
    return new Task((resolve, reject) => {
      this.computation(
        value => fn(value).computation(resolve, reject),
        reject
      );
    });
  }
  
  mapError(fn) {
    return new Task((resolve, reject) => {
      this.computation(
        resolve,
        error => reject(fn(error))
      );
    });
  }
  
  fork(errorHandler, successHandler) {
    this.computation(successHandler, errorHandler);
  }
  
  toPromise() {
    return new Promise((resolve, reject) => {
      this.computation(resolve, reject);
    });
  }
}

// Task 工具函数
const TaskUtils = {
  delay: (ms) => new Task(resolve => 
    setTimeout(() => resolve(ms), ms)),
  
  parallel: (...tasks) => new Task((resolve, reject) => {
    let completed = 0;
    const results = [];
    
    tasks.forEach((task, index) => {
      task.fork(reject, value => {
        results[index] = value;
        completed++;
        if (completed === tasks.length) {
          resolve(results);
        }
      });
    });
  }),
  
  sequence: (tasks) => tasks.reduce(
    (acc, task) => acc.flatMap(results => 
      task.map(result => [...results, result])),
    Task.of([])
  )
};

// 使用示例
const fetchUserProfile = (userId) => new Task((resolve, reject) => {
  // 模拟异步 API 调用
  setTimeout(() => {
    if (userId > 0) {
      resolve({ id: userId, name: `用户${userId}` });
    } else {
      reject(new Error('无效的用户ID'));
    }
  }, 1000);
});

const program2 = fetchUserProfile(1)
  .map(user => ({ ...user, lastLogin: new Date() }))
  .flatMap(user => 
    TaskUtils.delay(500).map(() => user)
  );

program2.fork(
  error => console.error('错误:', error),
  user => console.log('用户:', user)
);
```



## 使用函数式编程范式重构复杂业务逻辑

### 电商订单处理系统重构

```javascript
// 传统命令式实现
class TraditionalOrderProcessor {
  processOrder(order) {
    // 验证订单
    if (!order.items || order.items.length === 0) {
      throw new Error('订单不能为空');
    }
    
    // 计算价格
    let total = 0;
    for (let item of order.items) {
      if (item.price < 0 || item.quantity < 0) {
        throw new Error('商品价格或数量不能为负数');
      }
      total += item.price * item.quantity;
    }
    
    // 应用折扣
    if (order.discount && order.discount > 0 && order.discount <= 1) {
      total = total * (1 - order.discount);
    }
    
    // 计算税费
    const tax = total * 0.1;
    const finalTotal = total + tax;
    
    // 检查库存
    for (let item of order.items) {
      if (this.inventory[item.id] < item.quantity) {
        throw new Error(`商品 ${item.name} 库存不足`);
      }
    }
    
    // 更新库存
    for (let item of order.items) {
      this.inventory[item.id] -= item.quantity;
    }
    
    return {
      ...order,
      subtotal: total,
      tax: tax,
      total: finalTotal,
      status: 'processed'
    };
  }
}

// 函数式重构版本
const OrderProcessor = {
  // 验证函数
  validateOrder: (order) => {
    if (!order.items || order.items.length === 0) {
      return Either.left('订单不能为空');
    }
    
    const invalidItem = order.items.find(item => 
      item.price < 0 || item.quantity < 0);
    
    if (invalidItem) {
      return Either.left('商品价格或数量不能为负数');
    }
    
    return Either.right(order);
  },
  
  // 计算小计
  calculateSubtotal: (order) => ({
    ...order,
    subtotal: order.items.reduce((sum, item) => 
      sum + item.price * item.quantity, 0)
  }),
  
  // 应用折扣
  applyDiscount: (order) => {
    if (!order.discount || order.discount <= 0 || order.discount > 1) {
      return order;
    }
    
    const discountAmount = order.subtotal * order.discount;
    return {
      ...order,
      discountAmount,
      subtotal: order.subtotal - discountAmount
    };
  },
  
  // 计算税费
  calculateTax: (taxRate = 0.1) => (order) => ({
    ...order,
    tax: order.subtotal * taxRate,
    total: order.subtotal * (1 + taxRate)
  }),
  
  // 检查库存
  checkInventory: (inventory) => (order) => {
    const outOfStock = order.items.find(item => 
      inventory[item.id] < item.quantity);
    
    if (outOfStock) {
      return Either.left(`商品 ${outOfStock.name} 库存不足`);
    }
    
    return Either.right(order);
  },
  
  // 更新库存
  updateInventory: (inventory) => (order) => {
    const newInventory = { ...inventory };
    order.items.forEach(item => {
      newInventory[item.id] -= item.quantity;
    });
    
    return {
      order: { ...order, status: 'processed' },
      inventory: newInventory
    };
  },
  
  // 主处理流程
  processOrder: (inventory) => (order) => {
    return OrderProcessor.validateOrder(order)
      .map(OrderProcessor.calculateSubtotal)
      .map(OrderProcessor.applyDiscount)
      .map(OrderProcessor.calculateTax(0.1))
      .flatMap(OrderProcessor.checkInventory(inventory))
      .map(OrderProcessor.updateInventory(inventory));
  }
};

// 使用示例
const inventory = { item1: 10, item2: 5, item3: 20 };
const order = {
  items: [
    { id: 'item1', name: '商品1', price: 100, quantity: 2 },
    { id: 'item2', name: '商品2', price: 50, quantity: 1 }
  ],
  discount: 0.1
};

const result = OrderProcessor.processOrder(inventory)(order);
result.fold(
  error => console.error('订单处理失败:', error),
  success => console.log('订单处理成功:', success)
);
```

### 用户权限系统重构

```javascript
// 函数式权限系统
const PermissionSystem = {
  // 权限检查器
  hasPermission: (permission) => (user) => 
    user.permissions && user.permissions.includes(permission),
  
  hasRole: (role) => (user) => 
    user.roles && user.roles.includes(role),
  
  hasAnyRole: (roles) => (user) => 
    roles.some(role => PermissionSystem.hasRole(role)(user)),
  
  hasAllRoles: (roles) => (user) => 
    roles.every(role => PermissionSystem.hasRole(role)(user)),
  
  // 权限组合器
  and: (...checkers) => (user) => 
    checkers.every(checker => checker(user)),
  
  or: (...checkers) => (user) => 
    checkers.some(checker => checker(user)),
  
  not: (checker) => (user) => !checker(user),
  
  // 条件权限检查
  when: (condition, checker) => (user) => 
    condition(user) ? checker(user) : true,
  
  // 资源权限检查
  canAccess: (resource) => (user) => {
    const resourcePermissions = {
      'admin-panel': ['admin'],
      'user-management': ['admin', 'user-manager'],
      'reports': ['admin', 'manager', 'analyst'],
      'profile': [] // 所有人都能访问
    };
    
    const requiredRoles = resourcePermissions[resource] || [];
    return requiredRoles.length === 0 || 
           PermissionSystem.hasAnyRole(requiredRoles)(user);
  },
  
  // 权限装饰器
  requiresPermission: (permission) => (fn) => (user, ...args) => {
    if (!PermissionSystem.hasPermission(permission)(user)) {
      throw new Error(`缺少权限: ${permission}`);
    }
    return fn(user, ...args);
  },
  
  requiresRole: (role) => (fn) => (user, ...args) => {
    if (!PermissionSystem.hasRole(role)(user)) {
      throw new Error(`缺少角色: ${role}`);
    }
    return fn(user, ...args);
  }
};

// 权限验证管道
const createAuthorizationPipeline = (...checkers) => (user) => {
  const results = checkers.map(checker => ({
    passed: checker(user),
    checker: checker.name || 'anonymous'
  }));
  
  return {
    authorized: results.every(r => r.passed),
    results,
    user
  };
};

// 业务逻辑与权限分离
const UserOperations = {
  // 纯业务逻辑
  deleteUser: (targetUserId) => (currentUser) => ({
    action: 'delete',
    targetUserId,
    executedBy: currentUser.id,
    timestamp: new Date()
  }),
  
  updateUserRole: (targetUserId, newRole) => (currentUser) => ({
    action: 'update-role',
    targetUserId,
    newRole,
    executedBy: currentUser.id,
    timestamp: new Date()
  }),
  
  viewUserData: (targetUserId) => (currentUser) => ({
    action: 'view',
    targetUserId,
    executedBy: currentUser.id,
    timestamp: new Date()
  })
};

// 权限增强的业务操作
const SecureUserOperations = {
  deleteUser: (targetUserId) => 
    PermissionSystem.requiresRole('admin')(
      UserOperations.deleteUser(targetUserId)
    ),
  
  updateUserRole: (targetUserId, newRole) =>
    PermissionSystem.requiresPermission('manage-users')(
      UserOperations.updateUserRole(targetUserId, newRole)
    ),
  
  viewUserData: (targetUserId) => (currentUser) => {
    // 用户可以查看自己的数据，或者管理员可以查看所有数据
    const canView = PermissionSystem.or(
      user => user.id === targetUserId,
      PermissionSystem.hasRole('admin')
    );
    
    if (!canView(currentUser)) {
      throw new Error('无权查看此用户数据');
    }
    
    return UserOperations.viewUserData(targetUserId)(currentUser);
  }
};
```

### 数据验证系统重构

```javascript
// 函数式数据验证系统
const Validators = {
  // 基础验证器
  required: (message = '此字段为必填项') => (value) =>
    value != null && value !== '' ? 
      Either.right(value) : Either.left(message),
  
  minLength: (min, message = `最少需要${min}个字符`) => (value) =>
    value && value.length >= min ? 
      Either.right(value) : Either.left(message),
  
  maxLength: (max, message = `最多允许${max}个字符`) => (value) =>
    !value || value.length <= max ? 
      Either.right(value) : Either.left(message),
  
  pattern: (regex, message = '格式不正确') => (value) =>
    !value || regex.test(value) ? 
      Either.right(value) : Either.left(message),
  
  email: (message = '邮箱格式不正确') => 
    Validators.pattern(/^[^\s@]+@[^\s@]+\.[^\s@]+$/, message),
  
  phone: (message = '手机号格式不正确') =>
    Validators.pattern(/^1[3-9]\d{9}$/, message),
  
  numeric: (message = '必须是数字') => (value) =>
    !value || !isNaN(value) ? 
      Either.right(value) : Either.left(message),
  
  range: (min, max, message = `值必须在${min}到${max}之间`) => (value) =>
    !value || (value >= min && value <= max) ? 
      Either.right(value) : Either.left(message),
  
  // 复合验证器
  combine: (...validators) => (value) => {
    for (const validator of validators) {
      const result = validator(value);
      if (!result.isRight) return result;
    }
    return Either.right(value);
  },
  
  // 对象验证器
  shape: (schema) => (obj) => {
    const errors = {};
    const validated = {};
    
    for (const [key, validator] of Object.entries(schema)) {
      const result = validator(obj[key]);
      if (result.isRight) {
        validated[key] = result.value;
      } else {
        errors[key] = result.value;
      }
    }
    
    return Object.keys(errors).length === 0 ?
      Either.right(validated) : Either.left(errors);
  },
  
  // 数组验证器
  arrayOf: (itemValidator) => (arr) => {
    if (!Array.isArray(arr)) {
      return Either.left('必须是数组');
    }
    
    const results = arr.map((item, index) => ({
      index,
      result: itemValidator(item)
    }));
    
    const errors = results
      .filter(r => !r.result.isRight)
      .reduce((acc, r) => ({
        ...acc,
        [r.index]: r.result.value
      }), {});
    
    if (Object.keys(errors).length > 0) {
      return Either.left(errors);
    }
    
    return Either.right(results.map(r => r.result.value));
  }
};

// 用户注册表单验证示例
const userRegistrationSchema = Validators.shape({
  username: Validators.combine(
    Validators.required('用户名不能为空'),
    Validators.minLength(3, '用户名至少3个字符'),
    Validators.maxLength(20, '用户名最多20个字符'),
    Validators.pattern(/^[a-zA-Z0-9_]+$/, '用户名只能包含字母、数字和下划线')
  ),
  
  email: Validators.combine(
    Validators.required('邮箱不能为空'),
    Validators.email('邮箱格式不正确')
  ),
  
  password: Validators.combine(
    Validators.required('密码不能为空'),
    Validators.minLength(8, '密码至少8个字符'),
    Validators.pattern(/(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/, 
      '密码必须包含大小写字母和数字')
  ),
  
  phone: Validators.combine(
    Validators.required('手机号不能为空'),
    Validators.phone('手机号格式不正确')
  ),
  
  age: Validators.combine(
    Validators.required('年龄不能为空'),
    Validators.numeric('年龄必须是数字'),
    Validators.range(18, 120, '年龄必须在18到120之间')
  )
});

// 使用验证器
const validateUserRegistration = (userData) => 
  userRegistrationSchema(userData)
    .fold(
      errors => ({ valid: false, errors }),
      data => ({ valid: true, data })
    );
```



## 函数式状态管理的设计与实现



### 不可变状态管理器

```javascript
// 基础状态管理器
class StateManager {
  constructor(initialState = {}) {
    this._state = deepFreeze(initialState);
    this._listeners = new Set();
    this._middlewares = [];
  }
  
  // 获取当前状态
  getState() {
    return this._state;
  }
  
  // 订阅状态变化
  subscribe(listener) {
    this._listeners.add(listener);
    return () => this._listeners.delete(listener);
  }
  
  // 添加中间件
  use(middleware) {
    this._middlewares.push(middleware);
  }
  
  // 分发动作
  dispatch(action) {
    // 应用中间件
    const enhancedDispatch = this._middlewares.reduceRight(
      (next, middleware) => middleware(this)(next),
      this._dispatch.bind(this)
    );
    
    return enhancedDispatch(action);
  }
  
  _dispatch(action) {
    const prevState = this._state;
    this._state = this._reducer(this._state, action);
    
    if (this._state !== prevState) {
      this._notifyListeners();
    }
    
    return action;
  }
  
  _notifyListeners() {
    this._listeners.forEach(listener => listener(this._state));
  }
  
  // 设置根 reducer
  setReducer(reducer) {
    this._reducer = reducer;
  }
}

// Reducer 组合器
const combineReducers = (reducers) => (state = {}, action) => {
  const nextState = {};
  let hasChanged = false;
  
  for (const [key, reducer] of Object.entries(reducers)) {
    const prevStateForKey = state[key];
    const nextStateForKey = reducer(prevStateForKey, action);
    
    nextState[key] = nextStateForKey;
    hasChanged = hasChanged || nextStateForKey !== prevStateForKey;
  }
  
  return hasChanged ? nextState : state;
};

// 中间件示例
const Middlewares = {
  // 日志中间件
  logger: (store) => (next) => (action) => {
    console.group(`Action: ${action.type}`);
    console.log('Previous State:', store.getState());
    console.log('Action:', action);
    
    const result = next(action);
    
    console.log('Next State:', store.getState());
    console.groupEnd();
    
    return result;
  },
  
  // 异步中间件
  thunk: (store) => (next) => (action) => {
    if (typeof action === 'function') {
      return action(store.dispatch, store.getState);
    }
    return next(action);
  },
  
  // 错误处理中间件
  errorHandler: (store) => (next) => (action) => {
    try {
      return next(action);
    } catch (error) {
      console.error('Action dispatch error:', error);
      store.dispatch({ type: 'ERROR', payload: error.message });
      throw error;
    }
  },
  
  // 持久化中间件
  persistence: (key) => (store) => (next) => (action) => {
    const result = next(action);
    localStorage.setItem(key, JSON.stringify(store.getState()));
    return result;
  }
};

// 实际应用示例 - 购物车状态管理
const cartReducer = (state = { items: [], total: 0 }, action) => {
  switch (action.type) {
    case 'ADD_ITEM':
      const existingItem = state.items.find(item => item.id === action.payload.id);
      
      if (existingItem) {
        const updatedItems = state.items.map(item =>
          item.id === action.payload.id
            ? { ...item, quantity: item.quantity + 1 }
            : item
        );
        return {
          ...state,
          items: updatedItems,
          total: calculateTotal(updatedItems)
        };
      }
      
      const newItems = [...state.items, { ...action.payload, quantity: 1 }];
      return {
        ...state,
        items: newItems,
        total: calculateTotal(newItems)
      };
    
    case 'REMOVE_ITEM':
      const filteredItems = state.items.filter(item => item.id !== action.payload);
      return {
        ...state,
        items: filteredItems,
        total: calculateTotal(filteredItems)
      };
    
    case 'UPDATE_QUANTITY':
      const quantityUpdatedItems = state.items.map(item =>
        item.id === action.payload.id
          ? { ...item, quantity: action.payload.quantity }
          : item
      ).filter(item => item.quantity > 0);
      
      return {
        ...state,
        items: quantityUpdatedItems,
        total: calculateTotal(quantityUpdatedItems)
      };
    
    case 'CLEAR_CART':
      return { items: [], total: 0 };
    
    default:
      return state;
  }
};

const userReducer = (state = { profile: null, isLoggedIn: false }, action) => {
  switch (action.type) {
    case 'LOGIN_SUCCESS':
      return {
        ...state,
        profile: action.payload,
        isLoggedIn: true
      };
    
    case 'LOGOUT':
      return {
        ...state,
        profile: null,
        isLoggedIn: false
      };
    
    case 'UPDATE_PROFILE':
      return {
        ...state,
        profile: { ...state.profile, ...action.payload }
      };
    
    default:
      return state;
  }
};

// 工具函数
const calculateTotal = (items) =>
  items.reduce((sum, item) => sum + item.price * item.quantity, 0);

// 动作创建器
const ActionCreators = {
  // 购物车动作
  addItem: (item) => ({ type: 'ADD_ITEM', payload: item }),
  removeItem: (itemId) => ({ type: 'REMOVE_ITEM', payload: itemId }),
  updateQuantity: (itemId, quantity) => ({ 
    type: 'UPDATE_QUANTITY', 
    payload: { id: itemId, quantity } 
  }),
  clearCart: () => ({ type: 'CLEAR_CART' }),
  
  // 用户动作
  loginSuccess: (profile) => ({ type: 'LOGIN_SUCCESS', payload: profile }),
  logout: () => ({ type: 'LOGOUT' }),
  updateProfile: (updates) => ({ type: 'UPDATE_PROFILE', payload: updates }),
  
  // 异步动作
  fetchUserProfile: (userId) => async (dispatch, getState) => {
    try {
      dispatch({ type: 'FETCH_PROFILE_START' });
      
      // 模拟 API 调用
      const response = await fetch(`/api/users/${userId}`);
      const profile = await response.json();
      
      dispatch(ActionCreators.loginSuccess(profile));
    } catch (error) {
      dispatch({ type: 'FETCH_PROFILE_ERROR', payload: error.message });
    }
  }
};

// 选择器 - 从状态中派生数据
const Selectors = {
  getCartItems: (state) => state.cart.items,
  getCartTotal: (state) => state.cart.total,
  getCartItemCount: (state) => 
    state.cart.items.reduce((count, item) => count + item.quantity, 0),
  
  getUserProfile: (state) => state.user.profile,
  isUserLoggedIn: (state) => state.user.isLoggedIn,
  
  // 记忆化选择器
  getExpensiveCartData: memoize((state) => {
    return state.cart.items.map(item => ({
      ...item,
      subtotal: item.price * item.quantity,
      discounted: item.price * item.quantity * 0.9 // 10% 折扣
    }));
  })
};

// 创建和配置 store
const createStore = () => {
  const store = new StateManager({
    cart: { items: [], total: 0 },
    user: { profile: null, isLoggedIn: false }
  });
  
  const rootReducer = combineReducers({
    cart: cartReducer,
    user: userReducer
  });
  
  store.setReducer(rootReducer);
  
  // 添加中间件
  store.use(Middlewares.logger);
  store.use(Middlewares.thunk);
  store.use(Middlewares.errorHandler);
  
  return store;
};

// 使用示例
const store = createStore();

// 订阅状态变化
const unsubscribe = store.subscribe((state) => {
  console.log('状态更新:', state);
});

// 分发动作
store.dispatch(ActionCreators.addItem({ id: 1, name: '商品1', price: 100 }));
store.dispatch(ActionCreators.addItem({ id: 2, name: '商品2', price: 200 }));
store.dispatch(ActionCreators.updateQuantity(1, 3));

// 异步动作
store.dispatch(ActionCreators.fetchUserProfile(123));

// 获取派生数据
const cartItems = Selectors.getCartItems(store.getState());
const cartTotal = Selectors.getCartTotal(store.getState());
const itemCount = Selectors.getCartItemCount(store.getState());
```



### React 集成示例

```javascript
// React Hook 集成
const useSelector = (selector) => {
  const [state, setState] = React.useState(() => selector(store.getState()));
  
  React.useEffect(() => {
    const unsubscribe = store.subscribe((newState) => {
      const selectedState = selector(newState);
      setState(selectedState);
    });
    
    return unsubscribe;
  }, [selector]);
  
  return state;
};

const useDispatch = () => {
  return React.useCallback((action) => store.dispatch(action), []);
};

// React 组件示例
const ShoppingCart = () => {
  const cartItems = useSelector(Selectors.getCartItems);
  const cartTotal = useSelector(Selectors.getCartTotal);
  const dispatch = useDispatch();
  
  const handleAddItem = (item) => {
    dispatch(ActionCreators.addItem(item));
  };
  
  const handleRemoveItem = (itemId) => {
    dispatch(ActionCreators.removeItem(itemId));
  };
  
  const handleUpdateQuantity = (itemId, quantity) => {
    dispatch(ActionCreators.updateQuantity(itemId, quantity));
  };
  
  return (
    <div>
      <h2>购物车</h2>
      {cartItems.map(item => (
        <div key={item.id}>
          <span>{item.name} - ¥{item.price} x {item.quantity}</span>
          <button onClick={() => handleUpdateQuantity(item.id, item.quantity + 1)}>
            +
          </button>
          <button onClick={() => handleUpdateQuantity(item.id, item.quantity - 1)}>
            -
          </button>
          <button onClick={() => handleRemoveItem(item.id)}>
            删除
          </button>
        </div>
      ))}
      <div>总计: ¥{cartTotal}</div>
    </div>
  );
};
```

## 

## 总结

函数式编程为 JavaScript 开发带来了以下核心优势：

### 主要收益

1. **代码可预测性**: 纯函数和不可变数据确保了相同输入总是产生相同输出
2. **易于测试**: 纯函数易于单元测试，无需模拟复杂的状态
3. **代码复用**: 高阶函数和函数组合提高了代码的模块化和复用性
4. **并发安全**: 不可变数据结构天然线程安全
5. **错误处理**: Monad 模式提供了优雅的错误处理方式
6. **状态管理**: 函数式状态管理使应用状态变化可追踪和可预测

### 实践建议

1. **渐进式采用**: 从小的工具函数开始，逐步引入函数式概念
2. **性能考虑**: 合理使用记忆化和结构共享优化性能
3. **团队培训**: 确保团队成员理解函数式编程的核心概念
4. **工具支持**: 使用 TypeScript 等工具提供更好的类型安全
5. **测试驱动**: 利用函数式编程的可测试性，采用测试驱动开发



# 前端架构设计

## 大型 JavaScript 应用的模块化设计与最佳实践

### 模块化设计原则

**职责单一原则 (SRP)**

```typescript
// ❌ 不好的设计 - 一个模块承担多个职责
class UserManager {
  validateUser(user: User) { /* 验证逻辑 */ }
  saveUser(user: User) { /* 存储逻辑 */ }
  sendEmail(user: User) { /* 邮件逻辑 */ }
}

// ✅ 好的设计 - 职责分离
class UserValidator {
  validate(user: User): ValidationResult { /* 只负责验证 */ }
}

class UserRepository {
  save(user: User): Promise<void> { /* 只负责存储 */ }
}

class EmailService {
  sendWelcomeEmail(user: User): Promise<void> { /* 只负责邮件 */ }
}
```



**依赖倒置原则 (DIP)**

```typescript
// 定义抽象接口
interface IUserRepository {
  findById(id: string): Promise<User | null>;
  save(user: User): Promise<void>;
}

// 业务逻辑依赖抽象而非具体实现
class UserService {
  constructor(private userRepo: IUserRepository) {}
  
  async updateUser(id: string, updates: Partial<User>) {
    const user = await this.userRepo.findById(id);
    if (!user) throw new Error('User not found');
    
    Object.assign(user, updates);
    await this.userRepo.save(user);
  }
}

// 具体实现
class LocalStorageUserRepository implements IUserRepository {
  async findById(id: string): Promise<User | null> {
    const data = localStorage.getItem(`user:${id}`);
    return data ? JSON.parse(data) : null;
  }
  
  async save(user: User): Promise<void> {
    localStorage.setItem(`user:${user.id}`, JSON.stringify(user));
  }
}
```



### 模块组织策略

**按功能划分 (Feature-based)**

```
src/
├── features/
│   ├── user/
│   │   ├── components/
│   │   ├── services/
│   │   ├── types/
│   │   └── index.ts
│   ├── product/
│   └── order/
├── shared/
│   ├── components/
│   ├── utils/
│   └── types/
└── core/
    ├── api/
    ├── store/
    └── router/
```

**模块边界定义**

```typescript
// features/user/index.ts - 明确的模块边界
export { UserService } from './services/UserService';
export { UserRepository } from './services/UserRepository';
export { UserProfile } from './components/UserProfile';
export type { User, UserPreferences } from './types';

// 内部实现不对外暴露
// export { InternalUserCache } from './services/InternalUserCache'; //
```



## 前端分层架构与关注点分离

### 三层架构模式

```typescript
// Presentation Layer - 表现层
class UserController {
  constructor(
    private userService: UserService,
    private validator: UserValidator
  ) {}

  async handleUserCreation(req: CreateUserRequest): Promise<UserResponse> {
    // 输入验证
    const validationResult = this.validator.validateCreateRequest(req);
    if (!validationResult.isValid) {
      throw new ValidationError(validationResult.errors);
    }

    // 调用业务层
    const user = await this.userService.createUser({
      name: req.name,
      email: req.email,
      preferences: req.preferences
    });

    // 数据转换
    return this.mapToResponse(user);
  }
}

// Business Logic Layer - 业务逻辑层
class UserService {
  constructor(
    private userRepo: IUserRepository,
    private emailService: IEmailService,
    private eventBus: IEventBus
  ) {}

  async createUser(userData: CreateUserData): Promise<User> {
    // 业务规则检查
    await this.validateBusinessRules(userData);
    
    // 创建用户实体
    const user = new User({
      id: generateId(),
      ...userData,
      createdAt: new Date(),
      status: UserStatus.ACTIVE
    });

    // 持久化
    await this.userRepo.save(user);
    
    // 发送事件
    this.eventBus.publish(new UserCreatedEvent(user));
    
    // 发送欢迎邮件
    await this.emailService.sendWelcomeEmail(user);
    
    return user;
  }
}

// Data Access Layer - 数据访问层
class UserRepository implements IUserRepository {
  constructor(private apiClient: ApiClient) {}

  async save(user: User): Promise<void> {
    await this.apiClient.post('/users', {
      id: user.id,
      name: user.name,
      email: user.email,
      preferences: user.preferences,
      createdAt: user.createdAt.toISOString(),
      status: user.status
    });
  }

  async findById(id: string): Promise<User | null> {
    try {
      const response = await this.apiClient.get(`/users/${id}`);
      return this.mapToEntity(response.data);
    } catch (error) {
      if (error.status === 404) return null;
      throw error;
    }
  }
}
```



### MVC/MVP/MVVM 模式实现

**MVVM 模式示例**

```typescript
// Model
class UserModel {
  private _user = signal<User | null>(null);
  private _loading = signal(false);
  private _error = signal<string | null>(null);

  get user() { return this._user.asReadonly(); }
  get loading() { return this._loading.asReadonly(); }
  get error() { return this._error.asReadonly(); }

  async loadUser(id: string) {
    this._loading.set(true);
    this._error.set(null);
    
    try {
      const user = await this.userService.getUser(id);
      this._user.set(user);
    } catch (error) {
      this._error.set(error.message);
    } finally {
      this._loading.set(false);
    }
  }
}

// ViewModel
class UserProfileViewModel {
  constructor(
    private userModel: UserModel,
    private validationService: ValidationService
  ) {}

  // 计算属性
  get displayName() {
    return computed(() => {
      const user = this.userModel.user();
      return user ? `${user.firstName} ${user.lastName}` : 'Unknown User';
    });
  }

  get canEdit() {
    return computed(() => {
      const user = this.userModel.user();
      return user?.status === UserStatus.ACTIVE;
    });
  }

  // 用户交互逻辑
  async updateProfile(updates: Partial<User>) {
    const validation = this.validationService.validate(updates);
    if (!validation.isValid) {
      throw new ValidationError(validation.errors);
    }

    await this.userModel.updateUser(updates);
  }
}

// View
function UserProfileView({ viewModel }: { viewModel: UserProfileViewModel }) {
  const user = viewModel.userModel.user();
  const loading = viewModel.userModel.loading();
  const displayName = viewModel.displayName();
  const canEdit = viewModel.canEdit();

  if (loading) return <LoadingSpinner />;

  return (
    <div className="user-profile">
      <h1>{displayName}</h1>
      {canEdit && (
        <EditButton onClick={() => viewModel.startEditing()} />
      )}
    </div>
  );
}
```



## 领域驱动设计 (DDD) 在前端中的应用

### 领域模型设计

```typescript
// 值对象 (Value Objects)
class Email {
  constructor(private readonly value: string) {
    if (!this.isValid(value)) {
      throw new Error('Invalid email format');
    }
  }

  private isValid(email: string): boolean {
    return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
  }

  toString(): string {
    return this.value;
  }

  equals(other: Email): boolean {
    return this.value === other.value;
  }
}

class Money {
  constructor(
    private readonly amount: number,
    private readonly currency: string
  ) {
    if (amount < 0) throw new Error('Amount cannot be negative');
  }

  add(other: Money): Money {
    if (this.currency !== other.currency) {
      throw new Error('Cannot add different currencies');
    }
    return new Money(this.amount + other.amount, this.currency);
  }

  toString(): string {
    return `${this.amount} ${this.currency}`;
  }
}

// 实体 (Entities)
class User {
  constructor(
    private readonly id: UserId,
    private name: string,
    private email: Email,
    private preferences: UserPreferences
  ) {}

  updateEmail(newEmail: Email): void {
    // 业务规则：只有验证过的用户才能更改邮箱
    if (!this.isVerified) {
      throw new Error('Unverified users cannot change email');
    }
    this.email = newEmail;
  }

  updatePreferences(preferences: Partial<UserPreferences>): void {
    this.preferences = { ...this.preferences, ...preferences };
  }

  get isVerified(): boolean {
    return this.preferences.emailVerified;
  }
}

// 聚合根 (Aggregate Root)
class Order {
  private constructor(
    private readonly id: OrderId,
    private readonly customerId: CustomerId,
    private items: OrderItem[],
    private status: OrderStatus,
    private readonly createdAt: Date
  ) {}

  static create(customerId: CustomerId, items: OrderItem[]): Order {
    if (items.length === 0) {
      throw new Error('Order must have at least one item');
    }

    return new Order(
      OrderId.generate(),
      customerId,
      items,
      OrderStatus.PENDING,
      new Date()
    );
  }

  addItem(item: OrderItem): void {
    if (this.status !== OrderStatus.PENDING) {
      throw new Error('Cannot modify confirmed order');
    }
    this.items.push(item);
  }

  confirm(): void {
    if (this.items.length === 0) {
      throw new Error('Cannot confirm empty order');
    }
    this.status = OrderStatus.CONFIRMED;
  }

  get total(): Money {
    return this.items.reduce(
      (sum, item) => sum.add(item.price),
      new Money(0, 'USD')
    );
  }
}
```



### 领域服务和应用服务

```typescript
// 领域服务 - 处理跨实体的业务逻辑
class OrderPricingService {
  calculateDiscount(order: Order, customer: Customer): Money {
    let discount = new Money(0, 'USD');

    // VIP 客户折扣
    if (customer.isVip) {
      discount = discount.add(order.total.multiply(0.1));
    }

    // 大订单折扣
    if (order.total.amount > 1000) {
      discount = discount.add(new Money(50, 'USD'));
    }

    return discount;
  }
}

// 应用服务 - 协调领域对象完成用例
class OrderApplicationService {
  constructor(
    private orderRepo: IOrderRepository,
    private customerRepo: ICustomerRepository,
    private pricingService: OrderPricingService,
    private eventBus: IEventBus
  ) {}

  async createOrder(command: CreateOrderCommand): Promise<OrderId> {
    // 获取客户信息
    const customer = await this.customerRepo.findById(command.customerId);
    if (!customer) {
      throw new Error('Customer not found');
    }

    // 创建订单
    const order = Order.create(command.customerId, command.items);

    // 应用折扣
    const discount = this.pricingService.calculateDiscount(order, customer);
    order.applyDiscount(discount);

    // 保存订单
    await this.orderRepo.save(order);

    // 发布事件
    this.eventBus.publish(new OrderCreatedEvent(order.id, customer.id));

    return order.id;
  }
}
```



## 前端整洁架构 (Clean Architecture) 实现

### 架构分层

```typescript
// Entities - 企业业务规则
export class User {
  constructor(
    public readonly id: string,
    public name: string,
    public email: string,
    private createdAt: Date
  ) {}

  updateName(newName: string): void {
    if (!newName.trim()) {
      throw new Error('Name cannot be empty');
    }
    this.name = newName;
  }

  get age(): number {
    const now = new Date();
    return now.getFullYear() - this.createdAt.getFullYear();
  }
}

// Use Cases - 应用业务规则
export interface IUserRepository {
  findById(id: string): Promise<User | null>;
  save(user: User): Promise<void>;
  findByEmail(email: string): Promise<User | null>;
}

export interface IEmailService {
  sendWelcomeEmail(user: User): Promise<void>;
}

export class CreateUserUseCase {
  constructor(
    private userRepo: IUserRepository,
    private emailService: IEmailService
  ) {}

  async execute(request: CreateUserRequest): Promise<User> {
    // 检查邮箱是否已存在
    const existingUser = await this.userRepo.findByEmail(request.email);
    if (existingUser) {
      throw new Error('Email already exists');
    }

    // 创建用户
    const user = new User(
      generateId(),
      request.name,
      request.email,
      new Date()
    );

    // 保存用户
    await this.userRepo.save(user);

    // 发送欢迎邮件
    await this.emailService.sendWelcomeEmail(user);

    return user;
  }
}

// Interface Adapters - 接口适配器
export class UserController {
  constructor(private createUserUseCase: CreateUserUseCase) {}

  async createUser(httpRequest: HttpRequest): Promise<HttpResponse> {
    try {
      const user = await this.createUserUseCase.execute({
        name: httpRequest.body.name,
        email: httpRequest.body.email
      });

      return {
        statusCode: 201,
        body: {
          id: user.id,
          name: user.name,
          email: user.email
        }
      };
    } catch (error) {
      return {
        statusCode: 400,
        body: { error: error.message }
      };
    }
  }
}

// Frameworks & Drivers - 框架和驱动
export class ApiUserRepository implements IUserRepository {
  constructor(private httpClient: HttpClient) {}

  async findById(id: string): Promise<User | null> {
    try {
      const response = await this.httpClient.get(`/users/${id}`);
      return new User(
        response.data.id,
        response.data.name,
        response.data.email,
        new Date(response.data.createdAt)
      );
    } catch (error) {
      if (error.status === 404) return null;
      throw error;
    }
  }

  async save(user: User): Promise<void> {
    await this.httpClient.post('/users', {
      id: user.id,
      name: user.name,
      email: user.email
    });
  }
}
```



###  依赖注入容器

```typescript
// 依赖注入容器
class Container {
  private services = new Map<string, any>();
  private factories = new Map<string, () => any>();

  register<T>(name: string, factory: () => T): void {
    this.factories.set(name, factory);
  }

  get<T>(name: string): T {
    if (this.services.has(name)) {
      return this.services.get(name);
    }

    const factory = this.factories.get(name);
    if (!factory) {
      throw new Error(`Service ${name} not registered`);
    }

    const instance = factory();
    this.services.set(name, instance);
    return instance;
  }
}

// 配置依赖注入
const container = new Container();

container.register('httpClient', () => new HttpClient(API_BASE_URL));
container.register('userRepository', () => 
  new ApiUserRepository(container.get('httpClient'))
);
container.register('emailService', () => new EmailService());
container.register('createUserUseCase', () => 
  new CreateUserUseCase(
    container.get('userRepository'),
    container.get('emailService')
  )
);
container.register('userController', () => 
  new UserController(container.get('createUserUseCase'))
);
```



##  基于事件的架构设计与实现

### 事件驱动架构

```typescript
// 事件定义
abstract class DomainEvent {
  constructor(
    public readonly aggregateId: string,
    public readonly occurredAt: Date = new Date()
  ) {}
}

class UserRegisteredEvent extends DomainEvent {
  constructor(
    aggregateId: string,
    public readonly email: string,
    public readonly name: string
  ) {
    super(aggregateId);
  }
}

class OrderPlacedEvent extends DomainEvent {
  constructor(
    aggregateId: string,
    public readonly customerId: string,
    public readonly total: number
  ) {
    super(aggregateId);
  }
}

// 事件总线
interface IEventBus {
  publish(event: DomainEvent): Promise<void>;
  subscribe<T extends DomainEvent>(
    eventType: new (...args: any[]) => T,
    handler: (event: T) => Promise<void>
  ): void;
}

class InMemoryEventBus implements IEventBus {
  private handlers = new Map<string, ((event: DomainEvent) => Promise<void>)[]>();

  async publish(event: DomainEvent): Promise<void> {
    const eventType = event.constructor.name;
    const eventHandlers = this.handlers.get(eventType) || [];
    
    await Promise.all(
      eventHandlers.map(handler => handler(event))
    );
  }

  subscribe<T extends DomainEvent>(
    eventType: new (...args: any[]) => T,
    handler: (event: T) => Promise<void>
  ): void {
    const typeName = eventType.name;
    const handlers = this.handlers.get(typeName) || [];
    handlers.push(handler as (event: DomainEvent) => Promise<void>);
    this.handlers.set(typeName, handlers);
  }
}

// 事件处理器
class WelcomeEmailHandler {
  constructor(private emailService: IEmailService) {}

  async handle(event: UserRegisteredEvent): Promise<void> {
    await this.emailService.sendWelcomeEmail({
      to: event.email,
      name: event.name
    });
  }
}

class UserAnalyticsHandler {
  constructor(private analyticsService: IAnalyticsService) {}

  async handle(event: UserRegisteredEvent): Promise<void> {
    await this.analyticsService.track('user_registered', {
      userId: event.aggregateId,
      email: event.email,
      timestamp: event.occurredAt
    });
  }
}

// 事件订阅配置
const eventBus = new InMemoryEventBus();
const welcomeEmailHandler = new WelcomeEmailHandler(emailService);
const analyticsHandler = new UserAnalyticsHandler(analyticsService);

eventBus.subscribe(UserRegisteredEvent, event => 
  welcomeEmailHandler.handle(event)
);
eventBus.subscribe(UserRegisteredEvent, event => 
  analyticsHandler.handle(event)
);
```



### CQRS (命令查询责任分离)

```typescript
// 命令定义
abstract class Command {
  constructor(public readonly id: string = generateId()) {}
}

class CreateUserCommand extends Command {
  constructor(
    public readonly name: string,
    public readonly email: string
  ) {
    super();
  }
}

class UpdateUserCommand extends Command {
  constructor(
    public readonly userId: string,
    public readonly updates: Partial<{name: string; email: string}>
  ) {
    super();
  }
}

// 查询定义
abstract class Query<TResult> {
  constructor(public readonly id: string = generateId()) {}
}

class GetUserQuery extends Query<User | null> {
  constructor(public readonly userId: string) {
    super();
  }
}

class GetUserListQuery extends Query<User[]> {
  constructor(
    public readonly page: number = 1,
    public readonly limit: number = 10
  ) {
    super();
  }
}

// 命令处理器
interface ICommandHandler<TCommand extends Command> {
  handle(command: TCommand): Promise<void>;
}

class CreateUserCommandHandler implements ICommandHandler<CreateUserCommand> {
  constructor(
    private userRepo: IUserRepository,
    private eventBus: IEventBus
  ) {}

  async handle(command: CreateUserCommand): Promise<void> {
    const user = new User(
      generateId(),
      command.name,
      command.email,
      new Date()
    );

    await this.userRepo.save(user);

    await this.eventBus.publish(
      new UserRegisteredEvent(user.id, user.email, user.name)
    );
  }
}

// 查询处理器
interface IQueryHandler<TQuery extends Query<TResult>, TResult> {
  handle(query: TQuery): Promise<TResult>;
}

class GetUserQueryHandler implements IQueryHandler<GetUserQuery, User | null> {
  constructor(private userRepo: IUserRepository) {}

  async handle(query: GetUserQuery): Promise<User | null> {
    return this.userRepo.findById(query.userId);
  }
}

// 命令/查询总线
class CommandBus {
  private handlers = new Map<string, ICommandHandler<any>>();

  register<T extends Command>(
    commandType: new (...args: any[]) => T,
    handler: ICommandHandler<T>
  ): void {
    this.handlers.set(commandType.name, handler);
  }

  async execute<T extends Command>(command: T): Promise<void> {
    const handler = this.handlers.get(command.constructor.name);
    if (!handler) {
      throw new Error(`No handler for command ${command.constructor.name}`);
    }
    await handler.handle(command);
  }
}

class QueryBus {
  private handlers = new Map<string, IQueryHandler<any, any>>();

  register<TQuery extends Query<TResult>, TResult>(
    queryType: new (...args: any[]) => TQuery,
    handler: IQueryHandler<TQuery, TResult>
  ): void {
    this.handlers.set(queryType.name, handler);
  }

  async execute<TQuery extends Query<TResult>, TResult>(
    query: TQuery
  ): Promise<TResult> {
    const handler = this.handlers.get(query.constructor.name);
    if (!handler) {
      throw new Error(`No handler for query ${query.constructor.name}`);
    }
    return handler.handle(query);
  }
}
```





## 大型 SPA 应用状态管理架构

### 状态管理模式

typescript

```typescript
// 状态切片设计
interface UserState {
  entities: Record<string, User>;
  currentUserId: string | null;
  loading: boolean;
  error: string | null;
}

interface ProductState {
  entities: Record<string, Product>;
  categories: Category[];
  filters: ProductFilters;
  pagination: PaginationState;
}

interface AppState {
  user: UserState;
  product: ProductState;
  cart: CartState;
  ui: UIState;
}

// 动作定义
type UserAction =
  | { type: 'USER_LOAD_START' }
  | { type: 'USER_LOAD_SUCCESS'; payload: User }
  | { type: 'USER_LOAD_ERROR'; payload: string }
  | { type: 'USER_UPDATE'; payload: Partial<User> };

// 状态管理器
class StateManager {
  private state: AppState;
  private listeners: Set<() => void> = new Set();

  constructor(initialState: AppState) {
    this.state = initialState;
  }

  getState(): AppState {
    return this.state;
  }

  dispatch(action: any): void {
    this.state = this.reducer(this.state, action);
    this.notifyListeners();
  }

  subscribe(listener: () => void): () => void {
    this.listeners.add(listener);
    return () => this.listeners.delete(listener);
  }

  private reducer(state: AppState, action: any): AppState {
    return {
      user: this.userReducer(state.user, action),
      product: this.productReducer(state.product, action),
      cart: this.cartReducer(state.cart, action),
      ui: this.uiReducer(state.ui, action)
    };
  }

  private userReducer(state: UserState, action: UserAction): UserState {
    switch (action.type) {
      case 'USER_LOAD_START':
        return { ...state, loading: true, error: null };
      
      case 'USER_LOAD_SUCCESS':
        return {
          ...state,
          entities: { ...state.entities, [action.payload.id]: action.payload },
          currentUserId: action.payload.id,
          loading: false,
          error: null
        };
      
      case 'USER_LOAD_ERROR':
        return { ...state, loading: false, error: action.payload };
      
      default:
        return state;
    }
  }

  private notifyListeners(): void {
    this.listeners.forEach(listener => listener());
  }
}
```

### 状态规范化

typescript

```typescript
// 规范化状态结构
interface NormalizedState<T> {
  byId: Record<string, T>;
  allIds: string[];
}

interface NormalizedAppState {
  users: NormalizedState<User>;
  products: NormalizedState<Product>;
  orders: NormalizedState<Order>;
  // 关系数据
  userOrders: Record<string, string[]>; // userId -> orderIds
  orderItems: Record<string, string[]>; // orderId -> productIds
}

// 规范化工具
class StateNormalizer {
  static normalizeUsers(users: User[]): NormalizedState<User> {
    const byId: Record<string, User> = {};
    const allIds: string[] = [];

    users.forEach(user => {
      byId[user.id] = user;
      allIds.push(user.id);
    });

    return { byId, allIds };
  }

  static denormalizeUser(
    state: NormalizedAppState,
    userId: string
  ): User | undefined {
    return state.users.byId[userId];
  }

  static getUserOrders(
    state: NormalizedAppState,
    userId: string
  ): Order[] {
    const orderIds = state.userOrders[userId] || [];
    return orderIds
      .map(id => state.orders.byId[id])
      .filter(Boolean);
  }
}

// 选择器
class Selectors {
  static getUser = (state: NormalizedAppState, userId: string) =>
    state.users.byId[userId];

  static getAllUsers = (state: NormalizedAppState) =>
    state.users.allIds.map(id => state.users.byId[id]);

  static getUserWithOrders = (state: NormalizedAppState, userId: string) => {
    const user = Selectors.getUser(state, userId);
    if (!user) return null;

    const orders = StateNormalizer.getUserOrders(state, userId);
    return { ...user, orders };
  };

  // 记忆化选择器
  static createMemoizedSelector<TArgs extends any[], TResult>(
    selector: (...args: TArgs) => TResult
  ) {
    const cache = new Map<string, TResult>();

    return (...args: TArgs): TResult => {
      const key = JSON.stringify(args);
      
      if (cache.has(key)) {
        return cache.get(key)!;
      }

      const result = selector(...args);
      cache.set(key, result);
      return result;
    };
  }
}
```



## 渐进式前端架构与微前端设计



### 渐进式架构演进

```typescript
// 阶段1：单体应用
class MonolithicApp {
  private router: Router;
  private userModule: UserModule;
  private productModule: ProductModule;
  private orderModule: OrderModule;

  constructor() {
    this.router = new Router();
    this.userModule = new UserModule();
    this.productModule = new ProductModule();
    this.orderModule = new OrderModule();
    
    this.setupRoutes();
  }

  private setupRoutes() {
    this.router.add('/users/*', this.userModule.handle);
    this.router.add('/products/*', this.productModule.handle);
    this.router.add('/orders/*', this.orderModule.handle);
  }
}

// 阶段2：模块化重构
interface ModuleInterface {
  initialize(): Promise<void>;
  destroy(): Promise<void>;
  getRoutes(): RouteConfig[];
  getExports(): Record<string, any>;
}

class ModularApp {
  private modules = new Map<string, ModuleInterface>();
  private moduleLoader: ModuleLoader;

  constructor() {
    this.moduleLoader = new ModuleLoader();
  }

  async loadModule(name: string): Promise<void> {
    const module = await this.moduleLoader.load(name);
    this.modules.set(name, module);
    await module.initialize();
  }

  async unloadModule(name: string): Promise<void> {
    const module = this.modules.get(name);
    if (module) {
      await module.destroy();
      this.modules.delete(name);
    }
  }
}

// 阶段3：微前端架构
class MicrofrontendApp {
  private container: HTMLElement;
  private applications = new Map<string, MicrofrontendApplication>();

  constructor(container: HTMLElement) {
    this.container = container;
  }

  async mountApplication(config: MicrofrontendConfig): Promise<void> {
    const app = new MicrofrontendApplication(config);
    await app.mount(this.container);
    this.applications.set(config.name, app);
  }

  async unmountApplication(name: string): Promise<void> {
    const app = this.applications.get(name);
    if (app) {
      await app.unmount();
      this.applications.delete(name);
    }
  }
}
```

### 7.2 微前端实现模式

**Module Federation 模式**

```typescript
// 主应用配置
const ModuleFederationPlugin = require('@module-federation/webpack');

module.exports = {
  plugins: [
    new ModuleFederationPlugin({
      name: 'shell',
      remotes: {
        userApp: 'userApp@http://localhost:3001/remoteEntry.js',
        productApp: 'productApp@http://localhost:3002/remoteEntry.js',
        orderApp: 'orderApp@http://localhost:3003/remoteEntry.js'
      },
      shared: {
        react: { singleton: true },
        'react-dom': { singleton: true }
      }
    })
  ]
};

// 主应用路由配置
const UserApp = React.lazy(() => import('userApp/UserApp'));
const ProductApp = React.lazy(() => import('productApp/ProductApp'));
const OrderApp = React.lazy(() => import('orderApp/OrderApp'));

function ShellApp() {
  return (
    <Router>
      <div className="shell-layout">
        <Header />
        <Suspense fallback={<Loading />}>
          <Routes>
            <Route path="/users/*" element={<UserApp />} />
            <Route path="/products/*" element={<ProductApp />} />
            <Route path="/orders/*" element={<OrderApp />} />
          </Routes>
        </Suspense>
      </div>
    </Router>
  );
}

// 子应用导出
// userApp/src/bootstrap.tsx
const UserApp = () => {
  return (
    <Routes>
      <Route path="/" element={<UserList />} />
      <Route path="/:id" element={<UserDetail />} />
      <Route path="/create" element={<CreateUser />} />
    </Routes>
  );
};

export default UserApp;
```

**Single-SPA 模式**

```typescript
// 主应用注册
import { registerApplication, start } from 'single-spa';

registerApplication({
  name: 'user-app',
  app: () => import('./user-app/main.js'),
  activeWhen: location => location.pathname.startsWith('/users'),
  customProps: {
    authToken: getAuthToken(),
    apiBaseUrl: API_BASE_URL
  }
});

registerApplication({
  name: 'product-app',
  app: () => import('./product-app/main.js'),
  activeWhen: '/products'
});

start();

// 子应用实现
// user-app/main.js
let userAppInstance;

export async function mount(props) {
  const { domElement, authToken, apiBaseUrl } = props;
  
  userAppInstance = new UserApp({
    container: domElement,
    authToken,
    apiBaseUrl
  });
  
  await userAppInstance.render();
}

export async function unmount(props) {
  if (userAppInstance) {
    await userAppInstance.destroy();
    userAppInstance = null;
  }
}

export async function bootstrap() {
  // 初始化代码
}
```

**Web Components 模式**

```typescript
// 微前端 Web Component
class UserMicrofrontend extends HTMLElement {
  private userApp: UserApp | null = null;
  private shadow: ShadowRoot;

  constructor() {
    super();
    this.shadow = this.attachShadow({ mode: 'open' });
  }

  static get observedAttributes() {
    return ['auth-token', 'api-base-url', 'user-id'];
  }

  async connectedCallback() {
    const authToken = this.getAttribute('auth-token');
    const apiBaseUrl = this.getAttribute('api-base-url');
    const userId = this.getAttribute('user-id');

    // 加载样式隔离
    const style = document.createElement('style');
    style.textContent = await this.loadStyles();
    this.shadow.appendChild(style);

    // 创建应用容器
    const container = document.createElement('div');
    this.shadow.appendChild(container);

    // 初始化应用
    this.userApp = new UserApp({
      container,
      authToken,
      apiBaseUrl,
      userId
    });

    await this.userApp.mount();
  }

  async disconnectedCallback() {
    if (this.userApp) {
      await this.userApp.unmount();
      this.userApp = null;
    }
  }

  attributeChangedCallback(name: string, oldValue: string, newValue: string) {
    if (this.userApp && oldValue !== newValue) {
      this.userApp.updateProps({ [name]: newValue });
    }
  }

  private async loadStyles(): Promise<string> {
    const response = await fetch('/user-app/styles.css');
    return response.text();
  }
}

customElements.define('user-microfrontend', UserMicrofrontend);

// 主应用使用
function MainApp() {
  const authToken = useAuthToken();
  const apiBaseUrl = useApiBaseUrl();

  return (
    <div>
      <Header />
      <main>
        <user-microfrontend
          auth-token={authToken}
          api-base-url={apiBaseUrl}
          user-id="123"
        />
      </main>
    </div>
  );
}
```

### 7.3 微前端通信机制

```typescript
// 事件总线通信
class MicrofrontendEventBus {
  private eventTarget = new EventTarget();

  publish(eventName: string, data: any): void {
    const event = new CustomEvent(eventName, { detail: data });
    this.eventTarget.dispatchEvent(event);
  }

  subscribe(eventName: string, handler: (data: any) => void): () => void {
    const eventHandler = (event: CustomEvent) => handler(event.detail);
    this.eventTarget.addEventListener(eventName, eventHandler);
    
    return () => this.eventTarget.removeEventListener(eventName, eventHandler);
  }
}

// 全局状态共享
class SharedState {
  private state = new Map<string, any>();
  private subscribers = new Map<string, Set<(value: any) => void>>();

  set<T>(key: string, value: T): void {
    this.state.set(key, value);
    this.notifySubscribers(key, value);
  }

  get<T>(key: string): T | undefined {
    return this.state.get(key);
  }

  subscribe<T>(key: string, callback: (value: T) => void): () => void {
    if (!this.subscribers.has(key)) {
      this.subscribers.set(key, new Set());
    }
    
    this.subscribers.get(key)!.add(callback);
    
    return () => {
      const keySubscribers = this.subscribers.get(key);
      if (keySubscribers) {
        keySubscribers.delete(callback);
      }
    };
  }

  private notifySubscribers(key: string, value: any): void {
    const keySubscribers = this.subscribers.get(key);
    if (keySubscribers) {
      keySubscribers.forEach(callback => callback(value));
    }
  }
}

// API 网关模式
class MicrofrontendApiGateway {
  private services = new Map<string, ApiService>();

  registerService(name: string, service: ApiService): void {
    this.services.set(name, service);
  }

  async callService(serviceName: string, method: string, ...args: any[]): Promise<any> {
    const service = this.services.get(serviceName);
    if (!service) {
      throw new Error(`Service ${serviceName} not found`);
    }

    if (typeof service[method] !== 'function') {
      throw new Error(`Method ${method} not found on service ${serviceName}`);
    }

    return service[method](...args);
  }
}

// 使用示例
const eventBus = new MicrofrontendEventBus();
const sharedState = new SharedState();
const apiGateway = new MicrofrontendApiGateway();

// 用户应用
class UserApp {
  constructor() {
    // 监听购物车变化
    eventBus.subscribe('cart:item-added', (item) => {
      this.showNotification(`${item.name} added to cart`);
    });

    // 监听用户状态变化
    sharedState.subscribe('currentUser', (user) => {
      this.updateUserDisplay(user);
    });
  }

  onUserLogin(user: User) {
    // 更新共享状态
    sharedState.set('currentUser', user);
    
    // 发布事件
    eventBus.publish('user:logged-in', user);
  }
}

// 购物车应用
class CartApp {
  constructor() {
    // 监听用户登录
    eventBus.subscribe('user:logged-in', (user) => {
      this.loadUserCart(user.id);
    });
  }

  addToCart(item: CartItem) {
    // 添加到购物车逻辑
    this.items.push(item);
    
    // 发布事件
    eventBus.publish('cart:item-added', item);
    
    // 更新共享状态
    sharedState.set('cartCount', this.items.length);
  }
}
```

### 7.4 微前端最佳实践

**应用隔离和沙箱**

```typescript
// CSS 隔离
class CSSIsolation {
  private scopeId: string;

  constructor(appName: string) {
    this.scopeId = `mf-${appName}-${Date.now()}`;
  }

  scopeCSS(css: string): string {
    return css.replace(/([^{}]+){/g, (match, selector) => {
      const scopedSelector = selector
        .split(',')
        .map(s => `[data-scope="${this.scopeId}"] ${s.trim()}`)
        .join(', ');
      return `${scopedSelector} {`;
    });
  }

  applyScopeToElement(element: HTMLElement): void {
    element.setAttribute('data-scope', this.scopeId);
  }
}

// JavaScript 沙箱
class JavaScriptSandbox {
  private originalWindow: Record<string, any> = {};
  private modifiedKeys: Set<string> = new Set();

  activate(): void {
    // 记录原始 window 属性
    Object.keys(window).forEach(key => {
      this.originalWindow[key] = window[key];
    });
  }

  deactivate(): void {
    // 恢复 window 对象
    this.modifiedKeys.forEach(key => {
      if (this.originalWindow.hasOwnProperty(key)) {
        window[key] = this.originalWindow[key];
      } else {
        delete window[key];
      }
    });
    
    this.modifiedKeys.clear();
  }

  setGlobal(key: string, value: any): void {
    if (!this.originalWindow.hasOwnProperty(key)) {
      this.modifiedKeys.add(key);
    }
    window[key] = value;
  }
}

// 微前端应用包装器
class MicrofrontendWrapper {
  private cssIsolation: CSSIsolation;
  private jsSandbox: JavaScriptSandbox;
  private app: any;

  constructor(private config: MicrofrontendConfig) {
    this.cssIsolation = new CSSIsolation(config.name);
    this.jsSandbox = new JavaScriptSandbox();
  }

  async mount(container: HTMLElement): Promise<void> {
    // 激活沙箱
    this.jsSandbox.activate();

    try {
      // 应用 CSS 作用域
      this.cssIsolation.applyScopeToElement(container);

      // 加载应用
      const appModule = await import(this.config.entry);
      this.app = appModule.default;

      // 挂载应用
      await this.app.mount({
        container,
        ...this.config.props
      });
    } catch (error) {
      console.error(`Failed to mount microfrontend ${this.config.name}:`, error);
      this.jsSandbox.deactivate();
      throw error;
    }
  }

  async unmount(): Promise<void> {
    try {
      if (this.app && typeof this.app.unmount === 'function') {
        await this.app.unmount();
      }
    } finally {
      // 清理沙箱
      this.jsSandbox.deactivate();
    }
  }
}
```

**性能优化策略**

```typescript
// 懒加载管理器
class LazyLoadManager {
  private loadedApps = new Set<string>();
  private loadingPromises = new Map<string, Promise<any>>();

  async loadApp(config: MicrofrontendConfig): Promise<any> {
    if (this.loadedApps.has(config.name)) {
      return;
    }

    if (this.loadingPromises.has(config.name)) {
      return this.loadingPromises.get(config.name);
    }

    const loadPromise = this.doLoadApp(config);
    this.loadingPromises.set(config.name, loadPromise);

    try {
      const result = await loadPromise;
      this.loadedApps.add(config.name);
      return result;
    } finally {
      this.loadingPromises.delete(config.name);
    }
  }

  private async doLoadApp(config: MicrofrontendConfig): Promise<any> {
    // 预加载检查
    if (config.preload) {
      return this.preloadApp(config);
    }

    // 按需加载
    return import(config.entry);
  }

  private async preloadApp(config: MicrofrontendConfig): Promise<any> {
    // 使用 link 标签预加载资源
    const link = document.createElement('link');
    link.rel = 'prefetch';
    link.href = config.entry;
    document.head.appendChild(link);

    return import(config.entry);
  }
}

// 资源共享优化
class SharedResourceManager {
  private sharedDependencies = new Map<string, any>();

  registerSharedDependency(name: string, dependency: any): void {
    this.sharedDependencies.set(name, dependency);
  }

  getSharedDependency(name: string): any {
    return this.sharedDependencies.get(name);
  }

  // 版本兼容性检查
  checkVersionCompatibility(name: string, requiredVersion: string): boolean {
    const shared = this.sharedDependencies.get(name);
    if (!shared || !shared.version) {
      return false;
    }

    return this.isVersionCompatible(shared.version, requiredVersion);
  }

  private isVersionCompatible(currentVersion: string, requiredVersion: string): boolean {
    // 简化的版本比较，实际应该使用 semver
    const current = currentVersion.split('.').map(Number);
    const required = requiredVersion.split('.').map(Number);

    return current[0] === required[0] && current[1] >= required[1];
  }
}
```

























































































