# React SSR 原理与实现



## React SSR 的核心原理与实现机制

### SSR 基本概念

服务端渲染（Server-Side Rendering）是指在服务器上执行 React 组件，生成完整的 HTML 字符串，然后发送给客户端的技术。

**核心优势：**

- 更好的 SEO 支持
- 更快的首屏加载时间（FCP）
- 更好的用户体验，特别是在慢网络环境下

### 实现原理

React SSR 的核心是 `ReactDOMServer.renderToString()` 方法：

```javascript
// 服务端代码
import React from 'react';
import ReactDOMServer from 'react-dom/server';
import App from './App';

const html = ReactDOMServer.renderToString(<App />);

const fullHtml = `
<!DOCTYPE html>
<html>
<head>
    <title>SSR App</title>
</head>
<body>
    <div id="root">${html}</div>
    <script src="/bundle.js"></script>
</body>
</html>
```



###  关键 API

**服务端渲染 API：**

- `renderToString()`: 同步渲染，返回 HTML 字符串
- `renderToStaticMarkup()`: 不包含 React 内部属性的静态标记
- `renderToPipeableStream()`: React 18 流式渲染（Node.js）
- `renderToReadableStream()`: React 18 流式渲染（Web Streams）

**客户端激活 API：**

- `ReactDOM.hydrate()`: React 17 及之前版本
- `ReactDOM.hydrateRoot()`: React 18 新 API



## 客户端激活 (Hydration) 过程与常见问题解决

### Hydration 原理

Hydration 是指客户端 JavaScript 接管服务端渲染的 HTML，为其添加交互性的过程。

```javascript
// 客户端代码
import React from 'react';
import { hydrateRoot } from 'react-dom/client';
import App from './App';

// React 18
const container = document.getElementById('root');
const root = hydrateRoot(container, <App />);

// React 17
// ReactDOM.hydrate(<App />, document.getElementById('root'));
```



### Hydration 过程

1. **匹配阶段**: React 比较服务端 HTML 和客户端虚拟 DOM
2. **附加事件**: 为现有 DOM 节点附加事件监听器
3. **状态初始化**: 初始化组件状态和副作用

### 常见问题与解决方案

**问题 1: Hydration 不匹配**

```javascript
// 错误示例：服务端和客户端渲染不一致
function MyComponent() {
    const [isClient, setIsClient] = useState(false);
    
    // 这会导致 hydration 不匹配
    return <div>{isClient ? 'Client' : 'Server'}</div>;
}

// 解决方案 1: 使用 useEffect
function MyComponent() {
    const [isClient, setIsClient] = useState(false);
    
    useEffect(() => {
        setIsClient(true);
    }, []);
    
    return <div>{isClient ? 'Client' : 'Server'}</div>;
}

// 解决方案 2: 使用 suppressHydrationWarning
function MyComponent() {
    return (
        <div suppressHydrationWarning>
            {typeof window !== 'undefined' ? 'Client' : 'Server'}
        </div>
    );
}
```

**问题 2: 异步数据处理**

```javascript
// 错误示例
function UserProfile({ userId }) {
    const [user, setUser] = useState(null);
    
    useEffect(() => {
        fetchUser(userId).then(setUser);
    }, [userId]);
    
    if (!user) return <div>Loading...</div>;
    return <div>{user.name}</div>;
}

// 解决方案：数据预取
function UserProfile({ user }) {
    // 服务端已经获取了用户数据
    return <div>{user.name}</div>;
}
```



##  React 18 中的流式 SSR 与选择性水合

### 流式 SSR

React 18 引入了流式渲染，允许服务端逐步发送 HTML 片段：

```javascript
// 服务端流式渲染
import { renderToPipeableStream } from 'react-dom/server';

app.get('/', (req, res) => {
    const { pipe, abort } = renderToPipeableStream(
        <App />,
        {
            bootstrapScripts: ['/client.js'],
            onShellReady() {
                res.statusCode = 200;
                res.setHeader('Content-type', 'text/html');
                pipe(res);
            },
            onError(error) {
                console.error(error);
                res.statusCode = 500;
                res.send('<!doctype html><p>Error</p>');
            }
        }
    );
    
    setTimeout(abort, 10000);
});
```



###  Suspense 与流式渲染

```javascript
import { Suspense } from 'react';

function App() {
    return (
        <html>
            <body>
                <h1>My App</h1>
                <Suspense fallback={<div>Loading comments...</div>}>
                    <Comments />
                </Suspense>
                <Suspense fallback={<div>Loading sidebar...</div>}>
                    <Sidebar />
                </Suspense>
            </body>
        </html>
    );
}

// Comments 组件可以异步加载数据
async function Comments() {
    const comments = await fetchComments();
    return (
        <div>
            {comments.map(comment => (
                <div key={comment.id}>{comment.text}</div>
            ))}
        </div>
    );
}
```



### 选择性水合 (Selective Hydration)

React 18 允许优先级水合，用户交互的组件会优先被水合：

```javascript
function App() {
    return (
        <div>
            <Header />
            <Suspense fallback={<div>Loading...</div>}>
                <MainContent />
            </Suspense>
            <Suspense fallback={<div>Loading...</div>}>
                <Sidebar />
            </Suspense>
        </div>
    );
}

// 用户点击 Sidebar，React 会优先水合 Sidebar 组件
```



##  从零实现一个 React SSR 框架

### 基础架构

```javascript
// server.js
import express from 'express';
import React from 'react';
import { renderToPipeableStream } from 'react-dom/server';
import { StaticRouter } from 'react-router-dom/server';
import App from '../src/App';

const app = express();

// 静态资源服务
app.use(express.static('public'));

// SSR 路由处理
app.get('*', (req, res) => {
    const { pipe, abort } = renderToPipeableStream(
        <StaticRouter location={req.url}>
            <App />
        </StaticRouter>,
        {
            bootstrapScripts: ['/client.js'],
            onShellReady() {
                res.statusCode = 200;
                res.setHeader('Content-type', 'text/html');
                pipe(res);
            },
            onError(error) {
                console.error(error);
                res.statusCode = 500;
            }
        }
    );
    
    setTimeout(abort, 10000);
});

app.listen(3000);
```



### 客户端入口

```javascript
// client.js
import React from 'react';
import { hydrateRoot } from 'react-dom/client';
import { BrowserRouter } from 'react-router-dom';
import App from './App';

const container = document.getElementById('root');
hydrateRoot(
    container,
    <BrowserRouter>
        <App />
    </BrowserRouter>
);
```



### 构建配置

```javascript
// webpack.config.js
const path = require('path');

module.exports = [
    // 客户端配置
    {
        name: 'client',
        mode: 'development',
        entry: './src/client.js',
        output: {
            path: path.resolve(__dirname, 'public'),
            filename: 'client.js'
        },
        module: {
            rules: [
                {
                    test: /\.jsx?$/,
                    exclude: /node_modules/,
                    use: {
                        loader: 'babel-loader',
                        options: {
                            presets: ['@babel/preset-react']
                        }
                    }
                }
            ]
        }
    },
    // 服务端配置
    {
        name: 'server',
        mode: 'development',
        target: 'node',
        entry: './server/server.js',
        output: {
            path: path.resolve(__dirname, 'dist'),
            filename: 'server.js'
        },
        module: {
            rules: [
                {
                    test: /\.jsx?$/,
                    exclude: /node_modules/,
                    use: {
                        loader: 'babel-loader',
                        options: {
                            presets: ['@babel/preset-react']
                        }
                    }
                }
            ]
        }
    }
];
```



## SSR 应用中的数据预取与状态管理



### 数据预取策略

**方法 1: 路由级别数据预取**

```javascript
// 定义数据获取方法
const routes = [
    {
        path: '/users/:id',
        component: UserProfile,
        loadData: (store, match) => {
            return store.dispatch(fetchUser(match.params.id));
        }
    }
];

// 服务端数据预取
app.get('*', async (req, res) => {
    const store = createStore();
    const promises = [];
    
    // 匹配路由并预取数据
    routes.forEach(route => {
        const match = matchPath(req.path, route);
        if (match && route.loadData) {
            promises.push(route.loadData(store, match));
        }
    });
    
    await Promise.all(promises);
    
    const html = renderToString(
        <Provider store={store}>
            <StaticRouter location={req.url}>
                <App />
            </StaticRouter>
        </Provider>
    );
    
    const preloadedState = store.getState();
    res.send(renderFullPage(html, preloadedState));
});
```



**方法 2: 组件级别数据预取**

```javascript
// 使用自定义 Hook
function useSSRData(key, fetcher) {
    const [data, setData] = useState(() => {
        // 服务端渲染时从全局状态获取
        if (typeof window === 'undefined') {
            return global.__SSR_DATA__[key];
        }
        // 客户端从 window 获取
        return window.__PRELOADED_STATE__[key];
    });
    
    useEffect(() => {
        if (!data) {
            fetcher().then(setData);
        }
    }, [data, fetcher]);
    
    return data;
}

// 在组件中使用
function UserProfile({ userId }) {
    const user = useSSRData(`user_${userId}`, () => fetchUser(userId));
    
    if (!user) return <div>Loading...</div>;
    return <div>{user.name}</div>;
}
```



### 5.2 状态同步

```javascript
// 服务端状态序列化
function renderFullPage(html, preloadedState) {
    return `
    <!doctype html>
    <html>
        <head>
            <title>SSR App</title>
        </head>
        <body>
            <div id="root">${html}</div>
            <script>
                window.__PRELOADED_STATE__ = ${JSON.stringify(preloadedState).replace(/</g, '\\u003c')}
            </script>
            <script src="/client.js"></script>
        </body>
    </html>
    `;
}

// 客户端状态恢复
const preloadedState = window.__PRELOADED_STATE__;
delete window.__PRELOADED_STATE__;
const store = createStore(rootReducer, preloadedState);
```



## React SSR 中的性能优化策略

###  缓存策略

**组件级缓存**

```javascript
import LRU from 'lru-cache';

const componentCache = new LRU({ max: 100 });

function CachedComponent({ cacheKey, children }) {
    if (typeof window === 'undefined') {
        const cached = componentCache.get(cacheKey);
        if (cached) {
            return <div dangerouslySetInnerHTML={{ __html: cached }} />;
        }
        
        const html = renderToString(children);
        componentCache.set(cacheKey, html);
        return <div dangerouslySetInnerHTML={{ __html: html }} />;
    }
    
    return children;
}
```



**页面级缓存**

```javascript
const pageCache = new LRU({ max: 50, maxAge: 1000 * 60 * 5 }); // 5分钟

app.get('*', (req, res) => {
    const cacheKey = req.url;
    const cached = pageCache.get(cacheKey);
    
    if (cached) {
        return res.send(cached);
    }
    
    // 渲染页面...
    const html = renderFullPage(renderedHtml, preloadedState);
    pageCache.set(cacheKey, html);
    res.send(html);
});
```



### 代码分割与懒加载优化

```javascript
// 服务端支持的动态导入
import { ChunkExtractor } from '@loadable/server';

app.get('*', (req, res) => {
    const extractor = new ChunkExtractor({ statsFile: './loadable-stats.json' });
    
    const jsx = extractor.collectChunks(
        <StaticRouter location={req.url}>
            <App />
        </StaticRouter>
    );
    
    const html = renderToString(jsx);
    
    res.send(`
        <!DOCTYPE html>
        <html>
            <head>
                ${extractor.getLinkTags()}
                ${extractor.getStyleTags()}
            </head>
            <body>
                <div id="root">${html}</div>
                ${extractor.getScriptTags()}
            </body>
        </html>
    `);
});
```



### 渲染性能优化

```javascript
// 使用 React.memo 减少不必要的渲染
const ExpensiveComponent = React.memo(({ data }) => {
    return <div>{/* 复杂渲染逻辑 */}</div>;
});

// 使用 useMemo 缓存计算结果
function DataTable({ items }) {
    const processedData = useMemo(() => {
        return items.map(item => ({
            ...item,
            processed: expensiveCalculation(item)
        }));
    }, [items]);
    
    return <table>{/* 渲染表格 */}</table>;
}
```



## 同构应用中的代码分割与动态导入



### 使用 @loadable/component

```javascript
// 安装依赖
// npm install @loadable/component @loadable/server @loadable/webpack-plugin

// 组件懒加载
import loadable from '@loadable/component';

const AsyncComponent = loadable(() => import('./HeavyComponent'), {
    fallback: <div>Loading...</div>
});

function App() {
    return (
        <div>
            <h1>My App</h1>
            <AsyncComponent />
        </div>
    );
}
```



### 路由级代码分割

```javascript
import { Routes, Route } from 'react-router-dom';
import loadable from '@loadable/component';

// 懒加载页面组件
const Home = loadable(() => import('./pages/Home'));
const About = loadable(() => import('./pages/About'));
const Contact = loadable(() => import('./pages/Contact'));

function App() {
    return (
        <Routes>
            <Route path="/" element={<Home />} />
            <Route path="/about" element={<About />} />
            <Route path="/contact" element={<Contact />} />
        </Routes>
    );
}
```



###  服务端配置

```javascript
// webpack.config.js
const LoadablePlugin = require('@loadable/webpack-plugin');

module.exports = {
    // ... 其他配置
    plugins: [
        new LoadablePlugin()
    ]
};

// 服务端渲染
import { ChunkExtractor, ChunkExtractorManager } from '@loadable/server';

const extractor = new ChunkExtractor({
    statsFile: path.resolve('./loadable-stats.json')
});

const jsx = (
    <ChunkExtractorManager extractor={extractor}>
        <StaticRouter location={req.url}>
            <App />
        </StaticRouter>
    </ChunkExtractorManager>
);

const html = renderToString(jsx);

// 获取需要的资源
const scriptTags = extractor.getScriptTags();
const linkTags = extractor.getLinkTags();
const styleTags = extractor.getStyleTags();
```



### 预加载策略

javascript

```javascript
// 鼠标悬停预加载
function NavLink({ to, children }) {
    const handleMouseEnter = () => {
        // 预加载对应的路由组件
        import(`./pages/${to}`);
    };
    
    return (
        <Link 
            to={to} 
            onMouseEnter={handleMouseEnter}
        >
            {children}
        </Link>
    );
}

// 可视区域预加载
import { useInView } from 'react-intersection-observer';

function LazySection() {
    const { ref, inView } = useInView({
        triggerOnce: true,
        rootMargin: '200px'
    });
    
    return (
        <div ref={ref}>
            {inView ? (
                <AsyncComponent />
            ) : (
                <div>Placeholder</div>
            )}
        </div>
    );
}
```

## 总结

React SSR 是现代 Web 应用的重要技术，涉及服务端渲染、客户端激活、数据预取、性能优化等多个方面。React 18 的流式渲染和选择性水合进一步提升了 SSR 的性能和用户体验。

**关键要点：**

1. 理解 SSR 的核心原理和 Hydration 过程
2. 正确处理服务端和客户端的差异
3. 合理使用数据预取和状态管理
4. 通过缓存、代码分割等手段优化性能
5. 利用 React 18 的新特性提升用户体验



# Next.js 深度应用

##  Next

##  Next.js 13/14 的 App Router 架构设计与实现原理

### 架构设计核心概念

App Router 是 Next.js 13 引入的全新路由系统，基于 React Server Components 构建，代表了现代 React 应用开发的新范式。

#### 文件系统路由架构

```
app/
├── layout.tsx          # 根布局
├── page.tsx           # 首页
├── loading.tsx        # 加载状态
├── error.tsx          # 错误处理
├── not-found.tsx      # 404 页面
├── global-error.tsx   # 全局错误处理
├── dashboard/
│   ├── layout.tsx     # 嵌套布局
│   ├── page.tsx       # /dashboard
│   ├── settings/
│   │   └── page.tsx   # /dashboard/settings
│   └── @analytics/    # 并行路由
│       └── page.tsx
├── (marketing)/       # 路由分组
│   ├── about/
│   └── contact/
└── api/
    └── users/
        └── route.ts   # API 路由
```

#### 实现原理深度解析

**组件树构建机制**

```typescript
// Next.js 内部的路由解析流程
interface RouteNode {
  segment: string;
  component: React.ComponentType;
  layout?: React.ComponentType;
  loading?: React.ComponentType;
  error?: React.ComponentType;
  children: RouteNode[];
}

// 路由树构建示例
const routeTree = {
  segment: '',
  layout: RootLayout,
  children: [
    {
      segment: 'dashboard',
      layout: DashboardLayout,
      page: DashboardPage,
      children: [
        {
          segment: 'settings',
          page: SettingsPage
        }
      ]
    }
  ]
};
```



 **渲染策略**

```typescript
// 服务器端渲染流程
async function renderPage(pathname: string) {
  const routeMatch = matchRoute(pathname);
  const serverComponents = await renderServerComponents(routeMatch);
  const clientBundle = await generateClientBundle(routeMatch);
  
  return {
    serverComponents,
    clientBundle,
    metadata: extractMetadata(routeMatch)
  };
}
```



### 核心特性

**布局嵌套与状态保持**

```typescript
// app/layout.tsx - 根布局
export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="zh">
      <body>
        <Header />
        <main>{children}</main>
        <Footer />
      </body>
    </html>
  );
}

// app/dashboard/layout.tsx - 嵌套布局
export default function DashboardLayout({
  children,
  analytics, // 并行路由
}: {
  children: React.ReactNode;
  analytics: React.ReactNode;
}) {
  return (
    <div className="dashboard">
      <Sidebar />
      <div className="content">
        {children}
        {analytics}
      </div>
    </div>
  );
}
```



## 服务器组件与客户端组件的协同工作

### Server Components 架构原理

Server Components 在服务器端执行，直接访问后端资源，减少客户端 JavaScript 包大小。

#### 组件类型划分

```typescript
// 服务器组件 (默认)
async function ServerComponent() {
  const data = await fetch('https://api.example.com/data');
  const posts = await data.json();
  
  return (
    <div>
      {posts.map(post => (
        <PostCard key={post.id} post={post} />
      ))}
    </div>
  );
}

// 客户端组件
'use client';
import { useState, useEffect } from 'react';

function ClientComponent() {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    // 客户端副作用
    document.title = `Count: ${count}`;
  }, [count]);
  
  return (
    <button onClick={() => setCount(count + 1)}>
      Count: {count}
    </button>
  );
}
```



### 协同工作模式

**1. 组件组合模式**

```typescript
// 服务器组件包含客户端组件
async function BlogPost({ id }: { id: string }) {
  const post = await getPost(id);
  
  return (
    <article>
      <h1>{post.title}</h1>
      <div>{post.content}</div>
      {/* 客户端交互组件 */}
      <InteractiveComponents postId={id} />
    </article>
  );
}

'use client';
function InteractiveComponents({ postId }: { postId: string }) {
  return (
    <div>
      <LikeButton postId={postId} />
      <CommentSection postId={postId} />
      <ShareButton />
    </div>
  );
}
```



**2. 数据传递策略**

```typescript
// 服务器组件向客户端组件传递数据
async function ProductPage({ params }: { params: { id: string } }) {
  const product = await getProduct(params.id);
  const relatedProducts = await getRelatedProducts(params.id);
  
  return (
    <div>
      <ProductInfo product={product} />
      {/* 序列化数据传递给客户端组件 */}
      <ProductInteractions 
        productId={product.id}
        initialLikes={product.likes}
        relatedProducts={relatedProducts}
      />
    </div>
  );
}
```



### 性能优化策略

**1. 组件边界优化**

```typescript
// 最小化客户端组件范围
function ProductCard({ product }) {
  return (
    <div className="card">
      <img src={product.image} alt={product.name} />
      <h3>{product.name}</h3>
      <p>{product.description}</p>
      {/* 只有交互部分使用客户端组件 */}
      <AddToCartButton productId={product.id} />
    </div>
  );
}

'use client';
function AddToCartButton({ productId }) {
  const [isAdding, setIsAdding] = useState(false);
  
  const handleAdd = async () => {
    setIsAdding(true);
    await addToCart(productId);
    setIsAdding(false);
  };
  
  return (
    <button onClick={handleAdd} disabled={isAdding}>
      {isAdding ? '添加中...' : '加入购物车'}
    </button>
  );
}
```



## Next.js 中的数据获取策略与缓存控制

### 数据获取策略

**1. Server Components 中的数据获取**

```typescript
// 并行数据获取
async function Dashboard() {
  // 并行执行多个异步操作
  const [user, posts, analytics] = await Promise.all([
    getUser(),
    getPosts(),
    getAnalytics()
  ]);
  
  return (
    <div>
      <UserProfile user={user} />
      <PostsList posts={posts} />
      <AnalyticsWidget data={analytics} />
    </div>
  );
}

// 瀑布式数据获取（避免）
async function BadExample() {
  const user = await getUser();
  const posts = await getPosts(user.id); // 依赖前一个请求
  const comments = await getComments(posts[0].id); // 再次依赖
  
  return <div>{/* 渲染内容 */}</div>;
}
```



**2. 数据获取模式**

```typescript
// 预加载模式
function preloadUser(id: string) {
  void getUser(id); // 预加载但不等待
}

function preloadPosts() {
  void getPosts();
}

// 在路由组件中预加载
export default function UserPage({ params }) {
  preloadUser(params.id);
  preloadPosts();
  
  return (
    <Suspense fallback={<UserSkeleton />}>
      <UserComponent id={params.id} />
    </Suspense>
  );
}
```



### 缓存控制策略

**1. 多层缓存架构**

```typescript
// 请求级缓存
async function getCachedData(id: string) {
  const data = await fetch(`/api/data/${id}`, {
    // 请求去重
    cache: 'force-cache',
    // 重新验证时间
    next: { revalidate: 3600 }
  });
  return data.json();
}

// React 缓存
import { cache } from 'react';

const getUser = cache(async (id: string) => {
  const response = await fetch(`/api/users/${id}`);
  return response.json();
});

// 多次调用只执行一次
async function UserProfile({ id }) {
  const user = await getUser(id); // 执行请求
  return <div>{user.name}</div>;
}

async function UserSettings({ id }) {
  const user = await getUser(id); // 使用缓存
  return <div>{user.email}</div>;
}
```



**2. 缓存失效与重新验证**

```typescript
// 基于时间的重新验证
export async function generateStaticParams() {
  return [{ id: '1' }, { id: '2' }];
}

async function ProductPage({ params }) {
  const product = await fetch(`/api/products/${params.id}`, {
    next: { 
      revalidate: 60, // 60秒后重新验证
      tags: ['product', params.id] // 缓存标签
    }
  });
  
  return <ProductDisplay product={product} />;
}

// 按需重新验证
import { revalidateTag, revalidatePath } from 'next/cache';

export async function updateProduct(id: string, data: any) {
  await updateProductInDB(id, data);
  
  // 重新验证特定标签
  revalidateTag(`product-${id}`);
  
  // 重新验证路径
  revalidatePath(`/products/${id}`);
}
```



**客户端缓存策略**

```typescript
// SWR 集成
'use client';
import useSWR from 'swr';

function ClientDataComponent() {
  const { data, error, mutate } = useSWR('/api/data', fetcher, {
    revalidateOnFocus: false,
    revalidateOnReconnect: true,
    refreshInterval: 30000
  });
  
  if (error) return <div>加载失败</div>;
  if (!data) return <div>加载中...</div>;
  
  return (
    <div>
      {data.map(item => <Item key={item.id} {...item} />)}
      <button onClick={() => mutate()}>刷新</button>
    </div>
  );
}
```



##  Next.js 中间件的设计与应用场景

### 中间件架构设计

中间件在请求到达页面之前执行，提供请求拦截、重写、重定向等功能。

```typescript
// middleware.ts
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';

export function middleware(request: NextRequest) {
  // 获取请求信息
  const { pathname, search } = request.nextUrl;
  const userAgent = request.headers.get('user-agent') || '';
  
  // 地理位置信息
  const country = request.geo?.country;
  const city = request.geo?.city;
  
  console.log(`Request: ${pathname}${search} from ${country}, ${city}`);
  
  // 执行中间件逻辑
  return handleRequest(request);
}

async function handleRequest(request: NextRequest) {
  const response = NextResponse.next();
  
  // 添加自定义头部
  response.headers.set('x-middleware-timestamp', Date.now().toString());
  
  return response;
}

// 配置中间件匹配路径
export const config = {
  matcher: [
    '/((?!api|_next/static|_next/image|favicon.ico).*)',
  ],
};
```



### 核心应用场景

**1. 身份认证与授权**

```typescript
import { NextResponse } from 'next/server';
import { verify } from 'jsonwebtoken';

export async function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl;
  
  // 保护的路由
  const protectedPaths = ['/dashboard', '/profile', '/admin'];
  const isProtectedPath = protectedPaths.some(path => 
    pathname.startsWith(path)
  );
  
  if (isProtectedPath) {
    const token = request.cookies.get('auth-token')?.value;
    
    if (!token) {
      return NextResponse.redirect(new URL('/login', request.url));
    }
    
    try {
      const payload = verify(token, process.env.JWT_SECRET!);
      
      // 检查用户权限
      if (pathname.startsWith('/admin') && !payload.isAdmin) {
        return NextResponse.redirect(new URL('/unauthorized', request.url));
      }
      
      // 添加用户信息到请求头
      const response = NextResponse.next();
      response.headers.set('x-user-id', payload.userId);
      return response;
      
    } catch (error) {
      return NextResponse.redirect(new URL('/login', request.url));
    }
  }
  
  return NextResponse.next();
}
```



**2. 国际化路由处理**

```typescript
const locales = ['en', 'zh', 'ja'];
const defaultLocale = 'en';

export function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl;
  
  // 检查路径是否已包含语言代码
  const pathnameHasLocale = locales.some(
    locale => pathname.startsWith(`/${locale}/`) || pathname === `/${locale}`
  );
  
  if (!pathnameHasLocale) {
    // 从 Accept-Language 头部获取首选语言
    const locale = getLocaleFromRequest(request) || defaultLocale;
    
    return NextResponse.redirect(
      new URL(`/${locale}${pathname}`, request.url)
    );
  }
  
  return NextResponse.next();
}

function getLocaleFromRequest(request: NextRequest): string | null {
  const acceptLanguage = request.headers.get('accept-language');
  if (!acceptLanguage) return null;
  
  // 解析 Accept-Language 头部
  const languages = acceptLanguage
    .split(',')
    .map(lang => lang.split(';')[0].trim());
  
  return languages.find(lang => locales.includes(lang)) || null;
}
```



**3. A/B 测试与特性标志**

```typescript
export function middleware(request: NextRequest) {
  const response = NextResponse.next();
  
  // A/B 测试配置
  const experiments = {
    'new-checkout': {
      enabled: true,
      traffic: 0.5, // 50% 流量
    },
    'redesigned-header': {
      enabled: true,
      traffic: 0.3, // 30% 流量
    }
  };
  
  // 为每个实验分配用户
  Object.entries(experiments).forEach(([experimentId, config]) => {
    if (!config.enabled) return;
    
    const cookieName = `experiment-${experimentId}`;
    let assignment = request.cookies.get(cookieName)?.value;
    
    if (!assignment) {
      // 随机分配
      assignment = Math.random() < config.traffic ? 'treatment' : 'control';
      response.cookies.set(cookieName, assignment, {
        maxAge: 30 * 24 * 60 * 60 * 1000, // 30天
        httpOnly: true,
        sameSite: 'strict'
      });
    }
    
    // 添加到响应头供组件使用
    response.headers.set(`x-experiment-${experimentId}`, assignment);
  });
  
  return response;
}
```



**4. 请求重写与代理**

```typescript
export function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl;
  
  // API 代理
  if (pathname.startsWith('/api/v1/')) {
    return NextResponse.rewrite(
      new URL(pathname.replace('/api/v1', '/api'), request.url)
    );
  }
  
  // 子域名路由
  const hostname = request.headers.get('host');
  const subdomain = hostname?.split('.')[0];
  
  if (subdomain && subdomain !== 'www' && subdomain !== 'localhost') {
    // 将子域名重写为路径参数
    return NextResponse.rewrite(
      new URL(`/sites/${subdomain}${pathname}`, request.url)
    );
  }
  
  // 移动端重定向
  const userAgent = request.headers.get('user-agent') || '';
  const isMobile = /Mobile|Android|iPhone/i.test(userAgent);
  
  if (isMobile && pathname.startsWith('/desktop-only')) {
    return NextResponse.redirect(new URL('/mobile-version', request.url));
  }
  
  return NextResponse.next();
}
```



##  Next.js 项目的高级路由技术与动态路由优化

### 高级路由技术

**1. 并行路由 (Parallel Routes)**

```typescript
// app/dashboard/layout.tsx
export default function DashboardLayout({
  children,
  analytics,
  notifications,
}: {
  children: React.ReactNode;
  analytics: React.ReactNode;
  notifications: React.ReactNode;
}) {
  return (
    <div className="dashboard-layout">
      <div className="main-content">{children}</div>
      <div className="sidebar">
        <div className="analytics-section">{analytics}</div>
        <div className="notifications-section">{notifications}</div>
      </div>
    </div>
  );
}

// 文件结构
// app/dashboard/
// ├── layout.tsx
// ├── page.tsx
// ├── @analytics/
// │   ├── page.tsx
// │   └── loading.tsx
// └── @notifications/
//     ├── page.tsx
//     └── error.tsx
```



**2. 拦截路由 (Intercepting Routes)**

```typescript
// app/photos/(..)modal/[id]/page.tsx
// 拦截 /modal/[id] 路由，在当前页面显示模态框

export default function PhotoModal({ params }: { params: { id: string } }) {
  return (
    <div className="modal-overlay">
      <div className="modal">
        <PhotoViewer id={params.id} />
        <CloseButton />
      </div>
    </div>
  );
}

// app/modal/[id]/page.tsx
// 直接访问时的完整页面
export default function PhotoPage({ params }: { params: { id: string } }) {
  return (
    <div className="full-page">
      <PhotoViewer id={params.id} />
      <PhotoComments id={params.id} />
    </div>
  );
}
```



**3. 条件路由与路由组**

```typescript
// (marketing) 路由组不影响 URL 结构
// app/(marketing)/
// ├── layout.tsx    # 营销页面布局
// ├── about/
// │   └── page.tsx  # /about
// └── contact/
//     └── page.tsx  # /contact

// app/(dashboard)/
// ├── layout.tsx    # 仪表板布局
// ├── analytics/
// └── settings/

// 条件布局
export default function ConditionalLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  // 根据路径应用不同布局
  const pathname = usePathname();
  
  if (pathname.startsWith('/admin')) {
    return <AdminLayout>{children}</AdminLayout>;
  }
  
  if (pathname.startsWith('/dashboard')) {
    return <DashboardLayout>{children}</DashboardLayout>;
  }
  
  return <DefaultLayout>{children}</DefaultLayout>;
}
```



### 动态路由优化

**1. 静态参数生成**

```typescript
// app/blog/[slug]/page.tsx
export async function generateStaticParams() {
  // 在构建时生成所有可能的参数
  const posts = await getAllPosts();
  
  return posts.map((post) => ({
    slug: post.slug,
  }));
}

// 增量静态生成
export const dynamicParams = true; // 允许动态参数

export default async function BlogPost({ 
  params 
}: { 
  params: { slug: string } 
}) {
  const post = await getPost(params.slug);
  
  if (!post) {
    notFound(); // 返回 404
  }
  
  return (
    <article>
      <h1>{post.title}</h1>
      <div dangerouslySetInnerHTML={{ __html: post.content }} />
    </article>
  );
}
```



**2. 多层级动态路由**

```typescript
// app/shop/[category]/[...slug]/page.tsx
// 匹配: /shop/electronics/phones/iphone
//       /shop/clothing/shirts/cotton/blue

export async function generateStaticParams() {
  const categories = await getCategories();
  const params = [];
  
  for (const category of categories) {
    const products = await getProductsByCategory(category.slug);
    
    for (const product of products) {
      // 生成产品路径
      params.push({
        category: category.slug,
        slug: product.path.split('/'), // ['phones', 'iphone']
      });
      
      // 生成分类路径
      if (product.subcategories) {
        product.subcategories.forEach(sub => {
          params.push({
            category: category.slug,
            slug: [sub.slug],
          });
        });
      }
    }
  }
  
  return params;
}

export default async function ProductPage({
  params,
}: {
  params: { category: string; slug: string[] };
}) {
  const { category, slug } = params;
  const fullPath = `/${category}/${slug.join('/')}`;
  
  // 尝试匹配产品
  const product = await getProductByPath(fullPath);
  if (product) {
    return <ProductView product={product} />;
  }
  
  // 尝试匹配分类
  const categoryData = await getCategoryByPath(fullPath);
  if (categoryData) {
    return <CategoryView category={categoryData} />;
  }
  
  notFound();
}
```



**3. 路由性能优化**

```typescript
// 预加载关键路由
import { preloadRoute } from 'next/navigation';

function ProductCard({ product }) {
  const handleMouseEnter = () => {
    // 鼠标悬停时预加载产品页面
    preloadRoute(`/products/${product.slug}`);
  };
  
  return (
    <Link 
      href={`/products/${product.slug}`}
      onMouseEnter={handleMouseEnter}
    >
      <div className="product-card">
        {/* 产品信息 */}
      </div>
    </Link>
  );
}

// 路由分组与代码分割
const AdminPanel = dynamic(() => import('./AdminPanel'), {
  loading: () => <AdminSkeleton />,
  ssr: false, // 仅客户端渲染
});

const DashboardCharts = dynamic(() => import('./DashboardCharts'), {
  loading: () => <ChartsSkeleton />,
});

export default function Dashboard() {
  const { user } = useAuth();
  
  return (
    <div>
      <h1>仪表板</h1>
      <Suspense fallback={<ChartsSkeleton />}>
        <DashboardCharts />
      </Suspense>
      
      {user.isAdmin && (
        <Suspense fallback={<AdminSkeleton />}>
          <AdminPanel />
        </Suspense>
      )}
    </div>
  );
}
```



## ISR、SSG、SSR 与 CSR 在 Next.js 中的选择策略

![image-20250529143723007](C:/Users/27019/AppData/Roaming/Typora/typora-user-images/image-20250529143723007.png)

### 实现策略详解

**1. 静态站点生成 (SSG)**

```typescript
// 纯静态生成
export default async function StaticPage() {
  const data = await getStaticData();
  
  return (
    <div>
      <h1>静态页面</h1>
      <StaticContent data={data} />
    </div>
  );
}

// 动态路由的静态生成
export async function generateStaticParams() {
  const posts = await getAllPosts();
  
  return posts.map(post => ({
    slug: post.slug,
  }));
}

export default async function BlogPost({ params }) {
  const post = await getPost(params.slug);
  
  return (
    <article>
      <h1>{post.title}</h1>
      <time>{post.publishedAt}</time>
      <div>{post.content}</div>
    </article>
  );
}

// 构建时优化
export async function generateMetadata({ params }) {
  const post = await getPost(params.slug);
  
  return {
    title: post.title,
    description: post.excerpt,
    openGraph: {
      title: post.title,
      description: post.excerpt,
      images: [post.coverImage],
    },
  };
}
```



**2. 增量静态再生 (ISR)**

```typescript
// 基于时间的重新验证
export default async function ProductPage({ params }) {
  const product = await fetch(`/api/products/${params.id}`, {
    next: { revalidate: 3600 } // 1小时后重新验证
  });
  
  return <ProductDetails product={product} />;
}

// 按需重新验证
// pages/api/revalidate.ts (App Router 使用 Route Handlers)
export async function POST(request: Request) {
  const { searchParams } = new URL(request.url);
  const path = searchParams.get('path');
  
  if (!path) {
    return Response.json({ message: 'Missing path' }, { status: 400 });
  }
  
  try {
    await revalidatePath(path);
    return Response.json({ revalidated: true });
  } catch (err) {
    return Response.json({ message: 'Error revalidating' }, { status: 500 });
  }
}

// 带标签的重新验证
async function getProduct(id: string) {
  const res = await fetch(`/api/products/${id}`, {
    next: { 
      revalidate: 3600,
      tags: ['product', `product-${id}`]
    }
  });
  return res.json();
}

// 更新产品时触发重新验证
export async function updateProduct(id: string, data: any) {
  await updateProductInDatabase(id, data);
  revalidateTag(`product-${id}`);
}
```



**3. 服务器端渲染 (SSR)**

```typescript
// 动态渲染（每次请求时执行）
async function UserDashboard({ searchParams }) {
  // 这个函数在每次请求时运行
  const session = await getServerSession();
  const userData = await getUserData(session.user.id);
  const notifications = await getNotifications(session.user.id);
  
  return (
    <div>
      <h1>欢迎, {userData.name}</h1>
      <NotificationList notifications={notifications} />
      <PersonalizedContent userId={session.user.id} />
    </div>
  );
}

// 强制动态渲染
export const dynamic = 'force-dynamic';

// 或使用动态函数
async function DynamicPage() {
  const userAgent = headers().get('user-agent');
  const searchParams = new URL(request.url).searchParams;
  const currentTime = new Date().toISOString();
  
  return (
    <div>
      <p>当前时间: {currentTime}</p>
      <p>用户代理: {userAgent}</p>
      <p>搜索参数: {searchParams.toString()}</p>
    </div>
  );
}
```



**4. 客户端渲染 (CSR)**

```typescript
'use client';
import { useState, useEffect } from 'react';

export default function ClientOnlyComponent() {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    async function fetchData() {
      const response = await fetch('/api/user-specific-data');
      const result = await response.json();
      setData(result);
      setLoading(false);
    }
    
    fetchData();
  }, []);
  
  if (loading) return <div>加载中...</div>;
  
  return (
    <div>
      <h2>客户端渲染内容</h2>
      <InteractiveChart data={data} />
      <RealTimeUpdates />
    </div>
  );
}

// 混合渲染策略
function HybridPage() {
  return (
    <div>
      {/* 服务器渲染的静态内容 */}
      <StaticHeader />
      <StaticContent />
      
      {/* 客户端渲染的动态内容 */}
      <Suspense fallback={<Skeleton />}>
        <ClientOnlyComponent />
      </Suspense>
    </div>
  );
}
```



### 选择策略决策树

**决策流程**

```typescript
function chooseRenderingStrategy(pageType: string, requirements: Requirements) {
  // 1. 内容是否经常变化？
  if (requirements.contentChangeFrequency === 'never') {
    return 'SSG'; // 静态生成
  }
  
  // 2. 是否需要实时数据？
  if (requirements.needsRealTimeData) {
    if (requirements.seoImportant) {
      return 'SSR'; // 服务器端渲染
    } else {
      return 'CSR'; // 客户端渲染
    }
  }
  
  // 3. 内容更新频率
  if (requirements.contentChangeFrequency === 'hourly' || 
      requirements.contentChangeFrequency === 'daily') {
    return 'ISR'; // 增量静态再生
  }
  
  // 4. 是否需要个性化？
  if (requirements.needsPersonalization) {
    return 'SSR';
  }
  
  // 5. 默认选择
  return 'ISR';
}

// 使用示例
const blogStrategy = chooseRenderingStrategy('blog', {
  contentChangeFrequency: 'daily',
  needsRealTimeData: false,
  seoImportant: true,
  needsPersonalization: false
}); // 结果: ISR

const dashboardStrategy = chooseRenderingStrategy('dashboard', {
  contentChangeFrequency: 'realtime',
  needsRealTimeData: true,
  seoImportant: false,
  needsPersonalization: true
}); // 结果: CSR
```



## Next.js 应用的部署优化与性能监控

### 部署优化策略

**1. 构建优化配置**

```javascript
// next.config.js
const nextConfig = {
  // 编译优化
  compiler: {
    removeConsole: process.env.NODE_ENV === 'production',
    styledComponents: true,
  },
  
  // 实验性功能
  experimental: {
    optimizeCss: true,
    gzipSize: true,
    craCompat: true,
    serverComponentsExternalPackages: ['@prisma/client'],
  },
  
  // 图片优化
  images: {
    formats: ['image/avif', 'image/webp'],
    domains: ['example.com', 'cdn.example.com'],
    deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],
    imageSizes: [16, 32, 48, 64, 96, 128, 256, 384],
    minimumCacheTTL: 31536000, // 1年
  },
  
  // 输出配置
  output: 'standalone', // Docker 部署优化
  
  // 压缩配置
  compress: true,
  
  // 包分析
  webpack: (config, { dev, isServer }) => {
    // 生产环境优化
    if (!dev && !isServer) {
      config.optimization.splitChunks = {
        chunks: 'all',
        cacheGroups: {
          vendor: {
            test: /[\\/]node_modules[\\/]/,
            name: 'vendors',
            chunks: 'all',
          },
          common: {
            name: 'common',
            minChunks: 2,
            chunks: 'all',
            enforce: true,
          },
        },
      };
    }
    
    return config;
  },
  
  // 重定向配置
  async redirects() {
    return [
      {
        source: '/old-blog/:slug',
        destination: '/blog/:slug',
        permanent: true,
      },
    ];
  },
  
  // 头部配置
  async headers() {
    return [
      {
        source: '/(.*)',
        headers: [
          {
            key: 'X-Frame-Options',
            value: 'DENY',
          },
          {
            key: 'X-Content-Type-Options',
            value: 'nosniff',
          },
          {
            key: 'Referrer-Policy',
            value: 'origin-when-cross-origin',
          },
        ],
      },
      {
        source: '/api/(.*)',
        headers: [
          {
            key: 'Cache-Control',
            value: 'public, max-age=3600',
          },
        ],
      },
    ];
  },
};

module.exports = nextConfig;
```

## 

**2. 部署配置优化**

```dockerfile
# Dockerfile 优化
FROM node:18-alpine AS base

# 依赖安装阶段
FROM base AS deps
RUN apk add --no-cache libc6-compat
WORKDIR /app

COPY package.json yarn.lock* package-lock.json* pnpm-lock.yaml* ./
RUN \
  if [ -f yarn.lock ]; then yarn --frozen-lockfile; \
  elif [ -f package-lock.json ]; then npm ci; \
  elif [ -f pnpm-lock.yaml ]; then yarn global add pnpm && pnpm i --frozen-lockfile; \
  else echo "Lockfile not found." && exit 1; \
  fi

# 构建阶段
FROM base AS builder
WORKDIR /app
COPY --from=deps /app/node_modules ./node_modules
COPY . .

ENV NEXT_TELEMETRY_DISABLED 1

RUN yarn build

# 运行阶段
FROM base AS runner
WORKDIR /app

ENV NODE_ENV production
ENV NEXT_TELEMETRY_DISABLED 1

RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nextjs

COPY --from=builder /app/public ./public

RUN mkdir .next
RUN chown nextjs:nodejs .next

COPY --from=builder --chown=nextjs:nodejs /app/.next/standalone ./
COPY --from=builder --chown=nextjs:nodejs /app/.next/static ./.next/static

USER nextjs

EXPOSE 3000

ENV PORT 3000

CMD ["node", "server.js"]
```



**3. CDN 与缓存策略**

```typescript
// 静态资源缓存配置
export const config = {
  // API 路由缓存
  runtime: 'edge',
};

export default async function handler(request: Request) {
  const data = await fetchData();
  
  const response = new Response(JSON.stringify(data), {
    headers: {
      'Content-Type': 'application/json',
      'Cache-Control': 'public, s-maxage=3600, stale-while-revalidate=86400',
      'CDN-Cache-Control': 'public, max-age=31536000',
      'Vary': 'Accept-Encoding',
    },
  });
  
  return response;
}

// 图片优化配置
import Image from 'next/image';

function OptimizedImage({ src, alt, ...props }) {
  return (
    <Image
      src={src}
      alt={alt}
      placeholder="blur"
      blurDataURL="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD..."
      sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
      quality={85}
      priority={props.priority}
      {...props}
    />
  );
}
```



### 性能监控实现

**1. 核心 Web 指标监控**

```typescript
// app/layout.tsx
import { SpeedInsights } from '@vercel/speed-insights/next';
import { Analytics } from '@vercel/analytics/react';

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="zh">
      <body>
        {children}
        <SpeedInsights />
        <Analytics />
        <WebVitalsReporter />
      </body>
    </html>
  );
}

// 自定义 Web Vitals 报告
'use client';
import { useReportWebVitals } from 'next/web-vitals';

function WebVitalsReporter() {
  useReportWebVitals((metric) => {
    // 发送到分析服务
    if (metric.label === 'web-vital') {
      gtag('event', metric.name, {
        event_category: 'Web Vitals',
        event_label: metric.id,
        value: Math.round(
          metric.name === 'CLS' ? metric.value * 1000 : metric.value
        ),
        non_interaction: true,
      });
      
      // 发送到自定义分析服务
      fetch('/api/vitals', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          name: metric.name,
          value: metric.value,
          id: metric.id,
          label: metric.label,
          delta: metric.delta,
          url: window.location.href,
          timestamp: Date.now(),
        }),
      });
    }
  });
  
  return null;
}
```



**2. 性能监控 API**

```typescript
// app/api/vitals/route.ts
export async function POST(request: Request) {
  const metric = await request.json();
  
  // 验证指标数据
  if (!isValidMetric(metric)) {
    return new Response('Invalid metric', { status: 400 });
  }
  
  // 存储到数据库
  await storeMetric({
    ...metric,
    userAgent: request.headers.get('user-agent'),
    timestamp: new Date(),
  });
  
  // 检查性能阈值
  await checkPerformanceThresholds(metric);
  
  return new Response('OK');
}

function isValidMetric(metric: any): boolean {
  const validNames = ['CLS', 'FCP', 'FID', 'LCP', 'TTFB'];
  return validNames.includes(metric.name) && 
         typeof metric.value === 'number' &&
         metric.value >= 0;
}

async function checkPerformanceThresholds(metric: any) {
  const thresholds = {
    LCP: 2500, // ms
    FID: 100,  // ms
    CLS: 0.1,  // score
    FCP: 1800, // ms
    TTFB: 800, // ms
  };
  
  if (metric.value > thresholds[metric.name]) {
    // 发送告警
    await sendAlert({
      type: 'performance_degradation',
      metric: metric.name,
      value: metric.value,
      threshold: thresholds[metric.name],
      url: metric.url,
    });
  }
}
```



**3. 实时性能仪表板**

```typescript
// 性能监控组件
'use client';
import { useState, useEffect } from 'react';
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip } from 'recharts';

export default function PerformanceDashboard() {
  const [metrics, setMetrics] = useState([]);
  const [realTimeData, setRealTimeData] = useState({});
  
  useEffect(() => {
    // 获取历史数据
    fetchMetrics().then(setMetrics);
    
    // 建立 WebSocket 连接获取实时数据
    const ws = new WebSocket('/api/ws/vitals');
    
    ws.onmessage = (event) => {
      const data = JSON.parse(event.data);
      setRealTimeData(prev => ({
        ...prev,
        [data.name]: data.value,
      }));
    };
    
    return () => ws.close();
  }, []);
  
  return (
    <div className="dashboard">
      <div className="metrics-grid">
        <MetricCard 
          title="Largest Contentful Paint"
          value={realTimeData.LCP}
          threshold={2500}
          unit="ms"
        />
        <MetricCard 
          title="First Input Delay"
          value={realTimeData.FID}
          threshold={100}
          unit="ms"
        />
        <MetricCard 
          title="Cumulative Layout Shift"
          value={realTimeData.CLS}
          threshold={0.1}
          unit=""
        />
        <MetricCard 
          title="First Contentful Paint"
          value={realTimeData.FCP}
          threshold={1800}
          unit="ms"
        />
      </div>
      
      <div className="charts">
        <LineChart width={800} height={300} data={metrics}>
          <CartesianGrid strokeDasharray="3 3" />
          <XAxis dataKey="timestamp" />
          <YAxis />
          <Tooltip />
          <Line type="monotone" dataKey="LCP" stroke="#8884d8" />
          <Line type="monotone" dataKey="FID" stroke="#82ca9d" />
        </LineChart>
      </div>
    </div>
  );
}

function MetricCard({ title, value, threshold, unit }) {
  const isGood = value <= threshold;
  
  return (
    <div className={`metric-card ${isGood ? 'good' : 'poor'}`}>
      <h3>{title}</h3>
      <div className="value">
        {value?.toFixed(2)} <span className="unit">{unit}</span>
      </div>
      <div className="threshold">
        阈值: {threshold}{unit}
      </div>
    </div>
  );
}
```



**4. 错误监控与告警**

```typescript
// 全局错误边界
'use client';
import { Component, ReactNode } from 'react';

interface Props {
  children: ReactNode;
}

interface State {
  hasError: boolean;
  error?: Error;
}

export class ErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = { hasError: false };
  }
  
  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }
  
  componentDidCatch(error: Error, errorInfo: any) {
    // 发送错误报告
    this.reportError(error, errorInfo);
  }
  
  async reportError(error: Error, errorInfo: any) {
    const errorReport = {
      message: error.message,
      stack: error.stack,
      componentStack: errorInfo.componentStack,
      url: window.location.href,
      userAgent: navigator.userAgent,
      timestamp: new Date().toISOString(),
    };
    
    try {
      await fetch('/api/errors', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(errorReport),
      });
    } catch (reportingError) {
      console.error('Failed to report error:', reportingError);
    }
  }
  
  render() {
    if (this.state.hasError) {
      return (
        <div className="error-fallback">
          <h2>出现了一些问题</h2>
          <p>我们已经记录了这个错误，正在修复中。</p>
          <button onClick={() => window.location.reload()}>
            刷新页面
          </button>
        </div>
      );
    }
    
    return this.props.children;
  }
}

// 性能预算监控
const performanceBudget = {
  LCP: 2500,
  FID: 100,
  CLS: 0.1,
  bundleSize: 250 * 1024, // 250KB
  imageSize: 500 * 1024,  // 500KB
};

export function checkPerformanceBudget(metrics: any) {
  const violations = [];
  
  Object.entries(performanceBudget).forEach(([key, limit]) => {
    if (metrics[key] > limit) {
      violations.push({
        metric: key,
        value: metrics[key],
        limit,
        percentage: ((metrics[key] - limit) / limit * 100).toFixed(2),
      });
    }
  });
  
  if (violations.length > 0) {
    console.warn('Performance budget violations:', violations);
    // 发送告警
    sendPerformanceAlert(violations);
  }
  
  return violations;
}
```

## 总结

Next.js 的深度应用涵盖了现代 Web 开发的方方面面，从架构设计到性能优化，每个环节都需要深入理解和精心设计。通过合理运用 App Router、Server Components、数据获取策略、中间件、动态路由、渲染策略和监控系统，可以构建出高性能、可扩展的现代 Web 应用。

关键要点：

- **架构设计**：理解 App Router 的文件系统路由和组件树构建机制
- **组件协同**：合理划分 Server Components 和 Client Components 的边界
- **数据策略**：选择合适的数据获取方式和缓存策略
- **中间件应用**：利用中间件处理横切关注点
- **路由优化**：使用高级路由技术提升用户体验
- **渲染选择**：根据具体需求选择最适合的渲染策略
- **部署监控**：建立完整的部署优化和性能监控体系





## 混合渲染与新兴技术

## React Server Components 的实现原理与使用边界

### 实现原理

React Server Components (RSC) 是在服务器端运行的组件，它们的核心原理包括：

**组件分离机制**：

- Server Components 在服务器端执行，直接访问数据源
- Client Components 在浏览器端运行，处理交互和状态
- 通过特殊的序列化协议在服务器和客户端之间传输组件树

**渲染流程**：

```javascript
// Server Component (在服务器运行)
async function BlogPost({ id }) {
  const post = await db.posts.findById(id); // 直接数据库访问
  return (
    <article>
      <h1>{post.title}</h1>
      <p>{post.content}</p>
      <Comments postId={id} /> {/* 可以是另一个 Server Component */}
    </article>
  );
}

// Client Component (需要明确标记)
'use client';
import { useState } from 'react';

function InteractiveButton() {
  const [count, setCount] = useState(0);
  return <button onClick={() => setCount(count + 1)}>Count: {count}</button>;
}
```

### 使用边界

**适合 RSC 的场景**：

- 数据获取密集的组件
- 静态内容展示
- SEO 关键页面
- 需要服务器端权限验证的内容

**必须使用 Client Components 的场景**：

- 需要浏览器 API（localStorage、window 等）
- 事件处理和交互
- 使用 React hooks（useState、useEffect 等）
- 第三方客户端库集成



## 渐进式水合 (Progressive Hydration) 的实现与应用

### 实现原理

渐进式水合允许页面分块逐步变为交互状态，而不是等待整个应用水合完成。

```javascript
// 使用 React.lazy 和 Suspense 实现渐进式水合
import { lazy, Suspense } from 'react';

const HeavyComponent = lazy(() => import('./HeavyComponent'));
const InteractiveWidget = lazy(() => import('./InteractiveWidget'));

function App() {
  return (
    <div>
      {/* 立即可见的静态内容 */}
      <header>
        <h1>我的应用</h1>
      </header>
      
      {/* 延迟水合的重组件 */}
      <Suspense fallback={<div>加载中...</div>}>
        <HeavyComponent />
      </Suspense>
      
      {/* 优先级较低的交互组件 */}
      <Suspense fallback={<div>准备交互功能...</div>}>
        <InteractiveWidget />
      </Suspense>
    </div>
  );
}
```

### 实现策略

**基于优先级的水合**：

```javascript
// 自定义 Hook 实现优先级水合
function useProgressiveHydration(priority = 'low') {
  const [isHydrated, setIsHydrated] = useState(false);
  
  useEffect(() => {
    const timeoutMap = {
      high: 0,
      medium: 100,
      low: 500
    };
    
    const timer = setTimeout(() => {
      setIsHydrated(true);
    }, timeoutMap[priority]);
    
    return () => clearTimeout(timer);
  }, [priority]);
  
  return isHydrated;
}
```



## 边缘渲染 (Edge Rendering) 在 React 应用中的实践

### 边缘渲染架构

边缘渲染将渲染过程推向用户更近的边缘节点，减少延迟。

```javascript
// Next.js Edge Runtime 示例
export const config = {
  runtime: 'edge'
};

export default async function handler(req) {
  const { searchParams } = new URL(req.url);
  const userId = searchParams.get('userId');
  
  // 在边缘节点获取用户数据
  const userData = await fetch(`https://api.example.com/users/${userId}`);
  
  // 边缘渲染 React 组件
  const html = renderToString(
    <UserProfile user={userData} />
  );
  
  return new Response(html, {
    headers: { 'content-type': 'text/html' }
  });
}
```

### 实践策略

**地理位置感知渲染**：

```javascript
// 根据用户地理位置选择数据源和渲染策略
function getRegionalConfig(request) {
  const country = request.cf?.country || 'US';
  
  return {
    apiEndpoint: `https://${country.toLowerCase()}.api.example.com`,
    currency: getCurrencyByCountry(country),
    language: getLanguageByCountry(country)
  };
}
```

## 

## React 的部分水合 (Partial Hydration) 技术与实现

### 选择性水合实现

```javascript
// 自定义部分水合组件
function PartiallyHydratedComponent({ children, shouldHydrate }) {
  const [isClient, setIsClient] = useState(false);
  
  useEffect(() => {
    if (shouldHydrate) {
      setIsClient(true);
    }
  }, [shouldHydrate]);
  
  // 服务器端渲染静态内容
  if (!isClient) {
    return <div suppressHydrationWarning>{children}</div>;
  }
  
  // 客户端渲染交互版本
  return children;
}

// 使用示例
function App() {
  return (
    <div>
      <PartiallyHydratedComponent shouldHydrate={false}>
        <StaticContent />
      </PartiallyHydratedComponent>
      
      <PartiallyHydratedComponent shouldHydrate={true}>
        <InteractiveContent />
      </PartiallyHydratedComponent>
    </div>
  );
}
```

### 智能水合决策

```javascript
// 基于用户行为决定是否水合
function useSmartHydration() {
  const [shouldHydrate, setShouldHydrate] = useState(false);
  
  useEffect(() => {
    // 检测用户交互意图
    const handleInteraction = () => setShouldHydrate(true);
    
    document.addEventListener('mousemove', handleInteraction, { once: true });
    document.addEventListener('touchstart', handleInteraction, { once: true });
    
    // 或基于 Intersection Observer
    const observer = new IntersectionObserver((entries) => {
      if (entries[0].isIntersecting) {
        setShouldHydrate(true);
      }
    });
    
    return () => {
      document.removeEventListener('mousemove', handleInteraction);
      document.removeEventListener('touchstart', handleInteraction);
      observer.disconnect();
    };
  }, []);
  
  return shouldHydrate;
}
```



## React 应用的 JAMStack 架构设计与实践

### JAMStack 架构模式

```javascript
// 静态生成 + API 驱动的 React 应用
// next.config.js
module.exports = {
  output: 'export',
  trailingSlash: true,
  images: {
    unoptimized: true
  }
};

// pages/blog/[slug].js
export async function getStaticPaths() {
  const posts = await fetchAllPosts();
  const paths = posts.map((post) => ({
    params: { slug: post.slug }
  }));
  
  return { paths, fallback: 'blocking' };
}

export async function getStaticProps({ params }) {
  const post = await fetchPost(params.slug);
  
  return {
    props: { post },
    revalidate: 60 // ISR 支持
  };
}
```



### 微服务 API 集成

```javascript
// API 层抽象
class APIService {
  constructor() {
    this.baseURL = process.env.NEXT_PUBLIC_API_URL;
  }
  
  async fetchContent(endpoint) {
    const response = await fetch(`${this.baseURL}${endpoint}`);
    return response.json();
  }
  
  // 支持多个微服务
  async fetchFromService(service, endpoint) {
    const serviceURL = process.env[`${service.toUpperCase()}_API_URL`];
    const response = await fetch(`${serviceURL}${endpoint}`);
    return response.json();
  }
}

// 在组件中使用
function BlogList() {
  const [posts, setPosts] = useState([]);
  
  useEffect(() => {
    const api = new APIService();
    api.fetchFromService('blog', '/posts').then(setPosts);
  }, []);
  
  return (
    <div>
      {posts.map(post => <BlogCard key={post.id} post={post} />)}
    </div>
  );
}
```



## React 18 的 Suspense SSR 架构深度解析

### Streaming SSR 实现

```javascript
// 服务器端流式渲染
import { renderToPipeableStream } from 'react-dom/server';

function handleRequest(req, res) {
  const { pipe, abort } = renderToPipeableStream(
    <App />,
    {
      bootstrapScripts: ['/client.js'],
      onShellReady() {
        // 优先发送页面骨架
        res.statusCode = 200;
        res.setHeader('Content-type', 'text/html');
        pipe(res);
      },
      onAllReady() {
        // 所有内容准备完毕
      },
      onError(error) {
        console.error(error);
      }
    }
  );
  
  // 处理请求超时
  setTimeout(abort, 10000);
}
```



### 选择性水合实现

```javascript
// 支持 Suspense 的组件结构
function App() {
  return (
    <html>
      <body>
        <div id="root">
          <Navigation /> {/* 立即渲染 */}
          
          <Suspense fallback={<PostsSkeleton />}>
            <Posts /> {/* 异步渲染 */}
          </Suspense>
          
          <Suspense fallback={<CommentsSkeleton />}>
            <Comments /> {/* 独立的异步块 */}
          </Suspense>
        </div>
      </body>
    </html>
  );
}

// 异步组件实现
async function Posts() {
  const posts = await fetchPosts(); // 可以是异步数据获取
  return (
    <div>
      {posts.map(post => <Post key={post.id} {...post} />)}
    </div>
  );
}
```



## React 与 WebAssembly 协同工作的最佳实践

### WASM 模块集成

```javascript
// 加载和使用 WebAssembly 模块
import { useEffect, useState } from 'react';

function useWasm(wasmPath) {
  const [wasmModule, setWasmModule] = useState(null);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    async function loadWasm() {
      try {
        const wasmModule = await import(wasmPath);
        await wasmModule.default(); // 初始化 WASM
        setWasmModule(wasmModule);
      } catch (error) {
        console.error('WASM 加载失败:', error);
      } finally {
        setLoading(false);
      }
    }
    
    loadWasm();
  }, [wasmPath]);
  
  return { wasmModule, loading };
}

// 图像处理组件示例
function ImageProcessor() {
  const { wasmModule, loading } = useWasm('./image-processor.wasm');
  const [processedImage, setProcessedImage] = useState(null);
  
  const processImage = useCallback((imageData) => {
    if (!wasmModule) return;
    
    // 调用 WASM 函数处理图像
    const result = wasmModule.process_image(
      imageData.data,
      imageData.width,
      imageData.height
    );
    
    setProcessedImage(result);
  }, [wasmModule]);
  
  if (loading) return <div>加载图像处理器...</div>;
  
  return (
    <div>
      <input
        type="file"
        accept="image/*"
        onChange={(e) => {
          const file = e.target.files[0];
          if (file) {
            const reader = new FileReader();
            reader.onload = (event) => {
              const img = new Image();
              img.onload = () => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = img.width;
                canvas.height = img.height;
                ctx.drawImage(img, 0, 0);
                const imageData = ctx.getImageData(0, 0, img.width, img.height);
                processImage(imageData);
              };
              img.src = event.target.result;
            };
            reader.readAsDataURL(file);
          }
        }}
      />
      {processedImage && <img src={processedImage} alt="处理后的图像" />}
    </div>
  );
}
```



### 性能优化策略

```javascript
// Web Worker + WASM 的组合使用
// worker.js
self.onmessage = async function(e) {
  const { imageData, operation } = e.data;
  
  // 在 Worker 中加载 WASM
  const wasmModule = await import('./image-processor.wasm');
  await wasmModule.default();
  
  // 执行计算密集型操作
  const result = wasmModule[operation](imageData);
  
  self.postMessage({ result });
};

// React 组件中使用
function useWasmWorker() {
  const [worker, setWorker] = useState(null);
  
  useEffect(() => {
    const worker = new Worker('./wasm-worker.js');
    setWorker(worker);
    
    return () => worker.terminate();
  }, []);
  
  const processInWorker = useCallback((data, operation) => {
    return new Promise((resolve) => {
      worker.onmessage = (e) => resolve(e.data.result);
      worker.postMessage({ imageData: data, operation });
    });
  }, [worker]);
  
  return processInWorker;
}
```
