# 状态管理与架构设计

##  Redux 设计哲学与核心实现原理

### 设计哲学

Redux基于三个核心原则：

1. 单一数据源（Single Source of Truth）
   - 整个应用的状态存储在一个单一的store中
   - 便于调试和状态管理
   - 支持时间旅行调试
2. 状态只读（State is Read-Only）
   - 不能直接修改状态
   - 只能通过dispatch action来改变状态
   - 确保状态变更的可预测性
3. 使用纯函数进行状态变更（Changes are Made with Pure Functions）
   - Reducer必须是纯函数
   - 相同输入总是产生相同输出
   - 无副作用

### 核心实现原理

```javascript
// Redux核心实现简化版
function createStore(reducer, preloadedState, enhancer) {
  if (typeof enhancer !== 'undefined') {
    return enhancer(createStore)(reducer, preloadedState);
  }

  let currentReducer = reducer;
  let currentState = preloadedState;
  let currentListeners = [];
  let nextListeners = currentListeners;
  let isDispatching = false;

  function getState() {
    return currentState;
  }

  function subscribe(listener) {
    nextListeners.push(listener);
    
    return function unsubscribe() {
      const index = nextListeners.indexOf(listener);
      nextListeners.splice(index, 1);
    };
  }

  function dispatch(action) {
    if (isDispatching) {
      throw new Error('Reducers may not dispatch actions.');
    }

    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }

    const listeners = (currentListeners = nextListeners);
    for (let i = 0; i < listeners.length; i++) {
      const listener = listeners[i];
      listener();
    }

    return action;
  }

  // 初始化状态
  dispatch({ type: '@@redux/INIT' });

  return {
    dispatch,
    subscribe,
    getState,
    replaceReducer
  };
}
```



## Redux 中间件机制的设计与实现

### 中间件设计理念

中间件提供了一个扩展点，允许在action被dispatch到reducer之前进行拦截和处理。

### 中间件实现原理

```javascript
// applyMiddleware实现
function applyMiddleware(...middlewares) {
  return createStore => (...args) => {
    const store = createStore(...args);
    let dispatch = () => {
      throw new Error('Dispatching while constructing your middleware is not allowed.');
    };

    const middlewareAPI = {
      getState: store.getState,
      dispatch: (...args) => dispatch(...args)
    };

    const chain = middlewares.map(middleware => middleware(middlewareAPI));
    dispatch = compose(...chain)(store.dispatch);

    return {
      ...store,
      dispatch
    };
  };
}

// compose函数实现
function compose(...funcs) {
  if (funcs.length === 0) {
    return arg => arg;
  }

  if (funcs.length === 1) {
    return funcs[0];
  }

  return funcs.reduce((a, b) => (...args) => a(b(...args)));
}
```

### 自定义中间件示例

```javascript
// 日志中间件
const logger = store => next => action => {
  console.log('dispatching', action);
  let result = next(action);
  console.log('next state', store.getState());
  return result;
};

// 异步中间件
const thunk = store => next => action => {
  if (typeof action === 'function') {
    return action(store.dispatch, store.getState);
  }
  return next(action);
};

// 错误处理中间件
const crashReporter = store => next => action => {
  try {
    return next(action);
  } catch (err) {
    console.error('Caught an exception!', err);
    throw err;
  }
};
```



##  Redux Toolkit 的核心设计与最佳实践

### RTK 核心特性

Redux Toolkit (RTK) 是Redux官方推荐的工具集，简化了Redux的使用。

#### createSlice

```javascript
import { createSlice } from '@reduxjs/toolkit';

const counterSlice = createSlice({
  name: 'counter',
  initialState: {
    value: 0
  },
  reducers: {
    increment: (state) => {
      // RTK使用Immer，允许"直接"修改状态
      state.value += 1;
    },
    decrement: (state) => {
      state.value -= 1;
    },
    incrementByAmount: (state, action) => {
      state.value += action.payload;
    }
  }
});

export const { increment, decrement, incrementByAmount } = counterSlice.actions;
export default counterSlice.reducer;
```

#### createAsyncThunk

```javascript
import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';

// 异步thunk
export const fetchUserById = createAsyncThunk(
  'users/fetchById',
  async (userId, { rejectWithValue }) => {
    try {
      const response = await userAPI.fetchById(userId);
      return response.data;
    } catch (err) {
      return rejectWithValue(err.response.data);
    }
  }
);

const usersSlice = createSlice({
  name: 'users',
  initialState: {
    entities: [],
    loading: 'idle'
  },
  reducers: {
    // 同步reducers
  },
  extraReducers: (builder) => {
    builder
      .addCase(fetchUserById.pending, (state) => {
        state.loading = 'pending';
      })
      .addCase(fetchUserById.fulfilled, (state, action) => {
        state.loading = 'idle';
        state.entities.push(action.payload);
      })
      .addCase(fetchUserById.rejected, (state, action) => {
        state.loading = 'idle';
        state.error = action.payload;
      });
  }
});
```

#### configureStore

```javascript
import { configureStore } from '@reduxjs/toolkit';
import counterReducer from './features/counter/counterSlice';
import usersReducer from './features/users/usersSlice';

export const store = configureStore({
  reducer: {
    counter: counterReducer,
    users: usersReducer
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      serializableCheck: {
        ignoredActions: ['persist/PERSIST']
      }
    }).concat(logger),
  devTools: process.env.NODE_ENV !== 'production'
});

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;
```



## React-Redux 连接机制源码解析

### Provider 组件实现

```javascript
import React, { useMemo } from 'react';
import { ReactReduxContext } from './Context';

function Provider({ store, children }) {
  const contextValue = useMemo(() => {
    const subscription = new Subscription(store);
    subscription.onStateChange = subscription.notifyNestedSubs;
    return {
      store,
      subscription
    };
  }, [store]);

  const previousState = useMemo(() => store.getState(), [store]);

  useEffect(() => {
    const { subscription } = contextValue;
    subscription.trySubscribe();

    if (previousState !== store.getState()) {
      subscription.notifyNestedSubs();
    }
    
    return () => {
      subscription.tryUnsubscribe();
      subscription.onStateChange = null;
    };
  }, [contextValue, previousState]);

  return (
    <ReactReduxContext.Provider value={contextValue}>
      {children}
    </ReactReduxContext.Provider>
  );
}
```



### useSelector Hook 实现

```javascript
import { useContext, useLayoutEffect, useRef, useMemo } from 'react';
import { ReactReduxContext } from './Context';

function useSelector(selector, equalityFn = refEquality) {
  const { store, subscription } = useContext(ReactReduxContext);
  
  const selectedState = useMemo(() => selector(store.getState()), [selector, store]);
  
  const ref = useRef();
  const forceRender = useForceRender();
  
  useLayoutEffect(() => {
    ref.current = {
      selector,
      equalityFn,
      selectedState,
      hasRun: true
    };
  });

  useLayoutEffect(() => {
    function checkForUpdates() {
      const { selector, equalityFn, selectedState } = ref.current;
      
      const newSelectedState = selector(store.getState());
      
      if (equalityFn(selectedState, newSelectedState)) {
        return;
      }
      
      ref.current.selectedState = newSelectedState;
      forceRender();
    }

    subscription.onStateChange = checkForUpdates;
    subscription.trySubscribe();

    checkForUpdates();

    return () => subscription.tryUnsubscribe();
  }, [store, subscription]);

  return selectedState;
}
```





### useDispatch Hook 实现

```javascript
import { useContext } from 'react';
import { ReactReduxContext } from './Context';

function useDispatch() {
  const { store } = useContext(ReactReduxContext);
  return store.dispatch;
}
```



## Redux 异步处理方案对比

### Redux-Thunk

```javascript
// 特点：简单直接，支持函数作为action
const fetchUser = (userId) => {
  return async (dispatch, getState) => {
    dispatch({ type: 'FETCH_USER_REQUEST' });
    try {
      const user = await api.fetchUser(userId);
      dispatch({ type: 'FETCH_USER_SUCCESS', payload: user });
    } catch (error) {
      dispatch({ type: 'FETCH_USER_FAILURE', payload: error.message });
    }
  };
};

// 使用
dispatch(fetchUser(123));
```





### Redux-Saga

```javascript
import { call, put, takeEvery, all } from 'redux-saga/effects';

// Worker saga
function* fetchUserSaga(action) {
  try {
    yield put({ type: 'FETCH_USER_REQUEST' });
    const user = yield call(api.fetchUser, action.payload.userId);
    yield put({ type: 'FETCH_USER_SUCCESS', payload: user });
  } catch (error) {
    yield put({ type: 'FETCH_USER_FAILURE', payload: error.message });
  }
}

// Watcher saga
function* watchFetchUser() {
  yield takeEvery('FETCH_USER', fetchUserSaga);
}

// Root saga
function* rootSaga() {
  yield all([
    watchFetchUser()
  ]);
}

// 复杂流程控制
function* userFlow() {
  while (true) {
    const { credentials } = yield take('LOGIN_REQUEST');
    const { user, error } = yield call(authorize, credentials);
    
    if (user) {
      yield put({ type: 'LOGIN_SUCCESS', user });
      yield take('LOGOUT');
      yield put({ type: 'LOGOUT_SUCCESS' });
    } else {
      yield put({ type: 'LOGIN_FAILURE', error });
    }
  }
}
```



### Redux-Observable

```javascript
import { ofType } from 'redux-observable';
import { map, mergeMap, catchError } from 'rxjs/operators';
import { of } from 'rxjs';

// Epic
const fetchUserEpic = action$ =>
  action$.pipe(
    ofType('FETCH_USER'),
    mergeMap(action =>
      ajax.getJSON(`/api/users/${action.payload.userId}`).pipe(
        map(user => ({ type: 'FETCH_USER_SUCCESS', payload: user })),
        catchError(error => of({ type: 'FETCH_USER_FAILURE', payload: error.message }))
      )
    )
  );

// 复杂数据流
const searchEpic = action$ =>
  action$.pipe(
    ofType('SEARCH'),
    debounceTime(300),
    distinctUntilChanged(),
    switchMap(action =>
      ajax.getJSON(`/api/search?q=${action.payload.query}`).pipe(
        map(results => ({ type: 'SEARCH_SUCCESS', payload: results })),
        catchError(error => of({ type: 'SEARCH_FAILURE', payload: error.message }))
      )
    )
  );
```

![image-20250522150443717](https://raw.githubusercontent.com/JoeyXXia/MyPictureData/main/image-20250522150443717.png)





## 不可变数据在 Redux 中的实现与性能优化

### 手动不可变更新

```javascript
// 错误做法 - 直接修改
function todosReducer(state = [], action) {
  switch (action.type) {
    case 'ADD_TODO':
      state.push(action.payload); // ❌ 直接修改
      return state;
    default:
      return state;
  }
}

// 正确做法 - 不可变更新
function todosReducer(state = [], action) {
  switch (action.type) {
    case 'ADD_TODO':
      return [...state, action.payload]; // ✅ 创建新数组
    
    case 'UPDATE_TODO':
      return state.map(todo =>
        todo.id === action.payload.id
          ? { ...todo, ...action.payload }
          : todo
      );
    
    case 'DELETE_TODO':
      return state.filter(todo => todo.id !== action.payload.id);
    
    default:
      return state;
  }
}
```



### 使用 Immer 简化不可变更新

```javascript
import { produce } from 'immer';

const todosReducer = produce((draft, action) => {
  switch (action.type) {
    case 'ADD_TODO':
      draft.push(action.payload);
      break;
    
    case 'UPDATE_TODO':
      const todo = draft.find(t => t.id === action.payload.id);
      if (todo) {
        Object.assign(todo, action.payload);
      }
      break;
    
    case 'DELETE_TODO':
      const index = draft.findIndex(t => t.id === action.payload.id);
      if (index !== -1) {
        draft.splice(index, 1);
      }
      break;
  }
});
```



### 性能优化策略

#### 选择器优化

```javascript
import { createSelector } from 'reselect';

// 基础选择器
const getTodos = state => state.todos;
const getFilter = state => state.filter;

// 记忆化选择器
const getVisibleTodos = createSelector(
  [getTodos, getFilter],
  (todos, filter) => {
    switch (filter) {
      case 'SHOW_ALL':
        return todos;
      case 'SHOW_COMPLETED':
        return todos.filter(t => t.completed);
      case 'SHOW_ACTIVE':
        return todos.filter(t => !t.completed);
      default:
        return todos;
    }
  }
);

// 参数化选择器
const getTodoById = createSelector(
  [getTodos, (state, id) => id],
  (todos, id) => todos.find(todo => todo.id === id)
);
```



#### 组件优化

```javascript
import React, { memo } from 'react';
import { useSelector, shallowEqual } from 'react-redux';

// 使用 shallowEqual 避免不必要的重渲染
const TodoList = memo(() => {
  const todos = useSelector(state => state.todos, shallowEqual);
  
  return (
    <ul>
      {todos.map(todo => (
        <TodoItem key={todo.id} todo={todo} />
      ))}
    </ul>
  );
});

// 优化单个Todo项
const TodoItem = memo(({ todo }) => {
  const dispatch = useDispatch();
  
  const handleToggle = useCallback(() => {
    dispatch(toggleTodo(todo.id));
  }, [dispatch, todo.id]);
  
  return (
    <li>
      <input
        type="checkbox"
        checked={todo.completed}
        onChange={handleToggle}
      />
      {todo.text}
    </li>
  );
});
```



## 大型应用的 Redux 模块化策略与代码组织

### 功能模块化结构

```
src/
├── features/
│   ├── auth/
│   │   ├── authSlice.js
│   │   ├── authAPI.js
│   │   ├── authSelectors.js
│   │   ├── components/
│   │   │   ├── LoginForm.js
│   │   │   └── UserProfile.js
│   │   └── index.js
│   ├── todos/
│   │   ├── todosSlice.js
│   │   ├── todosAPI.js
│   │   ├── todosSelectors.js
│   │   ├── components/
│   │   │   ├── TodoList.js
│   │   │   └── TodoItem.js
│   │   └── index.js
│   └── shared/
│       ├── uiSlice.js
│       └── apiSlice.js
├── store/
│   ├── index.js
│   ├── rootReducer.js
│   └── middleware.js
└── utils/
    ├── selectors.js
    └── helpers.js
```



### 特性切片模式

```javascript
// features/todos/todosSlice.js
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import { todosAPI } from './todosAPI';

export const fetchTodos = createAsyncThunk(
  'todos/fetchTodos',
  async (_, { rejectWithValue }) => {
    try {
      return await todosAPI.fetchAll();
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

const todosSlice = createSlice({
  name: 'todos',
  initialState: {
    items: [],
    status: 'idle',
    error: null
  },
  reducers: {
    todoAdded: (state, action) => {
      state.items.push(action.payload);
    },
    todoToggled: (state, action) => {
      const todo = state.items.find(todo => todo.id === action.payload);
      if (todo) {
        todo.completed = !todo.completed;
      }
    }
  },
  extraReducers: (builder) => {
    builder
      .addCase(fetchTodos.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(fetchTodos.fulfilled, (state, action) => {
        state.status = 'succeeded';
        state.items = action.payload;
      })
      .addCase(fetchTodos.rejected, (state, action) => {
        state.status = 'failed';
        state.error = action.payload;
      });
  }
});

export const { todoAdded, todoToggled } = todosSlice.actions;
export default todosSlice.reducer;
```



### 选择器组织

```javascript
// features/todos/todosSelectors.js
import { createSelector } from '@reduxjs/toolkit';

// 基础选择器
export const selectTodosState = state => state.todos;
export const selectAllTodos = state => state.todos.items;
export const selectTodosStatus = state => state.todos.status;
export const selectTodosError = state => state.todos.error;

// 复合选择器
export const selectActiveTodos = createSelector(
  [selectAllTodos],
  todos => todos.filter(todo => !todo.completed)
);

export const selectCompletedTodos = createSelector(
  [selectAllTodos],
  todos => todos.filter(todo => todo.completed)
);

export const selectTodosCount = createSelector(
  [selectAllTodos],
  todos => todos.length
);

export const selectActiveTodosCount = createSelector(
  [selectActiveTodos],
  activeTodos => activeTodos.length
);
```



### 跨模块通信

```javascript
// features/shared/apiSlice.js
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';

export const apiSlice = createApi({
  reducerPath: 'api',
  baseQuery: fetchBaseQuery({
    baseUrl: '/api',
    prepareHeaders: (headers, { getState }) => {
      const token = getState().auth.token;
      if (token) {
        headers.set('authorization', `Bearer ${token}`);
      }
      return headers;
    }
  }),
  tagTypes: ['Todo', 'User'],
  endpoints: builder => ({
    getTodos: builder.query({
      query: () => '/todos',
      providesTags: ['Todo']
    }),
    addTodo: builder.mutation({
      query: todo => ({
        url: '/todos',
        method: 'POST',
        body: todo
      }),
      invalidatesTags: ['Todo']
    })
  })
});

export const { useGetTodosQuery, useAddTodoMutation } = apiSlice;
```



### Store 配置

```javascript
// store/index.js
import { configureStore } from '@reduxjs/toolkit';
import { apiSlice } from '../features/shared/apiSlice';
import authReducer from '../features/auth/authSlice';
import todosReducer from '../features/todos/todosSlice';
import uiReducer from '../features/shared/uiSlice';

export const store = configureStore({
  reducer: {
    auth: authReducer,
    todos: todosReducer,
    ui: uiReducer,
    [apiSlice.reducerPath]: apiSlice.reducer
  },
  middleware: getDefaultMiddleware =>
    getDefaultMiddleware().concat(apiSlice.middleware),
  devTools: process.env.NODE_ENV !== 'production'
});

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;
```



### 类型安全的 Hooks

```typescript
// hooks/redux.ts
import { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux';
import type { RootState, AppDispatch } from '../store';

export const useAppDispatch = () => useDispatch<AppDispatch>();
export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;
```

### 最佳实践总结

1. **使用 Redux Toolkit**：简化样板代码，提供最佳实践
2. **按功能组织代码**：每个功能模块包含相关的reducers、actions、selectors和组件
3. **使用 TypeScript**：提供类型安全和更好的开发体验
4. **选择器记忆化**：使用 reselect 避免不必要的重计算
5. **规范化状态结构**：扁平化嵌套数据，使用实体模式
6. **异步操作统一处理**：使用 RTK Query 或 createAsyncThunk
7. **组件性能优化**：合理使用 React.memo 和 useCallback
8. **测试覆盖**：为reducers、selectors和异步操作编写测试





# 现代React状态管理完整指南

## Context + useReducer 实现应用状态管理的最佳实践

```ts
// types.ts
interface AppState {
  user: User | null;
  theme: 'light' | 'dark';
  notifications: Notification[];
  loading: boolean;
}

type AppAction =
  | { type: 'SET_USER'; payload: User }
  | { type: 'SET_THEME'; payload: 'light' | 'dark' }
  | { type: 'ADD_NOTIFICATION'; payload: Notification }
  | { type: 'REMOVE_NOTIFICATION'; payload: string }
  | { type: 'SET_LOADING'; payload: boolean };

// AppContext.tsx
import React, { createContext, useContext, useReducer, ReactNode } from 'react';

const initialState: AppState = {
  user: null,
  theme: 'light',
  notifications: [],
  loading: false
};

function appReducer(state: AppState, action: AppAction): AppState {
  switch (action.type) {
    case 'SET_USER':
      return { ...state, user: action.payload };
    
    case 'SET_THEME':
      return { ...state, theme: action.payload };
    
    case 'ADD_NOTIFICATION':
      return {
        ...state,
        notifications: [...state.notifications, action.payload]
      };
    
    case 'REMOVE_NOTIFICATION':
      return {
        ...state,
        notifications: state.notifications.filter(n => n.id !== action.payload)
      };
    
    case 'SET_LOADING':
      return { ...state, loading: action.payload };
    
    default:
      return state;
  }
}

interface AppContextType {
  state: AppState;
  dispatch: React.Dispatch<AppAction>;
}

const AppContext = createContext<AppContextType | undefined>(undefined);

export function AppProvider({ children }: { children: ReactNode }) {
  const [state, dispatch] = useReducer(appReducer, initialState);
  
  return (
    <AppContext.Provider value={{ state, dispatch }}>
      {children}
    </AppContext.Provider>
  );
}

export function useAppContext() {
  const context = useContext(AppContext);
  if (context === undefined) {
    throw new Error('useAppContext must be used within an AppProvider');
  }
  return context;
}
```



**优化的分层 Context 架构**

```ts
// 分离不同关注点的Context
// AuthContext.tsx
interface AuthState {
  user: User | null;
  isAuthenticated: boolean;
  loading: boolean;
}

const AuthContext = createContext<{
  state: AuthState;
  login: (credentials: LoginCredentials) => Promise<void>;
  logout: () => void;
  updateProfile: (data: Partial<User>) => Promise<void>;
} | undefined>(undefined);

export function AuthProvider({ children }: { children: ReactNode }) {
  const [state, dispatch] = useReducer(authReducer, initialAuthState);
  
  const login = useCallback(async (credentials: LoginCredentials) => {
    dispatch({ type: 'SET_LOADING', payload: true });
    try {
      const user = await authAPI.login(credentials);
      dispatch({ type: 'LOGIN_SUCCESS', payload: user });
    } catch (error) {
      dispatch({ type: 'LOGIN_ERROR', payload: error.message });
    }
  }, []);

  const logout = useCallback(() => {
    authAPI.logout();
    dispatch({ type: 'LOGOUT' });
  }, []);

  const updateProfile = useCallback(async (data: Partial<User>) => {
    try {
      const updatedUser = await authAPI.updateProfile(data);
      dispatch({ type: 'UPDATE_USER', payload: updatedUser });
    } catch (error) {
      throw error;
    }
  }, []);

  return (
    <AuthContext.Provider value={{ state, login, logout, updateProfile }}>
      {children}
    </AuthContext.Provider>
  );
}

// ThemeContext.tsx
interface ThemeContextType {
  theme: Theme;
  toggleTheme: () => void;
  setTheme: (theme: Theme) => void;
}

export function ThemeProvider({ children }: { children: ReactNode }) {
  const [theme, setTheme] = useState<Theme>('light');
  
  const toggleTheme = useCallback(() => {
    setTheme(prev => prev === 'light' ? 'dark' : 'light');
  }, []);
  
  // 持久化主题设置
  useEffect(() => {
    const savedTheme = localStorage.getItem('theme') as Theme;
    if (savedTheme) {
      setTheme(savedTheme);
    }
  }, []);
  
  useEffect(() => {
    localStorage.setItem('theme', theme);
    document.documentElement.setAttribute('data-theme', theme);
  }, [theme]);

  return (
    <ThemeContext.Provider value={{ theme, toggleTheme, setTheme }}>
      {children}
    </ThemeContext.Provider>
  );
}
```



**性能优化策略**

```ts
// 避免不必要的重新渲染
export function OptimizedProvider({ children }: { children: ReactNode }) {
  const [state, dispatch] = useReducer(appReducer, initialState);
  
  // 分离状态和动作，减少重新渲染
  const stateValue = useMemo(() => state, [state]);
  const actionsValue = useMemo(() => ({ dispatch }), []);
  
  return (
    <StateContext.Provider value={stateValue}>
      <ActionsContext.Provider value={actionsValue}>
        {children}
      </ActionsContext.Provider>
    </StateContext.Provider>
  );
}

// 选择性订阅
function useAppSelector<T>(selector: (state: AppState) => T): T {
  const state = useContext(StateContext);
  return useMemo(() => selector(state), [state, selector]);
}

// 使用示例
function UserProfile() {
  const user = useAppSelector(state => state.user);
  const { dispatch } = useContext(ActionsContext);
  
  // 只有user变化时才重新渲染
  return <div>{user?.name}</div>;
}
```



## 原子化状态管理库原理对比

### Zustand 实现原理

```typescript
// Zustand核心实现简化版
type StateCreator<T> = (
  set: (partial: T | Partial<T> | ((state: T) => T | Partial<T>)) => void,
  get: () => T
) => T;

function create<T>(createState: StateCreator<T>) {
  let state: T;
  const listeners = new Set<() => void>();
  
  const setState = (partial: T | Partial<T> | ((state: T) => T | Partial<T>)) => {
    const nextState = typeof partial === 'function' 
      ? (partial as (state: T) => T | Partial<T>)(state)
      : partial;
    
    state = Object.assign({}, state, nextState);
    listeners.forEach(listener => listener());
  };
  
  const getState = () => state;
  
  const subscribe = (listener: () => void) => {
    listeners.add(listener);
    return () => listeners.delete(listener);
  };
  
  state = createState(setState, getState);
  
  return { getState, setState, subscribe };
}

// 实际使用
interface BearStore {
  bears: number;
  increase: () => void;
  decrease: () => void;
  reset: () => void;
}

const useBearStore = create<BearStore>((set, get) => ({
  bears: 0,
  increase: () => set(state => ({ bears: state.bears + 1 })),
  decrease: () => set(state => ({ bears: state.bears - 1 })),
  reset: () => set({ bears: 0 })
}));

// 中间件支持
const log = (config) => (set, get, api) =>
  config(
    (...args) => {
      console.log('Previous state:', get());
      set(...args);
      console.log('New state:', get());
    },
    get,
    api
  );

const useStore = create(log((set) => ({
  count: 0,
  increment: () => set(state => ({ count: state.count + 1 }))
})));
```



### Jotai 实现原理

```typescript
// Jotai核心概念实现
interface Atom<Value> {
  key: string;
  read: (get: Getter) => Value;
  write?: (get: Getter, set: Setter, ...args: any[]) => void;
}

type Getter = <V>(atom: Atom<V>) => V;
type Setter = <V>(atom: Atom<V>, value: V) => void;

// 原子创建
function atom<Value>(
  read: Value | ((get: Getter) => Value),
  write?: (get: Getter, set: Setter, ...args: any[]) => void
): Atom<Value> {
  const key = `${Math.random()}`;
  
  if (typeof read === 'function') {
    return { key, read: read as (get: Getter) => Value, write };
  }
  
  return {
    key,
    read: () => read,
    write: write || ((get, set, newValue) => {
      // 基础原子的默认写操作
      atomValues.set(key, newValue);
    })
  };
}

// 存储原子值
const atomValues = new Map();
const atomDependents = new Map();

// useAtom Hook 实现
function useAtom<Value>(atom: Atom<Value>) {
  const [, forceUpdate] = useReducer(x => x + 1, 0);
  const currentValueRef = useRef<Value>();
  
  const getValue = useCallback(() => {
    const get: Getter = <V>(a: Atom<V>) => {
      // 建立依赖关系
      if (!atomDependents.has(a.key)) {
        atomDependents.set(a.key, new Set());
      }
      atomDependents.get(a.key).add(atom.key);
      
      return atomValues.has(a.key) ? atomValues.get(a.key) : a.read(get);
    };
    
    return atom.read(get);
  }, [atom]);
  
  const setValue = useCallback((newValue: Value) => {
    const get: Getter = (a) => atomValues.get(a.key) || a.read(get);
    const set: Setter = (a, value) => {
      atomValues.set(a.key, value);
      // 通知依赖的原子更新
      if (atomDependents.has(a.key)) {
        atomDependents.get(a.key).forEach(dependent => {
          // 触发重新渲染
        });
      }
    };
    
    if (atom.write) {
      atom.write(get, set, newValue);
    } else {
      set(atom, newValue);
    }
  }, [atom]);
  
  useEffect(() => {
    currentValueRef.current = getValue();
  });
  
  return [currentValueRef.current || getValue(), setValue] as const;
}

// 使用示例
const countAtom = atom(0);
const doubleCountAtom = atom(get => get(countAtom) * 2);

function Counter() {
  const [count, setCount] = useAtom(countAtom);
  const [double] = useAtom(doubleCountAtom);
  
  return (
    <div>
      <p>Count: {count}</p>
      <p>Double: {double}</p>
      <button onClick={() => setCount(c => c + 1)}>+</button>
    </div>
  );
}
```



### Recoil 实现原理

```typescript
// Recoil核心概念
interface RecoilState<T> {
  key: string;
  default: T | ((get: GetRecoilValue) => T);
}

interface RecoilSelector<T> {
  key: string;
  get: (opts: { get: GetRecoilValue }) => T;
  set?: (opts: { get: GetRecoilValue; set: SetRecoilState }, newValue: T) => void;
}

type GetRecoilValue = <T>(recoilVal: RecoilState<T> | RecoilSelector<T>) => T;
type SetRecoilState = <T>(recoilVal: RecoilState<T>, newValue: T) => void;

// atom 实现
function atom<T>(options: { key: string; default: T }): RecoilState<T> {
  return {
    key: options.key,
    default: options.default
  };
}

// selector 实现
function selector<T>(options: {
  key: string;
  get: (opts: { get: GetRecoilValue }) => T;
  set?: (opts: { get: GetRecoilValue; set: SetRecoilState }, newValue: T) => void;
}): RecoilSelector<T> {
  return {
    key: options.key,
    get: options.get,
    set: options.set
  };
}

// RecoilRoot 实现
const RecoilContext = createContext<{
  getState: <T>(recoilVal: RecoilState<T> | RecoilSelector<T>) => T;
  setState: <T>(recoilVal: RecoilState<T>, newValue: T) => void;
  subscribe: (key: string, callback: () => void) => () => void;
} | null>(null);

function RecoilRoot({ children }: { children: ReactNode }) {
  const stateMap = useRef(new Map()).current;
  const listenersMap = useRef(new Map<string, Set<() => void>>()).current;
  
  const getState = useCallback(<T>(recoilVal: RecoilState<T> | RecoilSelector<T>): T => {
    if ('default' in recoilVal) {
      // atom
      return stateMap.has(recoilVal.key) 
        ? stateMap.get(recoilVal.key) 
        : recoilVal.default;
    } else {
      // selector
      return recoilVal.get({ get: getState });
    }
  }, []);
  
  const setState = useCallback(<T>(recoilVal: RecoilState<T>, newValue: T) => {
    stateMap.set(recoilVal.key, newValue);
    
    // 通知监听器
    const listeners = listenersMap.get(recoilVal.key);
    if (listeners) {
      listeners.forEach(callback => callback());
    }
  }, []);
  
  const subscribe = useCallback((key: string, callback: () => void) => {
    if (!listenersMap.has(key)) {
      listenersMap.set(key, new Set());
    }
    listenersMap.get(key)!.add(callback);
    
    return () => {
      listenersMap.get(key)?.delete(callback);
    };
  }, []);
  
  return (
    <RecoilContext.Provider value={{ getState, setState, subscribe }}>
      {children}
    </RecoilContext.Provider>
  );
}

// 使用示例
const textState = atom({
  key: 'textState',
  default: ''
});

const charCountState = selector({
  key: 'charCountState',
  get: ({ get }) => {
    const text = get(textState);
    return text.length;
  }
});
```



![image-20250522151016029](https://raw.githubusercontent.com/JoeyXXia/MyPictureData/main/image-20250522151016029.png)



##  使用 Signals 实现 React 的细粒度更新

### Signals 基础实现

```typescript
// Signal 核心实现
class Signal<T> {
  private _value: T;
  private _subscribers = new Set<() => void>();
  private _computeSubscribers = new Set<ComputedSignal<any>>();
  
  constructor(initialValue: T) {
    this._value = initialValue;
  }
  
  get value(): T {
    // 收集依赖
    if (currentComputed) {
      this._computeSubscribers.add(currentComputed);
      currentComputed.addDependency(this);
    }
    return this._value;
  }
  
  set value(newValue: T) {
    if (this._value !== newValue) {
      this._value = newValue;
      this._notify();
    }
  }
  
  private _notify() {
    this._subscribers.forEach(callback => callback());
    this._computeSubscribers.forEach(computed => computed._recompute());
  }
  
  subscribe(callback: () => void): () => void {
    this._subscribers.add(callback);
    return () => this._subscribers.delete(callback);
  }
}

// 计算信号
let currentComputed: ComputedSignal<any> | null = null;

class ComputedSignal<T> {
  private _value: T;
  private _dependencies = new Set<Signal<any>>();
  private _computeFn: () => T;
  private _subscribers = new Set<() => void>();
  
  constructor(computeFn: () => T) {
    this._computeFn = computeFn;
    this._value = this._compute();
  }
  
  get value(): T {
    return this._value;
  }
  
  private _compute(): T {
    const prevComputed = currentComputed;
    currentComputed = this;
    
    try {
      return this._computeFn();
    } finally {
      currentComputed = prevComputed;
    }
  }
  
  _recompute() {
    const newValue = this._compute();
    if (this._value !== newValue) {
      this._value = newValue;
      this._subscribers.forEach(callback => callback());
    }
  }
  
  addDependency(signal: Signal<any>) {
    this._dependencies.add(signal);
  }
  
  subscribe(callback: () => void): () => void {
    this._subscribers.add(callback);
    return () => this._subscribers.delete(callback);
  }
}

// 创建函数
function signal<T>(initialValue: T): Signal<T> {
  return new Signal(initialValue);
}

function computed<T>(computeFn: () => T): ComputedSignal<T> {
  return new ComputedSignal(computeFn);
}

// React 集成
function useSignal<T>(signal: Signal<T> | ComputedSignal<T>): T {
  const [, forceUpdate] = useReducer(x => x + 1, 0);
  
  useEffect(() => {
    return signal.subscribe(() => {
      forceUpdate();
    });
  }, [signal]);
  
  return signal.value;
}
```

### Signals 在 React 中的使用

```typescript
// 全局状态
const count = signal(0);
const doubled = computed(() => count.value * 2);
const isEven = computed(() => count.value % 2 === 0);

// 用户信息信号
const user = signal<User | null>(null);
const isLoggedIn = computed(() => user.value !== null);
const userName = computed(() => user.value?.name || 'Anonymous');

// React 组件
function Counter() {
  const currentCount = useSignal(count);
  const doubledValue = useSignal(doubled);
  const even = useSignal(isEven);
  
  return (
    <div>
      <p>Count: {currentCount}</p>
      <p>Doubled: {doubledValue}</p>
      <p>Is Even: {even ? 'Yes' : 'No'}</p>
      <button onClick={() => count.value++}>Increment</button>
    </div>
  );
}

// 只有依赖的信号改变时才会重新渲染
function UserProfile() {
  const name = useSignal(userName);
  const loggedIn = useSignal(isLoggedIn);
  
  if (!loggedIn) {
    return <div>Please log in</div>;
  }
  
  return <div>Welcome, {name}!</div>;
}
```

### 效果更新（Effects）

```typescript
// 效果信号
function effect(fn: () => void | (() => void)): () => void {
  let cleanup: (() => void) | void;
  const dependencies = new Set<Signal<any>>();
  
  const run = () => {
    if (cleanup) cleanup();
    
    const prevComputed = currentComputed;
    currentComputed = {
      addDependency: (signal: Signal<any>) => {
        dependencies.add(signal);
      }
    } as any;
    
    try {
      cleanup = fn();
    } finally {
      currentComputed = prevComputed;
    }
  };
  
  // 订阅依赖
  const unsubscribers = Array.from(dependencies).map(signal => 
    signal.subscribe(run)
  );
  
  // 初始运行
  run();
  
  // 返回清理函数
  return () => {
    if (cleanup) cleanup();
    unsubscribers.forEach(unsub => unsub());
  };
}

// 使用效果
effect(() => {
  console.log(`Count changed to: ${count.value}`);
  
  // 清理函数
  return () => {
    console.log('Effect cleanup');
  };
});
```





## React Query 与 SWR 的数据请求状态管理机制

### React Query 核心实现原理

```ts
// React Query 简化实现
interface QueryOptions<T> {
  queryKey: unknown[];
  queryFn: () => Promise<T>;
  staleTime?: number;
  cacheTime?: number;
  refetchOnWindowFocus?: boolean;
  refetchOnReconnect?: boolean;
  retry?: boolean | number;
}

interface QueryState<T> {
  data: T | undefined;
  error: Error | null;
  isLoading: boolean;
  isFetching: boolean;
  isStale: boolean;
  dataUpdatedAt: number;
}

class QueryCache {
  private cache = new Map<string, QueryState<any>>();
  private timers = new Map<string, NodeJS.Timeout>();
  private subscribers = new Map<string, Set<() => void>>();
  
  get<T>(key: string): QueryState<T> | undefined {
    return this.cache.get(key);
  }
  
  set<T>(key: string, state: QueryState<T>) {
    this.cache.set(key, state);
    this.notify(key);
  }
  
  subscribe(key: string, callback: () => void): () => void {
    if (!this.subscribers.has(key)) {
      this.subscribers.set(key, new Set());
    }
    this.subscribers.get(key)!.add(callback);
    
    return () => {
      this.subscribers.get(key)?.delete(callback);
    };
  }
  
  private notify(key: string) {
    this.subscribers.get(key)?.forEach(callback => callback());
  }
  
  remove(key: string) {
    this.cache.delete(key);
    const timer = this.timers.get(key);
    if (timer) {
      clearTimeout(timer);
      this.timers.delete(key);
    }
  }
  
  scheduleGC(key: string, cacheTime: number) {
    const timer = setTimeout(() => {
      this.remove(key);
    }, cacheTime);
    this.timers.set(key, timer);
  }
}

const queryCache = new QueryCache();

function useQuery<T>(options: QueryOptions<T>) {
  const { queryKey, queryFn, staleTime = 0, cacheTime = 5 * 60 * 1000 } = options;
  const key = JSON.stringify(queryKey);
  
  const [, forceUpdate] = useReducer(x => x + 1, 0);
  
  // 获取或初始化查询状态
  const getQueryState = (): QueryState<T> => {
    return queryCache.get(key) || {
      data: undefined,
      error: null,
      isLoading: true,
      isFetching: true,
      isStale: false,
      dataUpdatedAt: 0
    };
  };
  
  const [queryState, setQueryState] = useState(getQueryState);
  
  // 执行查询
  const executeQuery = useCallback(async () => {
    const currentState = getQueryState();
    
    setQueryState(prev => ({ ...prev, isFetching: true, error: null }));
    queryCache.set(key, { ...currentState, isFetching: true, error: null });
    
    try {
      const data = await queryFn();
      const newState = {
        data,
        error: null,
        isLoading: false,
        isFetching: false,
        isStale: false,
        dataUpdatedAt: Date.now()
      };
      
      setQueryState(newState);
      queryCache.set(key, newState);
      
      // 设置过期时间
      if (staleTime > 0) {
        setTimeout(() => {
          const current = queryCache.get(key);
          if (current) {
            queryCache.set(key, { ...current, isStale: true });
          }
        }, staleTime);
      }
      
    } catch (error) {
      const errorState = {
        ...currentState,
        error: error as Error,
        isLoading: false,
        isFetching: false
      };
      
      setQueryState(errorState);
      queryCache.set(key, errorState);
    }
  }, [key, queryFn, staleTime]);
  
  // 订阅缓存更新
  useEffect(() => {
    return queryCache.subscribe(key, () => {
      const newState = queryCache.get(key);
      if (newState) {
        setQueryState(newState);
      }
    });
  }, [key]);
  
  // 初始数据获取
  useEffect(() => {
    const cached = queryCache.get(key);
    if (!cached || cached.isStale) {
      executeQuery();
    } else {
      setQueryState(cached);
    }
  }, [key, executeQuery]);
  
  return {
    ...queryState,
    refetch: executeQuery
  };
}
```



### SWR 核心实现原理

```ts
// SWR 简化实现
interface SWRConfig<T> {
  fetcher?: (key: string) => Promise<T>;
  refreshInterval?: number;
  revalidateOnFocus?: boolean;
  revalidateOnReconnect?: boolean;
  dedupingInterval?: number;
}

interface SWRState<T> {
  data: T | undefined;
  error: Error | undefined;
  isValidating: boolean;
  mutate: (data?: T, shouldRevalidate?: boolean) => Promise<T | undefined>;
}

class SWRCache {
  private cache = new Map<string, any>();
  private mutators = new Map<string, Set<(data: any) => void>>();
  private revalidators = new Map<string, Set<() => void>>();
  private timestamps = new Map<string, number>();
  
  get(key: string) {
    return this.cache.get(key);
  }
  
  set(key: string, data: any) {
    this.cache.set(key, data);
    this.timestamps.set(key, Date.now());
    this.broadcast(key, data);
  }
  
  subscribe(key: string, callback: (data: any) => void): () => void {
    if (!this.mutators.has(key)) {
      this.mutators.set(key, new Set());
    }
    this.mutators.get(key)!.add(callback);
    
    return () => {
      this.mutators.get(key)?.delete(callback);
    };
  }
  
  subscribeRevalidate(key: string, callback: () => void): () => void {
    if (!this.revalidators.has(key)) {
      this.revalidators.set(key, new Set());
    }
    this.revalidators.get(key)!.add(callback);
    
    return () => {
      this.revalidators.get(key)?.delete(callback);
    };
  }
  
  private broadcast(key: string, data: any) {
    this.mutators.get(key)?.forEach(callback => callback(data));
  }
  
  revalidate(key: string) {
    this.revalidators.get(key)?.forEach(callback => callback());
  }
  
  isStale(key: string, dedupingInterval: number): boolean {
    const timestamp = this.timestamps.get(key);
    return !timestamp || (Date.now() - timestamp) > dedupingInterval;
  }
}

const swrCache = new SWRCache();

function useSWR<T>(
  key: string, 
  fetcher?: (key: string) => Promise<T>, 
  config: SWRConfig<T> = {}
): SWRState<T> {
  const {
    refreshInterval,
    revalidateOnFocus = true,
    revalidateOnReconnect = true,
    dedupingInterval = 2000
  } = config;
  
  const [data, setData] = useState<T | undefined>(swrCache.get(key));
  const [error, setError] = useState<Error | undefined>();
  const [isValidating, setIsValidating] = useState(false);
  
  const revalidate = useCallback(async () => {
    if (!fetcher || !swrCache.isStale(key, dedupingInterval)) {
      return data;
    }
    
    setIsValidating(true);
    setError(undefined);
    
    try {
      const newData = await fetcher(key);
      swrCache.set(key, newData);
      setData(newData);
      return newData;
    } catch (err) {
      setError(err as Error);
      throw err;
    } finally {
      setIsValidating(false);
    }
  }, [key, fetcher, data, dedupingInterval]);
  
  const mutate = useCallback(async (
    newData?: T, 
    shouldRevalidate = true
  ): Promise<T | undefined> => {
    if (newData !== undefined) {
      swrCache.set(key, newData);
      setData(newData);
    }
    
    if (shouldRevalidate) {
      return revalidate();
    }
    
    return newData;
  }, [key, revalidate]);
  
  // 订阅缓存更新
  useEffect(() => {
    return swrCache.subscribe(key, (newData) => {
      setData(newData);
    });
  }, [key]);
  
  // 订阅重新验证
  useEffect(() => {
    return swrCache.subscribeRevalidate(key, revalidate);
  }, [key, revalidate]);
  
  // 初始数据获取
  useEffect(() => {
    const cachedData = swrCache.get(key);
    if (cachedData) {
      setData(cachedData);
    } else if (fetcher) {
      revalidate();
    }
  }, [key, fetcher, revalidate]);
  
  // 定时刷新
  useEffect(() => {
    if (refreshInterval && refreshInterval > 0) {
      const timer = setInterval(revalidate, refreshInterval);
      return () => clearInterval(timer);
    }
  }, [refreshInterval, revalidate]);
  
  // 窗口焦点重新验证
  useEffect(() => {
    if (revalidateOnFocus) {
      const handleFocus = () => swrCache.revalidate(key);
      window.addEventListener('focus', handleFocus);
      return () => window.removeEventListener('focus', handleFocus);
    }
  }, [key, revalidateOnFocus]);
  
  // 网络重连重新验证
  useEffect(() => {
    if (revalidateOnReconnect) {
      const handleOnline = () => swrCache.revalidate(key);
      window.addEventListener('online', handleOnline);
      return () => window.removeEventListener('online', handleOnline);
    }
  }, [key, revalidateOnReconnect]);
  
  return { data, error, isValidating, mutate };
}
```



![image-20250522151158332](https://raw.githubusercontent.com/JoeyXXia/MyPictureData/main/image-20250522151158332.png)





## 客户端缓存策略设计与实现

### 多层缓存架构

```ts
// 缓存层级定义
enum CacheLevel {
  MEMORY = 'memory',
  SESSION_STORAGE = 'sessionStorage',
  LOCAL_STORAGE = 'localStorage',
  INDEXED_DB = 'indexedDB'
}

interface CacheItem<T> {
  data: T;
  timestamp: number;
  expiry?: number;
  version?: string;
  tags?: string[];
}

interface CacheStrategy {
  level: CacheLevel;
  maxAge?: number;
  maxSize?: number;
  priority?: number;
}

// 抽象缓存接口
abstract class CacheAdapter<T> {
  abstract get(key: string): Promise<CacheItem<T> | null>;
  abstract set(key: string, item: CacheItem<T>): Promise<void>;
  abstract delete(key: string): Promise<void>;
  abstract clear(): Promise<void>;
  abstract keys(): Promise<string[]>;
}

// 内存缓存实现
class MemoryCache<T> extends CacheAdapter<T> {
  private cache = new Map<string, CacheItem<T>>();
  private maxSize: number;
  
  constructor(maxSize = 100) {
    super();
    this.maxSize = maxSize;
  }
  
  async get(key: string): Promise<CacheItem<T> | null> {
    const item = this.cache.get(key);
    
    if (!item) return null;
    
    // 检查过期
    if (item.expiry && Date.now() > item.expiry) {
      this.cache.delete(key);
      return null;
    }
    
    return item;
  }
  
  async set(key: string, item: CacheItem<T>): Promise<void> {
    // LRU 清理
    if (this.cache.size >= this.maxSize) {
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
    
    this.cache.set(key, item);
  }
  
  async delete(key: string): Promise<void> {
    this.cache.delete(key);
  }
  
  async clear(): Promise<void> {
    this.cache.clear();
  }
  
  async keys(): Promise<string[]> {
    return Array.from(this.cache.keys());
  }
}

// LocalStorage 缓存实现
class LocalStorageCache<T> extends CacheAdapter<T> {
  private prefix: string;
  
  constructor(prefix = 'cache_') {
    super();
    this.prefix = prefix;
  }
  
  async get(key: string): Promise<CacheItem<T> | null> {
    try {
      const item = localStorage.getItem(this.prefix + key);
      if (!item) return null;
      
      const parsed = JSON.parse(item) as CacheItem<T>;
      
      // 检查过期
      if (parsed.expiry && Date.now() > parsed.expiry) {
        await this.delete(key);
        return null;
      }
      
      return parsed;
    } catch {
      return null;
    }
  }
  
  async set(key: string, item: CacheItem<T>): Promise<void> {
    try {
      localStorage.setItem(this.prefix + key, JSON.stringify(item));
    } catch (error) {
      // 存储空间不足时清理过期项
      await this.cleanup();
      localStorage.setItem(this.prefix + key, JSON.stringify(item));
    }
  }
  
  async delete(key: string): Promise<void> {
    localStorage.removeItem(this.prefix + key);
  }
  
  async clear(): Promise<void> {
    const keys = await this.keys();
    keys.forEach(key => localStorage.removeItem(this.prefix + key));
  }
  
  async keys(): Promise<string[]> {
    const keys: string[] = [];
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (key?.startsWith(this.prefix)) {
        keys.push(key.substring(this.prefix.length));
      }
    }
    return keys;
  }
  
  private async cleanup(): Promise<void> {
    const keys = await this.keys();
    for (const key of keys) {
      const item = await this.get(key);
      if (!item) {
        await this.delete(key);
      }
    }
  }
}

// 多层缓存管理器
class MultiLevelCache<T> {
  private adapters: Map<CacheLevel, CacheAdapter<T>> = new Map();
  private strategies: CacheStrategy[];
  
  constructor(strategies: CacheStrategy[]) {
    this.strategies = strategies.sort((a, b) => (a.priority || 0) - (b.priority || 0));
    
    // 初始化适配器
    strategies.forEach(strategy => {
      switch (strategy.level) {
        case CacheLevel.MEMORY:
          this.adapters.set(strategy.level, new MemoryCache<T>());
          break;
        case CacheLevel.LOCAL_STORAGE:
          this.adapters.set(strategy.level, new LocalStorageCache<T>());
          break;
        // 其他适配器...
      }
    });
  }
  
  async get(key: string): Promise<T | null> {
    for (const strategy of this.strategies) {
      const adapter = this.adapters.get(strategy.level);
      if (adapter) {
        const item = await adapter.get(key);
        if (item) {
          // 向上层缓存同步数据
          await this.promoteToHigherLevels(key, item, strategy);
          return item.data;
        }
      }
    }
    return null;
  }
  
  async set(key: string, data: T, options: { tags?: string[]; ttl?: number } = {}): Promise<void> {
    const item: CacheItem<T> = {
      data,
      timestamp: Date.now(),
      expiry: options.ttl ? Date.now() + options.ttl : undefined,
      tags: options.tags
    };
    
    // 写入所有层级
    await Promise.all(
      this.strategies.map(async strategy => {
        const adapter = this.adapters.get(strategy.level);
        if (adapter) {
          await adapter.set(key, item);
        }
      })
    );
  }
  
  async invalidate(key: string): Promise<void> {
    await Promise.all(
      Array.from(this.adapters.values()).map(adapter => adapter.delete(key))
    );
  }
  
  async invalidateByTags(tags: string[]): Promise<void> {
    for (const adapter of this.adapters.values()) {
      const keys = await adapter.keys();
      for (const key of keys) {
        const item = await adapter.get(key);
        if (item?.tags?.some(tag => tags.includes(tag))) {
          await adapter.delete(key);
        }
      }
    }
  }
  
  private async promoteToHigherLevels(
    key: string, 
    item: CacheItem<T>, 
    currentStrategy: CacheStrategy
  ): Promise<void> {
    const currentIndex = this.strategies.indexOf(currentStrategy);
    const higherStrategies = this.strategies.slice(0, currentIndex);
    
    await Promise.all(
      higherStrategies.map(async strategy => {
        const adapter = this.adapters.get(strategy.level);
        if (adapter) {
          await adapter.set(key, item);
        }
      })
    );
  }
}
```





### 缓存使用示例

```ts
// 配置多层缓存
const cache = new MultiLevelCache([
  { level: CacheLevel.MEMORY, maxAge: 5 * 60 * 1000, priority: 1 }, // 5分钟
  { level: CacheLevel.LOCAL_STORAGE, maxAge: 24 * 60 * 60 * 1000, priority: 2 } // 24小时
]);

// 使用缓存的 Hook
function useCachedData<T>(
  key: string,
  fetcher: () => Promise<T>,
  options: { ttl?: number; tags?: string[] } = {}
) {
  const [data, setData] = useState<T | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);
  
  const fetchData = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      
      // 尝试从缓存获取
      const cached = await cache.get(key);
      if (cached) {
        setData(cached);
        setLoading(false);
        return;
      }
      
      // 从远程获取
      const result = await fetcher();
      await cache.set(key, result, options);
      setData(result);
    } catch (err) {
      setError(err as Error);
    } finally {
      setLoading(false);
    }
  }, [key, fetcher, options]);
  
  useEffect(() => {
    fetchData();
  }, [fetchData]);
  
  const mutate = useCallback(async (newData: T) => {
    await cache.set(key, newData, options);
    setData(newData);
  }, [key, options]);
  
  const invalidate = useCallback(async () => {
    await cache.invalidate(key);
    await fetchData();
  }, [key, fetchData]);
  
  return { data, loading, error, mutate, invalidate, refetch: fetchData };
}
```





## 全局状态、页面状态、组件状态的分层管理策略

### 状态分层架构

```ts
// 状态层级定义
enum StateScope {
  GLOBAL = 'global',      // 全局状态：用户信息、主题、语言等
  FEATURE = 'feature',    // 功能状态：特定功能模块的状态
  PAGE = 'page',          // 页面状态：当前页面的临时状态
  COMPONENT = 'component' // 组件状态：组件内部状态
}

// 全局状态管理
interface GlobalState {
  auth: {
    user: User | null;
    isAuthenticated: boolean;
    permissions: string[];
  };
  ui: {
    theme: 'light' | 'dark';
    language: string;
    sidebarCollapsed: boolean;
  };
  notifications: Notification[];
}

const useGlobalStore = create<GlobalState & {
  // Actions
  setUser: (user: User | null) => void;
  setTheme: (theme: 'light' | 'dark') => void;
  addNotification: (notification: Notification) => void;
  removeNotification: (id: string) => void;
}>((set, get) => ({
  // Initial state
  auth: {
    user: null,
    isAuthenticated: false,
    permissions: []
  },
  ui: {
    theme: 'light',
    language: 'en',
    sidebarCollapsed: false
  },
  notifications: [],
  
  // Actions
  setUser: (user) => set(state => ({
    auth: {
      ...state.auth,
      user,
      isAuthenticated: !!user,
      permissions: user?.permissions || []
    }
  })),
  
  setTheme: (theme) => set(state => ({
    ui: { ...state.ui, theme }
  })),
  
  addNotification: (notification) => set(state => ({
    notifications: [...state.notifications, notification]
  })),
  
  removeNotification: (id) => set(state => ({
    notifications: state.notifications.filter(n => n.id !== id)
  }))
}));

// 功能级状态管理（如电商购物车）
interface CartState {
  items: CartItem[];
  total: number;
  discount: number;
}

const useCartStore = create<CartState & {
  addItem: (item: Product, quantity: number) => void;
  removeItem: (id: string) => void;
  updateQuantity: (id: string, quantity: number) => void;
  clear: () => void;
}>((set, get) => ({
  items: [],
  total: 0,
  discount: 0,
  
  addItem: (product, quantity) => set(state => {
    const existingItem = state.items.find(item => item.id === product.id);
    let newItems;
    
    if (existingItem) {
      newItems = state.items.map(item =>
        item.id === product.id 
          ? { ...item, quantity: item.quantity + quantity }
          : item
      );
    } else {
      newItems = [...state.items, { ...product, quantity }];
    }
    
    const total = newItems.reduce((sum, item) => sum + item.price * item.quantity, 0);
    
    return { items: newItems, total };
  }),
  
  removeItem: (id) => set(state => {
    const newItems = state.items.filter(item => item.id !== id);
    const total = newItems.reduce((sum, item) => sum + item.price * item.quantity, 0);
    return { items: newItems, total };
  }),
  
  updateQuantity: (id, quantity) => set(state => {
    if (quantity <= 0) {
      return get().removeItem(id);
    }
    
    const newItems = state.items.map(item =>
      item.id === id ? { ...item, quantity } : item
    );
    const total = newItems.reduce((sum, item) => sum + item.price * item.quantity, 0);
    
    return { items: newItems, total };
  }),
  
  clear: () => set({ items: [], total: 0, discount: 0 })
}));

// 页面级状态管理
interface ProductListPageState {
  filters: {
    category: string[];
    priceRange: [number, number];
    rating: number;
    inStock: boolean;
  };
  sorting: {
    field: string;
    direction: 'asc' | 'desc';
  };
  pagination: {
    page: number;
    pageSize: number;
    total: number;
  };
  view: 'grid' | 'list';
}

function useProductListPage() {
  const [state, setState] = useState<ProductListPageState>({
    filters: {
      category: [],
      priceRange: [0, 1000],
      rating: 0,
      inStock: false
    },
    sorting: {
      field: 'name',
      direction: 'asc'
    },
    pagination: {
      page: 1,
      pageSize: 20,
      total: 0
    },
    view: 'grid'
  });
  
  const updateFilters = useCallback((newFilters: Partial<typeof state.filters>) => {
    setState(prev => ({
      ...prev,
      filters: { ...prev.filters, ...newFilters },
      pagination: { ...prev.pagination, page: 1 } // 重置页码
    }));
  }, []);
  
  const updateSorting = useCallback((field: string, direction: 'asc' | 'desc') => {
    setState(prev => ({
      ...prev,
      sorting: { field, direction },
      pagination: { ...prev.pagination, page: 1 }
    }));
  }, []);
  
  const updatePagination = useCallback((updates: Partial<typeof state.pagination>) => {
    setState(prev => ({
      ...prev,
      pagination: { ...prev.pagination, ...updates }
    }));
  }, []);
  
  return {
    state,
    updateFilters,
    updateSorting,
    updatePagination,
    setView: (view: 'grid' | 'list') => setState(prev => ({ ...prev, view }))
  };
}
```



### 状态选择策略

```ts
// 状态选择决策树
class StateManager {
  static shouldUseGlobalState(criteria: {
    persistAcrossPages?: boolean;
    sharedByMultipleComponents?: boolean;
    needsServerSync?: boolean;
    criticalForApp?: boolean;
  }): boolean {
    return !!(
      criteria.persistAcrossPages ||
      criteria.sharedByMultipleComponents ||
      criteria.criticalForApp
    );
  }
  
  static shouldUsePageState(criteria: {
    pageSpecific?: boolean;
    temporaryData?: boolean;
    formData?: boolean;
    uiState?: boolean;
  }): boolean {
    return !!(
      criteria.pageSpecific ||
      criteria.temporaryData ||
      criteria.formData ||
      criteria.uiState
    );
  }
  
  static shouldUseComponentState(criteria: {
    componentSpecific?: boolean;
    shortLived?: boolean;
    simpleData?: boolean;
  }): boolean {
    return !!(
      criteria.componentSpecific ||
      criteria.shortLived ||
      criteria.simpleData
    );
  }
}

// 使用示例
function MyComponent() {
  // 全局状态 - 用户信息
  const user = useGlobalStore(state => state.auth.user);
  
  // 功能状态 - 购物车
  const cartItems = useCartStore(state => state.items);
  
  // 页面状态 - 筛选条件
  const { state: pageState, updateFilters } = useProductListPage();
  
  // 组件状态 - 模态框显示
  const [showModal, setShowModal] = useState(false);
  
  return (
    <div>
      <UserInfo user={user} />
      <CartSummary items={cartItems} />
      <ProductFilters filters={pageState.filters} onUpdate={updateFilters} />
      <Modal show={showModal} onClose={() => setShowModal(false)} />
    </div>
  );
}
```



## 大型 React 应用的状态管理选型与实践



### 选型决策矩阵

```typescript
interface ProjectRequirements {
  teamSize: 'small' | 'medium' | 'large';
  complexity: 'low' | 'medium' | 'high';
  performanceNeeds: 'basic' | 'optimized' | 'critical';
  devExperience: 'junior' | 'mixed' | 'senior';
  maintainability: 'short' | 'medium' | 'long';
  bundleSize: 'flexible' | 'moderate' | 'strict';
}

class StateManagementSelector {
  static recommend(requirements: ProjectRequirements): {
    primary: string;
    secondary?: string;
    reasoning: string;
  } {
    const { teamSize, complexity, performanceNeeds, devExperience } = requirements;
    
    // 简单应用
    if (complexity === 'low' && teamSize === 'small') {
      return {
        primary: 'Context + useReducer',
        reasoning: '简单应用使用原生方案即可，减少依赖'
      };
    }
    
    // 中小型应用
    if (complexity === 'medium' || teamSize === 'medium') {
      if (performanceNeeds === 'critical') {
        return {
          primary: 'Zustand',
          secondary: 'Jotai (for specific features)',
          reasoning: 'Zustand 提供良好的性能和简单的 API'
        };
      }
      
      if (devExperience === 'junior') {
        return {
          primary: 'Redux Toolkit',
          secondary: 'React Query',
          reasoning: 'RTK 提供最佳实践和良好的开发工具'
        };
      }
      
      return {
        primary: 'Zustand',
        secondary: 'SWR',
        reasoning: '轻量级且功能强大，适合快速开发'
      };
    }
    
    // 大型复杂应用
    if (complexity === 'high' || teamSize === 'large') {
      return {
        primary: 'Redux Toolkit',
        secondary: 'React Query + Zustand',
        reasoning: '大型应用需要可预测的状态管理和强大的调试工具'
      };
    }
    
    return {
      primary: 'Zustand',
      reasoning: '通用推荐方案'
    };
  }
}
```





### 混合状态管理架构

```typescript
// 企业级应用的混合架构
interface AppStateArchitecture {
  // 全局业务状态 - Redux Toolkit
  business: {
    auth: AuthState;
    permissions: PermissionState;
    organization: OrganizationState;
  };
  
  // UI 状态 - Zustand
  ui: {
    theme: ThemeState;
    layout: LayoutState;
    modals: ModalState;
  };
  
  // 服务端状态 - React Query
  server: {
    users: QueryState<User[]>;
    products: QueryState<Product[]>;
    orders: QueryState<Order[]>;
  };
  
  // 表单状态 - React Hook Form
  forms: {
    [formId: string]: FormState;
  };
}

// 状态管理层配置
class StateArchitecture {
  // Redux store 配置
  static configureReduxStore() {
    return configureStore({
      reducer: {
        auth: authSlice.reducer,
        permissions: permissionsSlice.reducer,
        organization: organizationSlice.reducer
      },
      middleware: (getDefaultMiddleware) =>
        getDefaultMiddleware({
          serializableCheck: {
            ignoredActions: ['persist/PERSIST']
          }
        }).concat([
          // 自定义中间件
          authMiddleware,
          loggingMiddleware
        ]),
      devTools: process.env.NODE_ENV !== 'production'
    });
  }
  
  // Zustand UI 状态
  static createUIStore() {
    return create<UIState>((set, get) => ({
      theme: 'light',
      sidebarOpen: true,
      activeModals: [],
      
      toggleTheme: () => set(state => ({ 
        theme: state.theme === 'light' ? 'dark' : 'light' 
      })),
      
      toggleSidebar: () => set(state => ({ 
        sidebarOpen: !state.sidebarOpen 
      })),
      
      openModal: (modal) => set(state => ({
        activeModals: [...state.activeModals, modal]
      })),
      
      closeModal: (modalId) => set(state => ({
        activeModals: state.activeModals.filter(m => m.id !== modalId)
      }))
    }));
  }
  
  // React Query 配置
  static configureQueryClient() {
    return new QueryClient({
      defaultOptions: {
        queries: {
          staleTime: 5 * 60 * 1000, // 5分钟
          cacheTime: 10 * 60 * 1000, // 10分钟
          retry: (failureCount, error) => {
            if (error.status === 404) return false;
            return failureCount < 3;
          }
        },
        mutations: {
          retry: 1
        }
      },
      queryCache: new QueryCache({
        onError: (error) => {
          console.error('Query error:', error);
          // 全局错误处理
        }
      })
    });
  }
}

// 应用根组件设置
function AppRoot() {
  const store = StateArchitecture.configureReduxStore();
  const queryClient = StateArchitecture.configureQueryClient();
  
  return (
    <Provider store={store}>
      <QueryClientProvider client={queryClient}>
        <App />
        <ReactQueryDevtools initialIsOpen={false} />
      </QueryClientProvider>
    </Provider>
  );
}
```





### 性能优化最佳实践

```typescript
// 状态分片和选择器优化
const useOptimizedSelector = <T>(
  selector: (state: RootState) => T,
  equalityFn?: (a: T, b: T) => boolean
) => {
  return useSelector(selector, equalityFn || shallowEqual);
};

// 记忆化选择器
const selectUserPreferences = createSelector(
  [(state: RootState) => state.auth.user],
  (user) => ({
    theme: user?.preferences?.theme || 'light',
    language: user?.preferences?.language || 'en',
    notifications: user?.preferences?.notifications || true
  })
);

// 组件级优化
const OptimizedComponent = memo(({ userId }: { userId: string }) => {
  // 只订阅需要的数据
  const user = useOptimizedSelector(state => 
    state.users.entities[userId]
  );
  
  const handleUpdate = useCallback((data: Partial<User>) => {
    // 乐观更新
    dispatch(updateUserOptimistic({ id: userId, data }));
  }, [userId, dispatch]);
  
  return <UserCard user={user} onUpdate={handleUpdate} />;
});

// 状态正规化
interface NormalizedState<T> {
  ids: string[];
  entities: Record<string, T>;
}

const createNormalizedSlice = <T extends { id: string }>(
  name: string,
  initialState: NormalizedState<T> = { ids: [], entities: {} }
) => {
  return createSlice({
    name,
    initialState,
    reducers: {
      setAll: (state, action: PayloadAction<T[]>) => {
        state.ids = action.payload.map(item => item.id);
        state.entities = action.payload.reduce((acc, item) => {
          acc[item.id] = item;
          return acc;
        }, {} as Record<string, T>);
      },
      
      addOne: (state, action: PayloadAction<T>) => {
        const item = action.payload;
        if (!state.entities[item.id]) {
          state.ids.push(item.id);
        }
        state.entities[item.id] = item;
      },
      
      updateOne: (state, action: PayloadAction<{ id: string; changes: Partial<T> }>) => {
        const { id, changes } = action.payload;
        if (state.entities[id]) {
          Object.assign(state.entities[id], changes);
        }
      },
      
      removeOne: (state, action: PayloadAction<string>) => {
        const id = action.payload;
        delete state.entities[id];
        state.ids = state.ids.filter(existingId => existingId !== id);
      }
    }
  });
};

// 状态持久化
const persistConfig = {
  key: 'root',
  storage,
  whitelist: ['auth', 'ui'], // 只持久化特定的状态
  transforms: [
    // 压缩状态
    createTransform(
      (inboundState, key) => {
        return key === 'cache' ? compressState(inboundState) : inboundState;
      },
      (outboundState, key) => {
        return key === 'cache' ? decompressState(outboundState) : outboundState;
      }
    )
  ]
};

// 状态迁移
const migrations = {
  0: (state: any) => {
    // 迁移到版本 1
    return {
      ...state,
      version: 1
    };
  },
  1: (state: any) => {
    // 迁移到版本 2
    return {
      ...state,
      user: {
        ...state.user,
        preferences: state.user.settings // 重命名字段
      },
      version: 2
    };
  }
};

const persistedReducer = persistReducer(
  { ...persistConfig, version: 2, migrate: createMigrate(migrations) },
  rootReducer
);
```

### 测试策略

```typescript
// Redux 状态测试
describe('Auth Slice', () => {
  it('should handle login success', () => {
    const user = { id: '1', name: 'John', email: 'john@example.com' };
    const action = loginSuccess(user);
    const state = authReducer(initialState, action);
    
    expect(state.user).toEqual(user);
    expect(state.isAuthenticated).toBe(true);
    expect(state.loading).toBe(false);
  });
  
  it('should handle logout', () => {
    const initialStateWithUser = {
      ...initialState,
      user: { id: '1', name: 'John' },
      isAuthenticated: true
    };
    
    const action = logout();
    const state = authReducer(initialStateWithUser, action);
    
    expect(state.user).toBeNull();
    expect(state.isAuthenticated).toBe(false);
  });
});

// Zustand 状态测试
describe('UI Store', () => {
  let store: any;
  
  beforeEach(() => {
    store = create<UIState>((set) => ({
      theme: 'light',
      toggleTheme: () => set(state => ({ 
        theme: state.theme === 'light' ? 'dark' : 'light' 
      }))
    }));
  });
  
  it('should toggle theme', () => {
    expect(store.getState().theme).toBe('light');
    
    store.getState().toggleTheme();
    expect(store.getState().theme).toBe('dark');
    
    store.getState().toggleTheme();
    expect(store.getState().theme).toBe('light');
  });
});

// React Query 测试
describe('User Queries', () => {
  it('should fetch user data', async () => {
    const queryClient = new QueryClient({
      defaultOptions: { queries: { retry: false } }
    });
    
    const { result, waitFor } = renderHook(
      () => useQuery(['user', '1'], () => fetchUser('1')),
      {
        wrapper: ({ children }) => (
          <QueryClientProvider client={queryClient}>
            {children}
          </QueryClientProvider>
        )
      }
    );
    
    await waitFor(() => result.current.isSuccess);
    
    expect(result.current.data).toEqual({
      id: '1',
      name: 'John Doe'
    });
  });
});

// 集成测试
describe('App Integration', () => {
  it('should handle user login flow', async () => {
    const { getByText, getByLabelText } = render(<App />);
    
    // 输入登录信息
    fireEvent.change(getByLabelText('Email'), { 
      target: { value: 'john@example.com' } 
    });
    fireEvent.change(getByLabelText('Password'), { 
      target: { value: 'password' } 
    });
    
    // 点击登录
    fireEvent.click(getByText('Login'));
    
    // 验证登录成功
    await waitFor(() => {
      expect(getByText('Welcome, John!')).toBeInTheDocument();
    });
  });
});
```

### 监控和调试

```typescript
// 状态变化监控
const stateMonitor = (store: any) => (next: any) => (action: any) => {
  const prevState = store.getState();
  const result = next(action);
  const nextState = store.getState();
  
  // 性能监控
  console.group(`Action: ${action.type}`);
  console.log('Previous State:', prevState);
  console.log('Action:', action);
  console.log('Next State:', nextState);
  console.groupEnd();
  
  // 发送到监控服务
  if (process.env.NODE_ENV === 'production') {
    analytics.track('state_change', {
      action: action.type,
      timestamp: Date.now(),
      stateSize: JSON.stringify(nextState).length
    });
  }
  
  return result;
};

// 错误边界
class StateErrorBoundary extends Component<
  { children: ReactNode },
  { hasError: boolean; error?: Error }
> {
  constructor(props: any) {
    super(props);
    this.state = { hasError: false };
  }
  
  static getDerivedStateFromError(error: Error) {
    return { hasError: true, error };
  }
  
  componentDidCatch(error: Error, errorInfo: any) {
    console.error('State Error:', error, errorInfo);
    
    // 发送错误报告
    errorReporting.captureException(error, {
      tags: { component: 'StateErrorBoundary' },
      extra: errorInfo
    });
  }
  
  render() {
    if (this.state.hasError) {
      return (
        <div>
          <h2>Something went wrong with state management.</h2>
          <button onClick={() => this.setState({ hasError: false })}>
            Try again
          </button>
        </div>
      );
    }
    
    return this.props.children;
  }
}

// 开发工具集成
const devTools = () => {
  if (process.env.NODE_ENV === 'development') {
    // Redux DevTools
    window.__REDUX_DEVTOOLS_EXTENSION__?.connect();
    
    // Zustand DevTools
    import('zustand/middleware').then(({ devtools }) => {
      // 配置 Zustand 开发工具
    });
    
    // React Query DevTools 自动启用
  }
};
```

### 总结与最佳实践

```typescript
// 状态管理最佳实践清单
const bestPractices = {
  architecture: [
    '明确区分全局状态、页面状态和组件状态',
    '使用合适的状态管理库，避免过度工程化',
    '保持状态结构扁平化，避免深层嵌套',
    '实现状态的规范化存储'
  ],
  
  performance: [
    '使用选择器避免不必要的重新渲染',
    '合理使用 React.memo 和 useMemo',
    '实现虚拟化长列表',
    '使用 Suspense 进行代码分割'
  ],
  
  maintainability: [
    '保持 action 和 reducer 的纯函数特性',
    '使用 TypeScript 提供类型安全',
    '编写全面的测试覆盖',
    '建立清晰的状态更新模式'
  ],
  
  scalability: [
    '模块化状态管理',
    '使用中间件扩展功能',
    '实现状态持久化和迁移',
    '建立监控和错误处理机制'
  ]
};

// 迁移策略
const migrationStrategy = {
  fromLegacy: {
    'Class Components + setState': {
      to: 'Hooks + Context',
      steps: [
        '1. 识别共享状态',
        '2. 创建 Context Provider',
        '3. 逐步迁移组件',
        '4. 优化性能'
      ]
    },
    
    'Redux (Legacy)': {
      to: 'Redux Toolkit',
      steps: [
        '1. 安装 @reduxjs/toolkit',
        '2. 使用 createSlice 重写 reducers',
        '3. 使用 configureStore',
        '4. 迁移中间件'
      ]
    },
    
    'MobX': {
      to: 'Zustand',
      steps: [
        '1. 识别 observable 状态',
        '2. 创建 Zustand store',
        '3. 替换 observer 组件',
        '4. 测试和验证'
      ]
    }
  }
};

export {
  StateArchitecture,
  StateManager,
  bestPractices,
  migrationStrategy
};
```





# React 前端架构设计

##  React 应用的整洁架构 (Clean Architecture) 实现

### 核心原则

整洁架构的核心是依赖倒置原则，外层依赖内层，内层不依赖外层。

### 分层结构

```
src/
├── domain/           # 业务逻辑层（最内层）
│   ├── entities/     # 实体
│   ├── usecases/     # 用例
│   └── interfaces/   # 接口定义
├── application/      # 应用层
│   ├── services/     # 应用服务
│   └── dtos/         # 数据传输对象
├── infrastructure/   # 基础设施层
│   ├── api/          # API适配器
│   ├── storage/      # 存储适配器
│   └── external/     # 外部服务
└── presentation/     # 表现层（最外层）
    ├── components/   # UI组件
    ├── pages/        # 页面组件
    └── hooks/        # 自定义Hook
```

### 实现示例

**Domain层 - 用户实体**t

```typescript
// domain/entities/User.ts
export interface User {
  id: string;
  name: string;
  email: string;
}

export class UserEntity {
  constructor(
    private id: string,
    private name: string,
    private email: string
  ) {}

  validateEmail(): boolean {
    return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(this.email);
  }

  getDisplayName(): string {
    return this.name || this.email.split('@')[0];
  }
}
```

**Domain层 - 用例接口**

```typescript
// domain/usecases/UserUseCase.ts
export interface IUserRepository {
  findById(id: string): Promise<User>;
  save(user: User): Promise<User>;
}

export class GetUserUseCase {
  constructor(private userRepository: IUserRepository) {}

  async execute(id: string): Promise<User> {
    const user = await this.userRepository.findById(id);
    if (!user) {
      throw new Error('User not found');
    }
    return user;
  }
}
```

**Infrastructure层 - 仓储实现**

```typescript
// infrastructure/repositories/UserRepository.ts
export class UserRepository implements IUserRepository {
  async findById(id: string): Promise<User> {
    const response = await fetch(`/api/users/${id}`);
    return response.json();
  }

  async save(user: User): Promise<User> {
    const response = await fetch('/api/users', {
      method: 'POST',
      body: JSON.stringify(user),
    });
    return response.json();
  }
}
```

**Presentation层 - React组件**

```typescript
// presentation/hooks/useUser.ts
export const useUser = (id: string) => {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const userRepository = new UserRepository();
    const getUserUseCase = new GetUserUseCase(userRepository);
    
    getUserUseCase.execute(id)
      .then(setUser)
      .finally(() => setLoading(false));
  }, [id]);

  return { user, loading };
};
```



## 领域驱动设计 (DDD) 在 React 前端的实践

### 核心概念在前端的映射

- **聚合根 (Aggregate Root)**: 复杂组件的状态管理中心
- **值对象 (Value Objects)**: 不可变的数据结构
- **领域服务 (Domain Services)**: 业务逻辑服务
- **仓储 (Repository)**: 数据访问抽象

### 实践架构

```
src/
├── domains/
│   ├── user/
│   │   ├── entities/
│   │   ├── services/
│   │   ├── repositories/
│   │   └── components/
│   └── order/
│       ├── entities/
│       ├── services/
│       ├── repositories/
│       └── components/
└── shared/
    ├── components/
    ├── services/
    └── utils/
```





### 聚合根实现示例

```typescript
// domains/order/entities/OrderAggregate.ts
export class OrderAggregate {
  private constructor(
    private id: string,
    private items: OrderItem[],
    private status: OrderStatus,
    private customerId: string
  ) {}

  static create(customerId: string): OrderAggregate {
    return new OrderAggregate(
      generateId(),
      [],
      OrderStatus.DRAFT,
      customerId
    );
  }

  addItem(product: Product, quantity: number): void {
    if (this.status !== OrderStatus.DRAFT) {
      throw new Error('Cannot modify confirmed order');
    }
    
    const existingItem = this.items.find(item => 
      item.productId === product.id
    );

    if (existingItem) {
      existingItem.updateQuantity(quantity);
    } else {
      this.items.push(new OrderItem(product, quantity));
    }
  }

  getTotalAmount(): Money {
    return this.items.reduce(
      (total, item) => total.add(item.getSubtotal()),
      Money.zero()
    );
  }

  confirm(): void {
    if (this.items.length === 0) {
      throw new Error('Cannot confirm empty order');
    }
    this.status = OrderStatus.CONFIRMED;
  }
}
```

### 领域服务示例

```typescript
// domains/order/services/OrderDomainService.ts
export class OrderDomainService {
  constructor(
    private inventoryService: InventoryService,
    private pricingService: PricingService
  ) {}

  async validateOrder(order: OrderAggregate): Promise<ValidationResult> {
    const validations = await Promise.all([
      this.validateInventory(order),
      this.validatePricing(order),
    ]);

    return ValidationResult.combine(validations);
  }

  private async validateInventory(order: OrderAggregate): Promise<ValidationResult> {
    for (const item of order.getItems()) {
      const available = await this.inventoryService.getAvailableQuantity(
        item.productId
      );
      
      if (available < item.quantity) {
        return ValidationResult.failure(
          `Insufficient inventory for ${item.productName}`
        );
      }
    }
    
    return ValidationResult.success();
  }
}
```





## 微前端架构中的 React 应用集成与状态共享

### 微前端架构模式

1. **基座应用 + 子应用模式**
2. **模块联邦模式**
3. **Web Components模式**
4. **iframe模式**

### qiankun 基座应用架构

```typescript
// 基座应用配置
// main-app/src/main.ts
import { registerMicroApps, start } from 'qiankun';

const apps = [
  {
    name: 'user-center',
    entry: '//localhost:8081',
    container: '#user-center',
    activeRule: '/user',
  },
  {
    name: 'order-system',
    entry: '//localhost:8082',
    container: '#order-system',
    activeRule: '/order',
  },
];

registerMicroApps(apps, {
  beforeLoad: (app) => {
    console.log('before load', app.name);
  },
  beforeMount: (app) => {
    console.log('before mount', app.name);
  },
  afterUnmount: (app) => {
    console.log('after unmount', app.name);
  },
});

start();
```

### 状态共享方案

**1. 全局状态总线**

```typescript
// shared/GlobalEventBus.ts
class GlobalEventBus {
  private events: Map<string, Set<Function>> = new Map();

  subscribe(event: string, callback: Function) {
    if (!this.events.has(event)) {
      this.events.set(event, new Set());
    }
    this.events.get(event)!.add(callback);

    return () => {
      const callbacks = this.events.get(event);
      if (callbacks) {
        callbacks.delete(callback);
      }
    };
  }

  emit(event: string, data?: any) {
    const callbacks = this.events.get(event);
    if (callbacks) {
      callbacks.forEach(callback => callback(data));
    }
  }
}

export const globalEventBus = new GlobalEventBus();
```

**2. 共享状态Hook**

```typescript
// shared/hooks/useGlobalState.ts
export const useGlobalState = <T>(
  key: string,
  initialValue: T
): [T, (value: T) => void] => {
  const [state, setState] = useState<T>(() => {
    const stored = window.__GLOBAL_STATE__?.[key];
    return stored !== undefined ? stored : initialValue;
  });

  const updateState = useCallback((value: T) => {
    setState(value);
    if (!window.__GLOBAL_STATE__) {
      window.__GLOBAL_STATE__ = {};
    }
    window.__GLOBAL_STATE__[key] = value;
    
    globalEventBus.emit(`state:${key}`, value);
  }, [key]);

  useEffect(() => {
    const unsubscribe = globalEventBus.subscribe(
      `state:${key}`,
      (value: T) => setState(value)
    );

    return unsubscribe;
  }, [key]);

  return [state, updateState];
};
```

**3. 微应用通信示例**

```typescript
// 子应用中使用共享状态
const UserCenterApp: React.FC = () => {
  const [userInfo, setUserInfo] = useGlobalState('userInfo', null);
  const [notifications, setNotifications] = useGlobalState('notifications', []);

  const handleLogin = async (credentials: LoginCredentials) => {
    const user = await authService.login(credentials);
    setUserInfo(user);
    
    // 通知其他应用用户已登录
    globalEventBus.emit('user:login', user);
  };

  return (
    <div>
      <LoginForm onLogin={handleLogin} />
      {userInfo && <UserProfile user={userInfo} />}
    </div>
  );
};
```



## 基于 React 的大型中后台系统架构设计

### 整体架构

```
src/
├── app/                 # 应用配置
│   ├── store/          # 全局状态
│   ├── router/         # 路由配置
│   └── providers/      # 全局Provider
├── features/           # 功能模块
│   ├── dashboard/      # 仪表板
│   ├── user-management/# 用户管理
│   ├── order-system/   # 订单系统
│   └── report-center/  # 报表中心
├── shared/             # 共享资源
│   ├── components/     # 通用组件
│   ├── hooks/          # 通用Hook
│   ├── services/       # 业务服务
│   ├── utils/          # 工具函数
│   └── types/          # 类型定义
└── pages/              # 页面组件
```



### 路由架构设计

```typescript
// app/router/routes.ts
export interface RouteConfig {
  path: string;
  component: React.ComponentType;
  meta?: {
    title?: string;
    requiresAuth?: boolean;
    permissions?: string[];
    keepAlive?: boolean;
  };
  children?: RouteConfig[];
}

export const routes: RouteConfig[] = [
  {
    path: '/dashboard',
    component: lazy(() => import('@/features/dashboard')),
    meta: {
      title: '仪表板',
      requiresAuth: true,
    },
  },
  {
    path: '/users',
    component: lazy(() => import('@/features/user-management')),
    meta: {
      title: '用户管理',
      requiresAuth: true,
      permissions: ['user:read'],
    },
    children: [
      {
        path: '/users/list',
        component: lazy(() => import('@/features/user-management/UserList')),
      },
      {
        path: '/users/create',
        component: lazy(() => import('@/features/user-management/UserCreate')),
        meta: {
          permissions: ['user:create'],
        },
      },
    ],
  },
];
```



### 功能模块架构

```typescript
// features/user-management/index.ts
export { default as UserManagement } from './UserManagement';
export { UserProvider } from './contexts/UserContext';
export { useUserList, useUserDetail } from './hooks';
export type { User, UserQuery } from './types';

// features/user-management/UserManagement.tsx
const UserManagement: React.FC = () => {
  return (
    <UserProvider>
      <div className="user-management">
        <UserManagementHeader />
        <div className="user-management-content">
          <Outlet />
        </div>
      </div>
    </UserProvider>
  );
};
```



### 状态管理架构

```typescript
// app/store/index.ts
import { configureStore } from '@reduxjs/toolkit';
import { combineReducers } from '@reduxjs/toolkit';

// Feature slices
import authSlice from '@/features/auth/store/authSlice';
import userSlice from '@/features/user-management/store/userSlice';
import dashboardSlice from '@/features/dashboard/store/dashboardSlice';

const rootReducer = combineReducers({
  auth: authSlice,
  users: userSlice,
  dashboard: dashboardSlice,
});

export const store = configureStore({
  reducer: rootReducer,
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      serializableCheck: {
        ignoredActions: ['persist/PERSIST'],
      },
    }),
});

export type RootState = ReturnType<typeof rootReducer>;
export type AppDispatch = typeof store.dispatch;
```



## 前端资源与权限的精细化控制架构设计

### 权限控制模型

**RBAC (Role-Based Access Control) 模型**

```typescript
// shared/auth/types.ts
export interface Permission {
  id: string;
  resource: string;    // 资源
  action: string;      // 操作
  conditions?: any[];  // 条件
}

export interface Role {
  id: string;
  name: string;
  permissions: Permission[];
}

export interface User {
  id: string;
  name: string;
  roles: Role[];
}
```

### 权限验证Hook

```typescript
// shared/hooks/usePermissions.ts
export const usePermissions = () => {
  const { user } = useAuth();
  
  const hasPermission = useCallback((
    resource: string, 
    action: string,
    conditions?: any
  ): boolean => {
    if (!user) return false;

    return user.roles.some(role =>
      role.permissions.some(permission =>
        permission.resource === resource &&
        permission.action === action &&
        checkConditions(permission.conditions, conditions)
      )
    );
  }, [user]);

  const hasAnyPermission = useCallback((permissions: Array<{
    resource: string;
    action: string;
  }>): boolean => {
    return permissions.some(({ resource, action }) =>
      hasPermission(resource, action)
    );
  }, [hasPermission]);

  return {
    hasPermission,
    hasAnyPermission,
  };
};
```

### 权限控制组件

```typescript
// shared/components/PermissionGuard.tsx
interface PermissionGuardProps {
  resource: string;
  action: string;
  fallback?: React.ReactNode;
  children: React.ReactNode;
  conditions?: any;
}

export const PermissionGuard: React.FC<PermissionGuardProps> = ({
  resource,
  action,
  fallback = null,
  children,
  conditions,
}) => {
  const { hasPermission } = usePermissions();

  if (!hasPermission(resource, action, conditions)) {
    return <>{fallback}</>;
  }

  return <>{children}</>;
};
```

### 路由权限控制

```typescript
// app/router/PermissionRoute.tsx
export const PermissionRoute: React.FC<{
  element: React.ReactElement;
  permissions?: string[];
}> = ({ element, permissions = [] }) => {
  const { hasAnyPermission } = usePermissions();
  const navigate = useNavigate();

  useEffect(() => {
    if (permissions.length > 0) {
      const permissionChecks = permissions.map(perm => {
        const [resource, action] = perm.split(':');
        return { resource, action };
      });

      if (!hasAnyPermission(permissionChecks)) {
        navigate('/403');
        return;
      }
    }
  }, [permissions, hasAnyPermission, navigate]);

  return element;
};
```

### 按钮级权限控制

```typescript
// shared/components/ActionButton.tsx
interface ActionButtonProps extends ButtonProps {
  resource: string;
  action: string;
  conditions?: any;
}

export const ActionButton: React.FC<ActionButtonProps> = ({
  resource,
  action,
  conditions,
  children,
  ...props
}) => {
  const { hasPermission } = usePermissions();

  if (!hasPermission(resource, action, conditions)) {
    return null;
  }

  return <Button {...props}>{children}</Button>;
};

// 使用示例
<ActionButton
  resource="user"
  action="delete"
  conditions={{ ownerId: currentUser.id }}
  onClick={handleDelete}
>
  删除用户
</ActionButton>
```



## 模块联邦 (Module Federation) 在 React 应用中的最佳实践

### Webpack 5 模块联邦配置

**宿主应用配置**

```javascript
// webpack.config.js (Host App)
const ModuleFederationPlugin = require('@module-federation/webpack');

module.exports = {
  plugins: [
    new ModuleFederationPlugin({
      name: 'shell',
      remotes: {
        userApp: 'userApp@http://localhost:3001/remoteEntry.js',
        orderApp: 'orderApp@http://localhost:3002/remoteEntry.js',
      },
      shared: {
        react: {
          singleton: true,
          requiredVersion: '^18.0.0',
        },
        'react-dom': {
          singleton: true,
          requiredVersion: '^18.0.0',
        },
        '@ant-design/icons': {
          singleton: true,
        },
      },
    }),
  ],
};
```

**微应用配置**

```javascript
// webpack.config.js (Remote App)
const ModuleFederationPlugin = require('@module-federation/webpack');

module.exports = {
  plugins: [
    new ModuleFederationPlugin({
      name: 'userApp',
      filename: 'remoteEntry.js',
      exposes: {
        './UserManagement': './src/UserManagement',
        './UserList': './src/components/UserList',
        './userStore': './src/store/userStore',
      },
      shared: {
        react: {
          singleton: true,
          requiredVersion: '^18.0.0',
        },
        'react-dom': {
          singleton: true,
          requiredVersion: '^18.0.0',
        },
      },
    }),
  ],
};
```

### 动态导入微应用

```typescript
// 宿主应用中动态加载微应用
const UserManagement = React.lazy(() => import('userApp/UserManagement'));
const OrderSystem = React.lazy(() => import('orderApp/OrderSystem'));

const App: React.FC = () => {
  return (
    <Router>
      <Layout>
        <Suspense fallback={<Loading />}>
          <Routes>
            <Route path="/users/*" element={<UserManagement />} />
            <Route path="/orders/*" element={<OrderSystem />} />
          </Routes>
        </Suspense>
      </Layout>
    </Router>
  );
};
```

### 类型安全处理

```typescript
// types/remotes.d.ts
declare module 'userApp/UserManagement' {
  import { ComponentType } from 'react';
  const UserManagement: ComponentType;
  export default UserManagement;
}

declare module 'userApp/userStore' {
  export interface UserState {
    users: User[];
    loading: boolean;
  }
  
  export const userStore: UserState;
  export const userActions: {
    fetchUsers: () => Promise<void>;
    createUser: (user: Partial<User>) => Promise<void>;
  };
}
```

### 共享状态管理

```typescript
// shared/store/federatedStore.ts
interface FederatedStore {
  subscribe(key: string, callback: (data: any) => void): () => void;
  emit(key: string, data: any): void;
  getState(key: string): any;
  setState(key: string, data: any): void;
}

class FederatedStoreImpl implements FederatedStore {
  private state: Map<string, any> = new Map();
  private subscribers: Map<string, Set<Function>> = new Map();

  subscribe(key: string, callback: (data: any) => void): () => void {
    if (!this.subscribers.has(key)) {
      this.subscribers.set(key, new Set());
    }
    
    this.subscribers.get(key)!.add(callback);

    return () => {
      const callbacks = this.subscribers.get(key);
      if (callbacks) {
        callbacks.delete(callback);
      }
    };
  }

  emit(key: string, data: any): void {
    this.setState(key, data);
    
    const callbacks = this.subscribers.get(key);
    if (callbacks) {
      callbacks.forEach(callback => callback(data));
    }
  }

  getState(key: string): any {
    return this.state.get(key);
  }

  setState(key: string, data: any): void {
    this.state.set(key, data);
  }
}

export const federatedStore = new FederatedStoreImpl();

// 确保全局唯一
if (!window.__FEDERATED_STORE__) {
  window.__FEDERATED_STORE__ = federatedStore;
}

export default window.__FEDERATED_STORE__;
```



## React 企业级应用的代码组织与最佳实践

### 项目结构最佳实践

```
src/
├── app/                    # 应用层配置
│   ├── App.tsx            # 根组件
│   ├── store/             # 全局状态
│   ├── router/            # 路由配置
│   └── providers/         # 全局Provider
├── features/              # 功能模块（按业务领域）
│   ├── authentication/    # 认证模块
│   │   ├── components/    # 组件
│   │   ├── hooks/         # 自定义Hook
│   │   ├── services/      # 业务服务
│   │   ├── store/         # 状态管理
│   │   ├── types/         # 类型定义
│   │   └── utils/         # 工具函数
│   └── user-management/   # 用户管理模块
├── shared/                # 通用资源
│   ├── components/        # 通用组件
│   │   ├── ui/           # 基础UI组件
│   │   ├── layout/       # 布局组件
│   │   └── business/     # 业务组件
│   ├── hooks/            # 通用Hook
│   ├── services/         # 通用服务
│   ├── utils/            # 工具函数
│   ├── constants/        # 常量
│   ├── types/            # 通用类型
│   └── styles/           # 样式文件
├── assets/               # 静态资源
└── pages/                # 页面组件（路由页面）
```



### 组件设计最佳实践

**1. 组件分类与职责**

```typescript
// 展示组件 (Presentational Component)
interface UserCardProps {
  user: User;
  onEdit?: (user: User) => void;
  onDelete?: (userId: string) => void;
}

export const UserCard: React.FC<UserCardProps> = ({ 
  user, 
  onEdit, 
  onDelete 
}) => {
  return (
    <Card>
      <Avatar src={user.avatar} />
      <div>
        <h3>{user.name}</h3>
        <p>{user.email}</p>
      </div>
      {onEdit && <Button onClick={() => onEdit(user)}>编辑</Button>}
      {onDelete && <Button onClick={() => onDelete(user.id)}>删除</Button>}
    </Card>
  );
};

// 容器组件 (Container Component)
export const UserCardContainer: React.FC<{ userId: string }> = ({ userId }) => {
  const { user, loading } = useUserDetail(userId);
  const { updateUser, deleteUser } = useUserActions();

  if (loading) return <Skeleton />;

  return (
    <UserCard
      user={user}
      onEdit={updateUser}
      onDelete={deleteUser}
    />
  );
};
```

**2. 复合组件模式**

```typescript
// 复合组件设计
interface TableCompoundProps {
  data: any[];
  children: React.ReactNode;
}

interface TableContextType {
  data: any[];
  selectedRows: any[];
  onSelectRow: (row: any) => void;
}

const TableContext = createContext<TableContextType | null>(null);

export const Table: React.FC<TableCompoundProps> & {
  Header: typeof TableHeader;
  Body: typeof TableBody;
  Row: typeof TableRow;
  Cell: typeof TableCell;
} = ({ data, children }) => {
  const [selectedRows, setSelectedRows] = useState<any[]>([]);

  const contextValue = {
    data,
    selectedRows,
    onSelectRow: (row: any) => {
      setSelectedRows(prev => 
        prev.includes(row) 
          ? prev.filter(r => r !== row)
          : [...prev, row]
      );
    },
  };

  return (
    <TableContext.Provider value={contextValue}>
      <table className="table">
        {children}
      </table>
    </TableContext.Provider>
  );
};

// 使用方式
<Table data={users}>
  <Table.Header>
    <Table.Row>
      <Table.Cell>姓名</Table.Cell>
      <Table.Cell>邮箱</Table.Cell>
      <Table.Cell>操作</Table.Cell>
    </Table.Row>
  </Table.Header>
  <Table.Body>
    {users.map(user => (
      <Table.Row key={user.id}>
        <Table.Cell>{user.name}</Table.Cell>
        <Table.Cell>{user.email}</Table.Cell>
        <Table.Cell>
          <ActionButton resource="user" action="edit">
            编辑
          </ActionButton>
        </Table.Cell>
      </Table.Row>
    ))}
  </Table.Body>
</Table>
```

### 自定义Hook最佳实践

```typescript
// 数据获取Hook
export const useAsyncData = <T>(
  asyncFunction: () => Promise<T>,
  dependencies: React.DependencyList = []
) => {
  const [data, setData] = useState<T | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  const execute = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      const result = await asyncFunction();
      setData(result);
    } catch (err) {
      setError(err instanceof Error ? err : new Error('Unknown error'));
    } finally {
      setLoading(false);
    }
  }, dependencies);

  useEffect(() => {
    execute();
  }, [execute]);

  return {
    data,
    loading,
    error,
    refetch: execute,
  };
};

// 表单Hook
export const useForm = <T extends Record<string, any>>(
  initialValues: T,
  validationSchema?: (values: T) => Record<keyof T, string>
) => {
  const [values, setValues] = useState<T>(initialValues);
  const [errors, setErrors] = useState<Partial<Record<keyof T, string>>>({});
  const [touched, setTouched] = useState<Partial<Record<keyof T, boolean>>>({});

  const setValue = useCallback((name: keyof T, value: any) => {
    setValues(prev => ({ ...prev, [name]: value }));
    
    if (touched[name] && validationSchema) {
      const newErrors = validationSchema({ ...values, [name]: value });
      setErrors(prev => ({ ...prev, [name]: newErrors[name] }));
    }
  }, [values, touched, validationSchema]);

  const setFieldTouched = useCallback((name: keyof T) => {
    setTouched(prev => ({ ...prev, [name]: true }));
  }, []);

  const validate = useCallback(() => {
    if (!validationSchema) return true;
    
    const newErrors = validationSchema(values);
    setErrors(newErrors);
    
    return Object.keys(newErrors).length === 0;
  }, [values, validationSchema]);

  return {
    values,
    errors,
    touched,
    setValue,
    setFieldTouched,
    validate,
    reset: () => {
      setValues(initialValues);
      setErrors({});
      setTouched({});
    },
  };
};
```





### 性能优化最佳实践

**1. 组件懒加载与代码分割**

```typescript
// 路由级别的代码分割
const Dashboard = lazy(() => import('@/features/dashboard/Dashboard'));
const UserManagement = lazy(() => import('@/features/user-management'));

// 组件级别的条件加载
const HeavyChart = lazy(() => import('@/shared/components/HeavyChart'));

const StatisticsPage: React.FC = () => {
  const [showChart, setShowChart] = useState(false);

  return (
    <div>
      <Button onClick={() => setShowChart(true)}>显示图表</Button>
      {showChart && (
        <Suspense fallback={<ChartSkeleton />}>
          <HeavyChart />
        </Suspense>
      )}
    </div>
  );
};
```

**2. 虚拟化长列表**

```typescript
// 虚拟化表格组件
import { FixedSizeList as List } from 'react-window';

interface VirtualTableProps {
  data: any[];
  height: number;
  itemHeight: number;
  columns: Column[];
}

const VirtualTable: React.FC<VirtualTableProps> = ({
  data,
  height,
  itemHeight,
  columns,
}) => {
  const Row = ({ index, style }: { index: number; style: React.CSSProperties }) => {
    const item = data[index];
    
    return (
      <div style={style} className="virtual-table-row">
        {columns.map(column => (
          <div key={column.key} className="virtual-table-cell">
            {column.render ? column.render(item[column.key], item) : item[column.key]}
          </div>
        ))}
      </div>
    );
  };

  return (
    <List
      height={height}
      itemCount={data.length}
      itemSize={itemHeight}
      width="100%"
    >
      {Row}
    </List>
  );
};
```

**3. 状态管理优化**

```typescript
// 状态分割与局部更新
const useOptimizedUserStore = () => {
  const users = useSelector((state: RootState) => state.users.list);
  const loading = useSelector((state: RootState) => state.users.loading);
  
  // 使用 reselect 进行数据缓存
  const activeUsers = useMemo(() =>
    createSelector(
      (state: RootState) => state.users.list,
      (users) => users.filter(user => user.status === 'active')
    )
  , []);

  const dispatch = useDispatch();

  return {
    users,
    activeUsers: useSelector(activeUsers),
    loading,
    actions: {
      fetchUsers: () => dispatch(fetchUsersAsync()),
      updateUser: (user: User) => dispatch(updateUserAsync(user)),
    },
  };
};

// 组件级别的状态优化
const UserList: React.FC = () => {
  const { users, loading } = useOptimizedUserStore();
  
  // 使用 React.memo 和 useMemo 优化渲染
  const UserItem = React.memo<{ user: User }>(({ user }) => (
    <div className="user-item">
      <span>{user.name}</span>
      <span>{user.email}</span>
    </div>
  ));

  const renderedUsers = useMemo(() =>
    users.map(user => <UserItem key={user.id} user={user} />)
  , [users]);

  if (loading) return <Skeleton />;

  return <div className="user-list">{renderedUsers}</div>;
};
```



### 错误处理与监控

```typescript
// 全局错误边界
class GlobalErrorBoundary extends React.Component<
  { children: React.ReactNode },
  { hasError: boolean; error: Error | null }
> {
  constructor(props: { children: React.ReactNode }) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error: Error) {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    // 发送错误到监控系统
    this.reportError(error, errorInfo);
  }

  reportError = (error: Error, errorInfo: React.ErrorInfo) => {
    // 发送到错误监控平台
    if (process.env.NODE_ENV === 'production') {
      // Sentry, LogRocket 等
      console.error('Application Error:', error, errorInfo);
    }
  };

  render() {
    if (this.state.hasError) {
      return (
        <div className="error-fallback">
          <h2>出现了一些问题</h2>
          <p>请刷新页面重试</p>
          <button onClick={() => window.location.reload()}>
            刷新页面
          </button>
        </div>
      );
    }

    return this.props.children;
  }
}

// 异步错误处理Hook
export const useAsyncError = () => {
  const [error, setError] = useState<Error | null>(null);

  const throwError = useCallback((error: Error) => {
    setError(error);
  }, []);

  useEffect(() => {
    if (error) {
      throw error;
    }
  }, [error]);

  return throwError;
};
```

### 测试架构

```typescript
// 测试工具配置
// src/test/test-utils.tsx
import { render, RenderOptions } from '@testing-library/react';
import { Provider } from 'react-redux';
import { BrowserRouter } from 'react-router-dom';
import { store } from '@/app/store';

const AllTheProviders: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  return (
    <Provider store={store}>
      <BrowserRouter>
        {children}
      </BrowserRouter>
    </Provider>
  );
};

const customRender = (
  ui: React.ReactElement,
  options?: Omit<RenderOptions, 'wrapper'>
) => render(ui, { wrapper: AllTheProviders, ...options });

export * from '@testing-library/react';
export { customRender as render };

// 组件测试示例
import { render, screen, fireEvent, waitFor } from '@/test/test-utils';
import UserList from '../UserList';

describe('UserList Component', () => {
  it('should render user list correctly', async () => {
    render(<UserList />);
    
    await waitFor(() => {
      expect(screen.getByText('用户列表')).toBeInTheDocument();
    });
  });

  it('should handle user deletion', async () => {
    const mockDeleteUser = jest.fn();
    render(<UserList onDeleteUser={mockDeleteUser} />);
    
    const deleteButton = screen.getByText('删除');
    fireEvent.click(deleteButton);
    
    await waitFor(() => {
      expect(mockDeleteUser).toHaveBeenCalledTimes(1);
    });
  });
});

// Hook测试示例
import { renderHook, act } from '@testing-library/react';
import { useUserList } from '../hooks/useUserList';

describe('useUserList Hook', () => {
  it('should fetch users on mount', async () => {
    const { result } = renderHook(() => useUserList());
    
    expect(result.current.loading).toBe(true);
    
    await act(async () => {
      await new Promise(resolve => setTimeout(resolve, 100));
    });
    
    expect(result.current.loading).toBe(false);
    expect(result.current.users).toHaveLength(0);
  });
});
```

### 国际化架构

```typescript
// 国际化配置
// src/locales/index.ts
import i18n from 'i18next';
import { initReactI18next } from 'react-i18next';
import LanguageDetector from 'i18next-browser-languagedetector';

import en from './en.json';
import zh from './zh.json';

i18n
  .use(LanguageDetector)
  .use(initReactI18next)
  .init({
    resources: {
      en: { translation: en },
      zh: { translation: zh },
    },
    fallbackLng: 'zh',
    debug: process.env.NODE_ENV === 'development',
    interpolation: {
      escapeValue: false,
    },
  });

export default i18n;

// 类型安全的国际化Hook
import { useTranslation } from 'react-i18next';

type TranslationKeys = 'common.save' | 'common.cancel' | 'user.name' | 'user.email';

export const useTypedTranslation = () => {
  const { t, i18n } = useTranslation();
  
  return {
    t: (key: TranslationKeys, options?: any) => t(key, options),
    changeLanguage: i18n.changeLanguage,
    language: i18n.language,
  };
};

// 组件中使用
const UserForm: React.FC = () => {
  const { t } = useTypedTranslation();
  
  return (
    <Form>
      <Form.Item label={t('user.name')}>
        <Input />
      </Form.Item>
      <Form.Item label={t('user.email')}>
        <Input />
      </Form.Item>
      <Button type="primary">{t('common.save')}</Button>
      <Button>{t('common.cancel')}</Button>
    </Form>
  );
};
```

### 部署与构建优化

```javascript
// webpack优化配置
const path = require('path');
const { BundleAnalyzerPlugin } = require('webpack-bundle-analyzer');

module.exports = {
  // 生产环境优化
  optimization: {
    splitChunks: {
      chunks: 'all',
      cacheGroups: {
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name: 'vendors',
          chunks: 'all',
        },
        common: {
          name: 'common',
          minChunks: 2,
          priority: 5,
          reuseExistingChunk: true,
        },
      },
    },
    // 提取运行时代码
    runtimeChunk: {
      name: 'runtime',
    },
  },
  
  // 别名配置
  resolve: {
    alias: {
      '@': path.resolve(__dirname, 'src'),
      '@shared': path.resolve(__dirname, 'src/shared'),
      '@features': path.resolve(__dirname, 'src/features'),
      '@app': path.resolve(__dirname, 'src/app'),
    },
  },

  // 插件配置
  plugins: [
    // 分析打包体积
    process.env.ANALYZE && new BundleAnalyzerPlugin(),
  ].filter(Boolean),
};
```



### 总结

企业级React应用架构设计的核心要点：

1. **分层架构**: 采用Clean Architecture或DDD等架构模式，确保代码的可维护性和可测试性
2. **模块化设计**: 按功能域划分模块，降低耦合度，提高内聚性
3. **状态管理**: 合理使用Redux、Zustand等状态管理库，避免过度设计
4. **权限控制**: 实现细粒度的权限控制，确保应用安全性
5. **性能优化**: 代码分割、虚拟化、缓存等技术提升应用性能
6. **可扩展性**: 微前端、模块联邦等技术支持应用的横向扩展
7. **工程化**: 完善的构建、测试、部署流程，确保开发效率和代码质量
8. **用户体验**: 国际化、错误处理、加载状态等提升用户体验
