# ⼯程化与构建优化

 

## Vite 在 Vue 项目中的应用及原理分析】

### Vite 核心原理

**基于 ESM 的开发模式**

- 利用浏览器原生 ES 模块支持
- 按需编译，只处理当前访问的模块
- 热更新速度极快，毫秒级响应

**双引擎架构**

```javascript
// vite.config.js - Vue 项目配置
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'

export default defineConfig({
  plugins: [vue()],
  // 开发服务器配置
  server: {
    port: 3000,
    hmr: true
  },
  // 构建配置
  build: {
    target: 'es2015',
    rollupOptions: {
      output: {
        chunkFileNames: 'js/[name]-[hash].js',
        entryFileNames: 'js/[name]-[hash].js',
        assetFileNames: 'assets/[name]-[hash].[ext]'
      }
    }
  }
})
```

![image-20250526152101342](C:/Users/27019/AppData/Roaming/Typora/typora-user-images/image-20250526152101342.png)

**构建性能对比**

```javascript
// Webpack 配置示例
module.exports = {
  entry: './src/main.js',
  module: {
    rules: [
      {
        test: /\.vue$/,
        loader: 'vue-loader'
      },
      {
        test: /\.js$/,
        loader: 'babel-loader',
        exclude: /node_modules/
      }
    ]
  },
  plugins: [
    new VueLoaderPlugin(),
    new HtmlWebpackPlugin()
  ]
}

// Vite 等效配置
export default defineConfig({
  plugins: [vue()]
  // 大部分配置开箱即用
})
```



## Vue 项目构建速度和产物体积优化

### 构建速度优化策略

**依赖预构建优化**

```javascript
// vite.config.js
export default defineConfig({
  optimizeDeps: {
    include: ['vue', 'vue-router', 'axios'],
    exclude: ['your-es-lib']
  },
  server: {
    warmup: {
      clientFiles: ['./src/components/*.vue']
    }
  }
})
```



**并行构建配置**

```javascript
// 多线程构建
export default defineConfig({
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          vendor: ['vue', 'vue-router'],
          ui: ['element-plus', 'ant-design-vue']
        }
      }
    },
    terserOptions: {
      parallel: true
    }
  }
})
```



### 产物体积优化

**Tree Shaking 配置**

```javascript
// 确保 Tree Shaking 生效
export default defineConfig({
  build: {
    rollupOptions: {
      external: ['vue'],
      output: {
        globals: {
          vue: 'Vue'
        }
      }
    }
  },
  esbuild: {
    drop: ['console', 'debugger']
  }
```



**按需导入配置**

```javascript
// 自动导入插件
import AutoImport from 'unplugin-auto-import/vite'
import Components from 'unplugin-vue-components/vite'

export default defineConfig({
  plugins: [
    AutoImport({
      imports: ['vue', 'vue-router'],
      dts: true
    }),
    Components({
      dts: true
    })
  ]
})
```



**资源压缩优化**

```javascript
import { defineConfig } from 'vite'
import legacy from '@vitejs/plugin-legacy'
import { visualizer } from 'rollup-plugin-visualizer'

export default defineConfig({
  plugins: [
    legacy({
      targets: ['defaults', 'not IE 11']
    }),
    visualizer({
      filename: 'dist/stats.html',
      open: true
    })
  ],
  build: {
    minify: 'terser',
    terserOptions: {
      compress: {
        drop_console: true,
        drop_debugger: true
      }
    }
  }
})
```



## 模块联邦在 Vue 项目中的应用

### Module Federation 基础配置

**主应用配置**

```javascript
// host/vite.config.js
import { defineConfig } from 'vite'
import federation from '@originjs/vite-plugin-federation'

export default defineConfig({
  plugins: [
    federation({
      name: 'host-app',
      remotes: {
        remote1: 'http://localhost:5001/assets/remoteEntry.js',
        remote2: 'http://localhost:5002/assets/remoteEntry.js'
      },
      shared: ['vue', 'vue-router']
    })
  ]
})
```



**远程应用配置**

```javascript
// remote/vite.config.js
export default defineConfig({
  plugins: [
    federation({
      name: 'remote-app',
      filename: 'remoteEntry.js',
      exposes: {
        './Button': './src/components/Button.vue',
        './UserModule': './src/modules/User/index.js'
      },
      shared: ['vue', 'vue-router']
    })
  ]
})
```



### 微前端架构实现

**动态远程组件加载**

```vue
<!-- 主应用中使用远程组件 -->
<template>
  <div>
    <Suspense>
      <template #default>
        <RemoteButton />
      </template>
      <template #fallback>
        <div>Loading...</div>
      </template>
    </Suspense>
  </div>
</template>

<script setup>
import { defineAsyncComponent } from 'vue'

const RemoteButton = defineAsyncComponent(() =>
  import('remote1/Button')
)
</script>
```

**路由级别的模块联邦**

```javascript
// 路由配置
import { createRouter } from 'vue-router'

const routes = [
  {
    path: '/user',
    component: () => import('remote1/UserModule')
  },
  {
    path: '/product',
    component: () => import('remote2/ProductModule')
  }
]

export default createRouter({
  routes
})
```



## Vue 库的按需加载设计与实现



### 组件库按需导入

**Babel 插件配置**

```javascript
// babel.config.js
module.exports = {
  plugins: [
    ['import', {
      libraryName: 'element-plus',
      customStyleName: (name) => {
        return `element-plus/lib/theme-chalk/${name}.css`
      }
    }]
  ]
}
```

**自定义按需加载插件**

```javascript
// plugins/auto-import.js
function createAutoImportPlugin() {
  return {
    name: 'auto-import',
    resolveId(id) {
      if (id.startsWith('my-ui/')) {
        return id
      }
    },
    load(id) {
      if (id.startsWith('my-ui/')) {
        const componentName = id.split('/')[1]
        return `
          import Component from '../components/${componentName}/index.vue'
          import '../components/${componentName}/style.css'
          export default Component
        `
      }
    }
  }
}
```

### 工具函数树摇优化

```javascript
// utils/index.js - 支持 Tree Shaking
export const formatDate = (date) => {
  // 格式化日期逻辑
}

export const debounce = (fn, delay) => {
  // 防抖逻辑
}

// 确保每个工具函数独立导出
// 避免使用 export default { formatDate, debounce }
```



## Vue 项目的构建流水线设计与 CI/CD 实践



### GitHub Actions 配置

```yaml
# .github/workflows/deploy.yml
name: Build and Deploy

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'npm'
    
    - name: Install dependencies
      run: npm ci
    
    - name: Run tests
      run: npm run test:unit
    
    - name: Build project
      run: npm run build
      env:
        NODE_ENV: production
    
    - name: Deploy to OSS
      run: |
        npm install -g ossutil
        ossutil cp -r dist/ oss://your-bucket/
```

### Docker 容器化构建

```dockerfile
# Dockerfile
FROM node:18-alpine as builder

WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production

COPY . .
RUN npm run build

FROM nginx:alpine
COPY --from=builder /app/dist /usr/share/nginx/html
COPY nginx.conf /etc/nginx/nginx.conf

EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

### 多环境构建配置

```javascript
// scripts/build.js
const { execSync } = require('child_process')
const path = require('path')

const environments = {
  dev: {
    API_BASE_URL: 'https://dev-api.example.com',
    CDN_URL: 'https://dev-cdn.example.com'
  },
  staging: {
    API_BASE_URL: 'https://staging-api.example.com',
    CDN_URL: 'https://staging-cdn.example.com'
  },
  prod: {
    API_BASE_URL: 'https://api.example.com',
    CDN_URL: 'https://cdn.example.com'
  }
}

const env = process.argv[2] || 'dev'
const config = environments[env]

// 设置环境变量并构建
Object.keys(config).forEach(key => {
  process.env[key] = config[key]
})

execSync('vite build', { stdio: 'inherit' })
```





## Vue SFC 的构建流程及自定义块处理

### SFC 编译流程分析

**编译步骤详解**

```javascript
// SFC 编译流程
const { parse, compileTemplate, compileScript, compileStyle } = require('@vue/compiler-sfc')

function compileSFC(source, filename) {
  // 1. 解析 SFC
  const { descriptor } = parse(source, { filename })
  
  // 2. 编译 script
  const scriptResult = compileScript(descriptor, {
    id: 'vue-component'
  })
  
  // 3. 编译 template
  const templateResult = compileTemplate({
    source: descriptor.template.content,
    filename
  })
  
  // 4. 编译 style
  const styleResults = descriptor.styles.map(style =>
    compileStyle({
      source: style.content,
      scoped: style.scoped
    })
  )
  
  return {
    script: scriptResult.content,
    template: templateResult.code,
    styles: styleResults.map(s => s.code)
  }
}
```



### 自定义块处理

**自定义块定义**

```vue
<template>
  <div>{{ message }}</div>
</template>

<script setup>
import { ref } from 'vue'
const message = ref('Hello')
</script>

<docs>
这是一个示例组件
用于展示自定义块的使用
</docs>

<i18n>
{
  "en": {
    "hello": "Hello"
  },
  "zh": {
    "hello": "你好"
  }
}
</i18n>
```

**自定义块处理器**

```javascript
// vite-plugin-custom-block.js
export function customBlockPlugin() {
  return {
    name: 'custom-block',
    transform(code, id) {
      if (!id.includes('.vue')) return
      
      const { parse } = require('@vue/compiler-sfc')
      const { descriptor } = parse(code)
      
      // 处理 docs 块
      if (descriptor.customBlocks.find(b => b.type === 'docs')) {
        const docsBlock = descriptor.customBlocks.find(b => b.type === 'docs')
        // 生成文档或注入元数据
        console.log('Component docs:', docsBlock.content)
      }
      
      // 处理 i18n 块
      if (descriptor.customBlocks.find(b => b.type === 'i18n')) {
        const i18nBlock = descriptor.customBlocks.find(b => b.type === 'i18n')
        const i18nData = JSON.parse(i18nBlock.content)
        
        // 注入到组件中
        code += `
          export const __i18n = ${JSON.stringify(i18nData)}
        `
      }
      
      return code
    }
  }
}
```



## 大型 Vue 项目的分包策略与缓存优化

### 智能分包策略

**基于路由的分包**

```javascript
// vite.config.js
export default defineConfig({
  build: {
    rollupOptions: {
      output: {
        manualChunks: (id) => {
          // 第三方库分包
          if (id.includes('node_modules')) {
            if (id.includes('vue')) {
              return 'vue-vendor'
            }
            if (id.includes('element-plus')) {
              return 'ui-vendor'
            }
            if (id.includes('axios') || id.includes('lodash')) {
              return 'utils-vendor'
            }
            return 'vendor'
          }
          
          // 按页面模块分包
          if (id.includes('/src/views/user/')) {
            return 'user-module'
          }
          if (id.includes('/src/views/product/')) {
            return 'product-module'
          }
          if (id.includes('/src/views/order/')) {
            return 'order-module'
          }
        }
      }
    }
  }
})
```



**动态导入优化**

```javascript
// router/index.js
const routes = [
  {
    path: '/user',
    component: () => import(
      /* webpackChunkName: "user" */
      '../views/User/index.vue'
    )
  },
  {
    path: '/product',
    component: () => import(
      /* webpackChunkName: "product" */
      '../views/Product/index.vue'
    )
  }
]
```



### 缓存优化策略

**HTTP 缓存配置**

```nginx
# nginx.conf
location ~* \.(js|css)$ {
    expires 1y;
    add_header Cache-Control "public, immutable";
}

location ~* \.(html)$ {
    expires -1;
    add_header Cache-Control "no-cache, no-store, must-revalidate";
}
```



**Service Worker 缓存**

```javascript
// sw.js
const CACHE_NAME = 'vue-app-v1'
const urlsToCache = [
  '/',
  '/js/app.js',
  '/css/app.css'
]

self.addEventListener('install', event => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then(cache => cache.addAll(urlsToCache))
  )
})

self.addEventListener('fetch', event => {
  event.respondWith(
    caches.match(event.request)
      .then(response => {
        if (response) {
          return response
        }
        return fetch(event.request)
      })
  )
})
```



**构建时文件指纹**

```javascript
// 确保文件内容变化时文件名变化
export default defineConfig({
  build: {
    rollupOptions: {
      output: {
        entryFileNames: 'js/[name].[hash].js',
        chunkFileNames: 'js/[name].[hash].js',
        assetFileNames: 'assets/[name].[hash].[ext]'
      }
    }
  }
})
```



### 性能监控与分析

**Bundle 分析**

```javascript
import { defineConfig } from 'vite'
import { Bundle } from 'rollup-plugin-analyzer'

export default defineConfig({
  plugins: [
    Bundle({
      summaryOnly: true,
      limit: 10
    })
  ]
})
```

**运行时性能监控**

```javascript
// performance.js
export function trackPerformance() {
  // 首屏加载时间
  window.addEventListener('load', () => {
    const loadTime = performance.timing.loadEventEnd - performance.timing.navigationStart
    console.log('Page load time:', loadTime)
  })
  
  // 路由切换性能
  router.beforeEach((to, from, next) => {
    window.routeStartTime = performance.now()
    next()
  })
  
  router.afterEach(() => {
    const routeTime = performance.now() - window.routeStartTime
    console.log('Route change time:', routeTime)
  })
}
```



# Vue项目工程化实践

## Vue 项目的代码规范与质量保证体系

### 代码规范配置

**ESLint 配置**

```javascript
// .eslintrc.js
module.exports = {
  root: true,
  env: {
    node: true,
    browser: true,
    es2021: true
  },
  extends: [
    'plugin:vue/vue3-essential',
    '@vue/eslint-config-typescript',
    '@vue/eslint-config-prettier',
    'plugin:@typescript-eslint/recommended'
  ],
  parserOptions: {
    ecmaVersion: 2021,
    parser: '@typescript-eslint/parser',
    sourceType: 'module'
  },
  rules: {
    // Vue 相关规则
    'vue/multi-word-component-names': 'error',
    'vue/component-definition-name-casing': ['error', 'PascalCase'],
    'vue/component-name-in-template-casing': ['error', 'kebab-case'],
    'vue/prop-name-casing': ['error', 'camelCase'],
    'vue/no-unused-vars': 'error',
    
    // TypeScript 规则
    '@typescript-eslint/no-unused-vars': 'error',
    '@typescript-eslint/explicit-function-return-type': 'warn',
    '@typescript-eslint/no-explicit-any': 'warn',
    
    // 通用规则
    'no-console': process.env.NODE_ENV === 'production' ? 'warn' : 'off',
    'no-debugger': process.env.NODE_ENV === 'production' ? 'warn' : 'off',
    'prefer-const': 'error',
    'no-var': 'error'
  }
}
```

**Prettier 配置**

```json
// .prettierrc
{
  "semi": false,
  "singleQuote": true,
  "trailingComma": "none",
  "printWidth": 100,
  "tabWidth": 2,
  "useTabs": false,
  "bracketSpacing": true,
  "arrowParens": "avoid",
  "vueIndentScriptAndStyle": true
}
```

**StyleLint 配置**

```javascript
// .stylelintrc.js
module.exports = {
  extends: [
    'stylelint-config-standard',
    'stylelint-config-recommended-vue'
  ],
  rules: {
    'selector-pseudo-element-no-unknown': [
      true,
      {
        ignorePseudoElements: ['v-deep', 'v-global', 'v-slotted']
      }
    ],
    'at-rule-no-unknown': [
      true,
      {
        ignoreAtRules: ['tailwind', 'apply', 'variants', 'responsive', 'screen']
      }
    ]
  }
}
```

### Git Hooks 配置

**Husky + lint-staged**

```json
// package.json
{
  "husky": {
    "hooks": {
      "pre-commit": "lint-staged",
      "commit-msg": "commitlint -E HUSKY_GIT_PARAMS"
    }
  },
  "lint-staged": {
    "*.{js,ts,vue}": [
      "eslint --fix",
      "prettier --write"
    ],
    "*.{css,scss,vue}": [
      "stylelint --fix"
    ],
    "*.{json,md}": [
      "prettier --write"
    ]
  }
}
```

**Commitlint 配置**

```javascript
// commitlint.config.js
module.exports = {
  extends: ['@commitlint/config-conventional'],
  rules: {
    'type-enum': [
      2,
      'always',
      [
        'feat',     // 新功能
        'fix',      // 修复bug
        'docs',     // 文档更新
        'style',    // 样式修改
        'refactor', // 重构
        'perf',     // 性能优化
        'test',     // 测试相关
        'chore',    // 构建过程或辅助工具的变动
        'revert'    // 回退
      ]
    ],
    'subject-case': [0]
  }
}
```

### 代码质量检测

**SonarQube 集成**

```yaml
# sonar-project.properties
sonar.projectKey=vue-project
sonar.projectName=Vue Project
sonar.projectVersion=1.0

sonar.sources=src
sonar.tests=tests
sonar.test.inclusions=**/*.spec.ts,**/*.test.ts
sonar.typescript.lcov.reportPaths=coverage/lcov.info

sonar.exclusions=**/node_modules/**,**/dist/**,**/*.d.ts
```



##  Vue 项目的自动化测试策略



### 单元测试配置

**Vitest 配置**

```javascript
// vitest.config.ts
import { defineConfig } from 'vitest/config'
import vue from '@vitejs/plugin-vue'

export default defineConfig({
  plugins: [vue()],
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: ['./tests/setup.ts'],
    coverage: {
      reporter: ['text', 'json', 'html'],
      exclude: [
        'node_modules/',
        'tests/',
        '**/*.d.ts',
        '**/*.config.*'
      ]
    }
  }
})
```

**单元测试示例**

```typescript
// tests/unit/Button.spec.ts
import { mount } from '@vue/test-utils'
import { describe, it, expect } from 'vitest'
import Button from '@/components/Button.vue'

describe('Button Component', () => {
  it('renders correctly with default props', () => {
    const wrapper = mount(Button, {
      props: {
        type: 'primary'
      },
      slots: {
        default: 'Click me'
      }
    })
    
    expect(wrapper.text()).toBe('Click me')
    expect(wrapper.classes()).toContain('btn-primary')
  })
  
  it('emits click event when clicked', async () => {
    const wrapper = mount(Button)
    await wrapper.trigger('click')
    
    expect(wrapper.emitted()).toHaveProperty('click')
    expect(wrapper.emitted('click')).toHaveLength(1)
  })
  
  it('is disabled when loading', () => {
    const wrapper = mount(Button, {
      props: {
        loading: true
      }
    })
    
    expect(wrapper.element.disabled).toBe(true)
    expect(wrapper.find('.loading-icon').exists()).toBe(true)
  })
})
```

### 组件测试

**复杂组件测试**

```typescript
// tests/components/UserForm.spec.ts
import { mount } from '@vue/test-utils'
import { createPinia, setActivePinia } from 'pinia'
import UserForm from '@/components/UserForm.vue'
import { useUserStore } from '@/stores/user'

describe('UserForm Component', () => {
  beforeEach(() => {
    setActivePinia(createPinia())
  })
  
  it('validates form inputs correctly', async () => {
    const wrapper = mount(UserForm)
    const userStore = useUserStore()
    
    // 测试表单验证
    await wrapper.find('#email').setValue('invalid-email')
    await wrapper.find('form').trigger('submit')
    
    expect(wrapper.find('.error-message').text()).toContain('Invalid email')
    expect(userStore.createUser).not.toHaveBeenCalled()
  })
  
  it('submits form with valid data', async () => {
    const wrapper = mount(UserForm)
    const userStore = useUserStore()
    
    // Mock store method
    vi.spyOn(userStore, 'createUser').mockResolvedValue({ id: 1 })
    
    await wrapper.find('#name').setValue('John Doe')
    await wrapper.find('#email').setValue('john@example.com')
    await wrapper.find('form').trigger('submit')
    
    expect(userStore.createUser).toHaveBeenCalledWith({
      name: 'John Doe',
      email: 'john@example.com'
    })
  })
})
```

### E2E 测试

**Playwright 配置**

```javascript
// playwright.config.js
import { defineConfig } from '@playwright/test'

export default defineConfig({
  testDir: './tests/e2e',
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,
  reporter: 'html',
  use: {
    baseURL: 'http://localhost:3000',
    trace: 'on-first-retry',
    screenshot: 'only-on-failure'
  },
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] }
    },
    {
      name: 'firefox',
      use: { ...devices['Desktop Firefox'] }
    },
    {
      name: 'webkit',
      use: { ...devices['Desktop Safari'] }
    }
  ],
  webServer: {
    command: 'npm run dev',
    url: 'http://localhost:3000',
    reuseExistingServer: !process.env.CI
  }
})
```

**E2E 测试示例**

```javascript
// tests/e2e/user-workflow.spec.js
import { test, expect } from '@playwright/test'

test.describe('User Workflow', () => {
  test('user can register and login', async ({ page }) => {
    // 注册流程
    await page.goto('/register')
    await page.fill('[data-testid="username"]', 'testuser')
    await page.fill('[data-testid="email"]', 'test@example.com')
    await page.fill('[data-testid="password"]', 'password123')
    await page.click('[data-testid="register-btn"]')
    
    // 验证注册成功
    await expect(page.locator('.success-message')).toBeVisible()
    
    // 登录流程
    await page.goto('/login')
    await page.fill('[data-testid="email"]', 'test@example.com')
    await page.fill('[data-testid="password"]', 'password123')
    await page.click('[data-testid="login-btn"]')
    
    // 验证登录成功
    await expect(page.locator('[data-testid="user-menu"]')).toBeVisible()
  })
  
  test('user can create and edit profile', async ({ page }) => {
    // 预设登录状态
    await page.goto('/login')
    // ... 登录逻辑
    
    // 创建个人资料
    await page.goto('/profile/edit')
    await page.fill('#bio', 'This is my bio')
    await page.selectOption('#country', 'US')
    await page.click('button[type="submit"]')
    
    // 验证保存成功
    await expect(page.locator('.profile-bio')).toContainText('This is my bio')
  })
})
```



## Vue 组件的文档生成与示例展示系统

### Storybook 配置

**Storybook 主配置**

```javascript
// .storybook/main.js
module.exports = {
  stories: ['../src/**/*.stories.@(js|jsx|ts|tsx|mdx)'],
  addons: [
    '@storybook/addon-essentials',
    '@storybook/addon-docs',
    '@storybook/addon-controls',
    '@storybook/addon-viewport',
    '@storybook/addon-a11y'
  ],
  framework: '@storybook/vue3',
  features: {
    buildStoriesJson: true
  },
  viteFinal: async (config) => {
    config.plugins = config.plugins || []
    config.plugins.push(
      require('@vitejs/plugin-vue')()
    )
    return config
  }
}
```

**组件 Story 示例**

```javascript
// src/components/Button/Button.stories.js
import Button from './Button.vue'

export default {
  title: 'Components/Button',
  component: Button,
  argTypes: {
    type: {
      control: { type: 'select' },
      options: ['primary', 'secondary', 'danger', 'ghost']
    },
    size: {
      control: { type: 'select' },
      options: ['small', 'medium', 'large']
    },
    disabled: {
      control: { type: 'boolean' }
    },
    loading: {
      control: { type: 'boolean' }
    }
  }
}

const Template = (args) => ({
  components: { Button },
  setup() {
    return { args }
  },
  template: '<Button v-bind="args">{{ args.default }}</Button>'
})

export const Primary = Template.bind({})
Primary.args = {
  type: 'primary',
  default: 'Primary Button'
}

export const Secondary = Template.bind({})
Secondary.args = {
  type: 'secondary',
  default: 'Secondary Button'
}

export const Loading = Template.bind({})
Loading.args = {
  type: 'primary',
  loading: true,
  default: 'Loading...'
}

export const AllSizes = () => ({
  components: { Button },
  template: `
    <div class="flex gap-4">
      <Button size="small">Small</Button>
      <Button size="medium">Medium</Button>
      <Button size="large">Large</Button>
    </div>
  `
})
```

### VitePress 文档系统

**VitePress 配置**

```javascript
// docs/.vitepress/config.js
import { defineConfig } from 'vitepress'

export default defineConfig({
  title: 'Vue Component Library',
  description: 'A comprehensive Vue 3 component library',
  themeConfig: {
    nav: [
      { text: 'Guide', link: '/guide/' },
      { text: 'Components', link: '/components/' },
      { text: 'API', link: '/api/' }
    ],
    sidebar: {
      '/guide/': [
        {
          text: 'Getting Started',
          items: [
            { text: 'Installation', link: '/guide/installation' },
            { text: 'Quick Start', link: '/guide/quick-start' },
            { text: 'Theming', link: '/guide/theming' }
          ]
        }
      ],
      '/components/': [
        {
          text: 'Basic Components',
          items: [
            { text: 'Button', link: '/components/button' },
            { text: 'Input', link: '/components/input' },
            { text: 'Card', link: '/components/card' }
          ]
        }
      ]
    }
  },
  vite: {
    plugins: [
      // 自定义插件处理 Vue 组件示例
    ]
  }
})
```

**组件文档示例**

```markdown
# Button 按钮

基础的按钮组件，支持多种类型和状态。

## 基础用法

<demo>
<template>
  <div class="demo-button">
    <Button type="primary">Primary</Button>
    <Button type="secondary">Secondary</Button>
    <Button type="danger">Danger</Button>
  </div>
</template>
</demo>

## 禁用状态

<demo>
<template>
  <div class="demo-button">
    <Button disabled>Disabled Button</Button>
    <Button type="primary" disabled>Primary Disabled</Button>
  </div>
</template>
</demo>

## API

### Props

| 参数 | 说明 | 类型 | 可选值 | 默认值 |
|------|------|------|--------|--------|
| type | 按钮类型 | string | primary / secondary / danger / ghost | - |
| size | 按钮尺寸 | string | small / medium / large | medium |
| disabled | 是否禁用 | boolean | - | false |
| loading | 是否加载中 | boolean | - | false |

### Events

| 事件名 | 说明 | 回调参数 |
|--------|------|----------|
| click | 点击事件 | (event: MouseEvent) |

### Slots

| 插槽名 | 说明 |
|-------|------|
| default | 按钮内容 |
```



## 企业级 Vue 组件库开发工作流

### 项目结构设计

```
vue-ui-library/
├── packages/
│   ├── components/          # 组件源码
│   │   ├── button/
│   │   ├── input/
│   │   └── index.ts
│   ├── theme/              # 主题相关
│   ├── utils/              # 工具函数
│   └── icons/              # 图标库
├── docs/                   # 文档
├── playground/             # 开发调试
├── tests/                  # 测试
├── scripts/                # 构建脚本
└── tools/                  # 开发工具
```

### 组件开发模板

**组件模板生成器**

```javascript
// scripts/create-component.js
const fs = require('fs')
const path = require('path')

function createComponent(componentName) {
  const componentDir = path.join(__dirname, '../packages/components', componentName)
  
  // 创建目录结构
  fs.mkdirSync(componentDir, { recursive: true })
  
  // 生成组件文件
  const componentTemplate = `
<template>
  <div class="ui-${componentName.toLowerCase()}">
    <slot />
  </div>
</template>

<script setup lang="ts">
import { defineProps, defineEmits } from 'vue'

interface Props {
  // 定义 props 类型
}

interface Emits {
  // 定义 emits 类型
}

const props = withDefaults(defineProps<Props>(), {
  // 默认值
})

const emit = defineEmits<Emits>()
</script>

<style scoped lang="scss">
.ui-${componentName.toLowerCase()} {
  // 组件样式
}
</style>
`

  fs.writeFileSync(
    path.join(componentDir, `${componentName}.vue`), 
    componentTemplate
  )
  
  // 生成 index.ts
  const indexTemplate = `
import ${componentName} from './${componentName}.vue'
import type { App } from 'vue'

${componentName}.install = (app: App) => {
  app.component('Ui${componentName}', ${componentName})
}

export default ${componentName}
`
  
  fs.writeFileSync(
    path.join(componentDir, 'index.ts'), 
    indexTemplate
  )
  
  console.log(`Component ${componentName} created successfully!`)
}

// 使用: node scripts/create-component.js Button
const componentName = process.argv[2]
if (componentName) {
  createComponent(componentName)
}
```

### 自动化发布流程

**Release 配置**

```javascript
// scripts/release.js
const { execSync } = require('child_process')
const inquirer = require('inquirer')
const semver = require('semver')
const fs = require('fs')

async function release() {
  // 1. 检查工作区状态
  const status = execSync('git status --porcelain', { encoding: 'utf8' })
  if (status) {
    console.error('Working directory is not clean')
    process.exit(1)
  }
  
  // 2. 运行测试
  console.log('Running tests...')
  execSync('npm run test', { stdio: 'inherit' })
  
  // 3. 构建
  console.log('Building...')
  execSync('npm run build', { stdio: 'inherit' })
  
  // 4. 版本选择
  const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'))
  const currentVersion = pkg.version
  
  const { version } = await inquirer.prompt([
    {
      type: 'list',
      name: 'version',
      message: 'Select release type:',
      choices: [
        { name: `patch (${semver.inc(currentVersion, 'patch')})`, value: 'patch' },
        { name: `minor (${semver.inc(currentVersion, 'minor')})`, value: 'minor' },
        { name: `major (${semver.inc(currentVersion, 'major')})`, value: 'major' },
        { name: 'custom', value: 'custom' }
      ]
    }
  ])
  
  const newVersion = version === 'custom' 
    ? (await inquirer.prompt([{ name: 'version', message: 'Enter version:' }])).version
    : semver.inc(currentVersion, version)
  
  // 5. 更新版本号
  pkg.version = newVersion
  fs.writeFileSync('package.json', JSON.stringify(pkg, null, 2))
  
  // 6. 提交并打标签
  execSync(`git add package.json`)
  execSync(`git commit -m "release: v${newVersion}"`)
  execSync(`git tag v${newVersion}`)
  
  // 7. 发布到 npm
  execSync('npm publish', { stdio: 'inherit' })
  
  // 8. 推送到远程仓库
  execSync('git push origin main --tags')
  
  console.log(`Released v${newVersion} successfully!`)
}

release().catch(console.error)
```





## 多团队协作下的 Vue 项目管理与模块解耦

### 微前端架构设计

**主应用框架**

```javascript
// apps/main/src/main.js
import { createApp } from 'vue'
import { createRouter, createWebHistory } from 'vue-router'
import App from './App.vue'

// 微应用注册
const microApps = [
  {
    name: 'user-module',
    entry: 'http://localhost:8081',
    container: '#user-container',
    activeRule: '/user'
  },
  {
    name: 'product-module',
    entry: 'http://localhost:8082',
    container: '#product-container',
    activeRule: '/product'
  }
]

// 路由配置
const routes = [
  {
    path: '/user/:pathMatch(.*)*',
    component: () => import('./MicroApp.vue'),
    props: { appName: 'user-module' }
  },
  {
    path: '/product/:pathMatch(.*)*',
    component: () => import('./MicroApp.vue'),
    props: { appName: 'product-module' }
  }
]

const router = createRouter({
  history: createWebHistory(),
  routes
})

const app = createApp(App)
app.use(router)
app.mount('#app')
```

**团队边界协议**

```typescript
// shared/types/team-contracts.ts
export interface TeamContract {
  team: string
  modules: string[]
  apis: ApiContract[]
  events: EventContract[]
  dependencies: string[]
}

export interface ApiContract {
  name: string
  method: 'GET' | 'POST' | 'PUT' | 'DELETE'
  path: string
  request?: any
  response?: any
}

export interface EventContract {
  name: string
  payload?: any
}

// 用户团队协议
export const userTeamContract: TeamContract = {
  team: 'user-team',
  modules: ['user-management', 'user-profile', 'authentication'],
  apis: [
    {
      name: 'getUserInfo',
      method: 'GET',
      path: '/api/user/:id',
      response: {
        id: 'string',
        name: 'string',
        email: 'string'
      }
    }
  ],
  events: [
    {
      name: 'user-login',
      payload: {
        userId: 'string',
        timestamp: 'number'
      }
    }
  ],
  dependencies: ['@shared/ui-components', '@shared/utils']
}
```

### 跨团队通信机制

**事件总线系统**

```typescript
// shared/event-bus.ts
class EventBus {
  private events: Map<string, Function[]> = new Map()
  
  on(event: string, callback: Function) {
    if (!this.events.has(event)) {
      this.events.set(event, [])
    }
    this.events.get(event)!.push(callback)
  }
  
  emit(event: string, data?: any) {
    const callbacks = this.events.get(event)
    if (callbacks) {
      callbacks.forEach(callback => callback(data))
    }
  }
  
  off(event: string, callback?: Function) {
    if (!callback) {
      this.events.delete(event)
      return
    }
    
    const callbacks = this.events.get(event)
    if (callbacks) {
      const index = callbacks.indexOf(callback)
      if (index > -1) {
        callbacks.splice(index, 1)
      }
    }
  }
}

export const globalEventBus = new EventBus()

// 在 Vue 应用中使用
import { getCurrentInstance } from 'vue'

export function useEventBus() {
  const instance = getCurrentInstance()
  
  const emit = (event: string, data?: any) => {
    globalEventBus.emit(event, data)
  }
  
  const on = (event: string, callback: Function) => {
    globalEventBus.on(event, callback)
    
    // 组件卸载时自动清理
    if (instance) {
      const { scope } = instance
      scope.stop = () => {
        globalEventBus.off(event, callback)
      }
    }
  }
  
  return { emit, on }
}
```



## Vue 项目的渐进式迁移策略

### Vue 2 到 Vue 3 迁移方案

**兼容性构建配置**

```javascript
// vue.config.js (Vue 2 项目)
const { defineConfig } = require('@vue/cli-service')

module.exports = defineConfig({
  // 启用 Vue 3 兼容模式
  chainWebpack: config => {
    config.resolve.alias.set('vue', '@vue/compat')
    
    config.module
      .rule('vue')
      .use('vue-loader')
      .tap(options => {
        return {
          ...options,
          compilerOptions: {
            compatConfig: {
              MODE: 2
            }
          }
        }
      })
  }
})
```

**渐进式迁移工具**

```javascript
// scripts/migration-helper.js
const fs = require('fs')
const path = require('path')
const { parse } = require('@vue/compiler-sfc')

class MigrationHelper {
  constructor(srcDir) {
    this.srcDir = srcDir
    this.issues = []
  }
  
  // 检测需要迁移的内容
  checkCompatibility() {
    this.scanDirectory(this.srcDir)
    this.generateReport()
  }
  
  scanDirectory(dir) {
    const files = fs.readdirSync(dir)
    
    files.forEach(file => {
      const filePath = path.join(dir, file)
      const stat = fs.statSync(filePath)
      
      if (stat.isDirectory()) {
        this.scanDirectory(filePath)
      } else if (file.endsWith('.vue')) {
        this.checkVueFile(filePath)
      } else if (file.endsWith('.js') || file.endsWith('.ts')) {
        this.checkJSFile(filePath)
      }
    })
  }
  
  checkVueFile(filePath) {
    const content = fs.readFileSync(filePath, 'utf8')
    const { descriptor } = parse(content, { filename: filePath })
    
    // 检查 Vue 2 特有语法
    if (descriptor.script) {
      this.checkVue2Patterns(descriptor.script.content, filePath)
    }
    
    if (descriptor.template) {
      this.checkTemplatePatterns(descriptor.template.content, filePath)
    }
  }
  
  checkVue2Patterns(content, filePath) {
    const patterns = [
      {
        pattern: /\$listeners/g,
        message: '$listeners 已被移除，使用 $attrs 替代',
        severity: 'error'
      },
      {
        pattern: /\$scopedSlots/g,
        message: '$scopedSlots 已被移除，使用 $slots 替代',
        severity: 'error'
      },
      {
        pattern: /Vue\.filter/g,
        message: '过滤器已被移除，使用计算属性或方法替代',
        severity: 'error'
      },
      {
        pattern: /new Vue\(/g,
        message: '使用 createApp() 替代 new Vue()',
        severity: 'warning'
      }
    ]
    
    patterns.forEach(({ pattern, message, severity }) => {
      const matches = content.match(pattern)
      if (matches) {
        this.issues.push({
          file: filePath,
          type: severity,
          message,
          count: matches.length
        })
      }
    })
  }
  
  generateReport() {
    const report = {
      total: this.issues.length,
      errors: this.issues.filter(i => i.type === 'error').length,
      warnings: this.issues.filter(i => i.type === 'warning').length,
      issues: this.issues
    }
    
    fs.writeFileSync(
      'migration-report.json',
      JSON.stringify(report, null, 2)
    )
    
    console.log(`Migration Report Generated:`)
    console.log(`Total Issues: ${report.total}`)
    console.log(`Errors: ${report.errors}`)
    console.log(`Warnings: ${report.warnings}`)
  }
}

// 使用迁移助手
const migrationHelper = new MigrationHelper('./src')
migrationHelper.checkCompatibility()
```

**分步迁移策略**

```javascript
// 第一阶段：基础 API 迁移
// migration/phase1-basic-api.js
export function migrateBasicAPIs(content) {
  return content
    // Vue 实例创建
    .replace(/new Vue\(\{/g, 'createApp({')
    // 全局 API
    .replace(/Vue\.extend/g, 'defineComponent')
    .replace(/Vue\.component/g, 'app.component')
    .replace(/Vue\.directive/g, 'app.directive')
    .replace(/Vue\.mixin/g, 'app.mixin')
    .replace(/Vue\.use/g, 'app.use')
    // 实例方法
    .replace(/\$mount\(['"](.*?)['"]\)/g, 'mount("$1")')
}

// 第二阶段：组合式 API 迁移
// migration/phase2-composition-api.js
export function migrateToCompositionAPI(vueComponent) {
  const template = `
<template>
  ${vueComponent.template}
</template>

<script setup>
import { ref, reactive, computed, watch, onMounted } from 'vue'

// 将 data 转换为 reactive/ref
${convertDataToRefs(vueComponent.data)}

// 将 computed 转换
${convertComputed(vueComponent.computed)}

// 将 methods 转换为函数
${convertMethods(vueComponent.methods)}

// 将生命周期钩子转换
${convertLifecycle(vueComponent)}

// 将 watch 转换
${convertWatchers(vueComponent.watch)}
</script>

<style scoped>
${vueComponent.style}
</style>
`
  return template
}
```

### 版本兼容性管理

**特性开关系统**

```typescript
// utils/feature-flags.ts
interface FeatureFlags {
  useVue3Features: boolean
  enableCompositionAPI: boolean
  useTeleport: boolean
  useFragments: boolean
}

class FeatureFlagManager {
  private flags: FeatureFlags
  
  constructor() {
    this.flags = {
      useVue3Features: this.checkVueVersion() >= 3,
      enableCompositionAPI: true,
      useTeleport: this.checkVueVersion() >= 3,
      useFragments: this.checkVueVersion() >= 3
    }
  }
  
  private checkVueVersion(): number {
    // @ts-ignore
    const version = require('vue/package.json').version
    return parseInt(version.split('.')[0])
  }
  
  isEnabled(flag: keyof FeatureFlags): boolean {
    return this.flags[flag]
  }
  
  enable(flag: keyof FeatureFlags) {
    this.flags[flag] = true
  }
  
  disable(flag: keyof FeatureFlags) {
    this.flags[flag] = false
  }
}

export const featureFlags = new FeatureFlagManager()

// 在组件中使用
export function useFeatureFlag(flag: keyof FeatureFlags) {
  return featureFlags.isEnabled(flag)
}
```



## Monorepo 在 Vue 项目中的应用与实践

### Lerna + pnpm 配置

**项目结构**

```
vue-monorepo/
├── packages/
│   ├── ui-components/          # 组件库
│   ├── utils/                  # 工具库
│   ├── theme/                  # 主题包
│   ├── icons/                  # 图标包
│   ├── web-app/               # Web 应用
│   ├── mobile-app/            # 移动端应用
│   └── admin-app/             # 管理后台
├── tools/
│   ├── build-tools/           # 构建工具
│   ├── eslint-config/         # ESLint 配置
│   └── jest-config/           # Jest 配置
├── docs/                      # 文档
├── pnpm-workspace.yaml
├── lerna.json
└── package.json
```

**Workspace 配置**

```yaml
# pnpm-workspace.yaml
packages:
  - 'packages/*'
  - 'tools/*'
  - 'docs'
```

```json
// lerna.json
{
  "version": "independent",
  "npmClient": "pnpm",
  "useWorkspaces": true,
  "command": {
    "publish": {
      "conventionalCommits": true,
      "message": "chore(release): publish",
      "registry": "https://registry.npmjs.org/"
    },
    "version": {
      "allowBranch": ["main", "release/*"],
      "conventionalCommits": true
    }
  }
}
```





### 包管理与依赖优化

**根目录 package.json**

```json
{
  "name": "vue-monorepo",
  "private": true,
  "workspaces": ["packages/*", "tools/*"],
  "scripts": {
    "build": "lerna run build",
    "test": "lerna run test",
    "lint": "lerna run lint",
    "dev": "lerna run dev --parallel",
    "clean": "lerna clean && rm -rf node_modules",
    "bootstrap": "lerna bootstrap",
    "publish": "lerna publish",
    "version": "lerna version"
  },
  "devDependencies": {
    "@lerna/cli": "latest",
    "typescript": "latest",
    "vite": "latest",
    "@vue/tsconfig": "latest"
  }
}
```

**子包配置示例**

```json
// packages/ui-components/package.json
{
  "name": "@vue-monorepo/ui-components",
  "version": "1.0.0",
  "main": "dist/index.js",
  "module": "dist/index.esm.js",
  "types": "dist/index.d.ts",
  "files": ["dist"],
  "scripts": {
    "build": "vite build",
    "dev": "vite build --watch",
    "test": "vitest"
  },
  "dependencies": {
    "vue": "^3.3.0"
  },
  "peerDependencies": {
    "vue": "^3.0.0"
  }
}
```

### 构建工具配置

**统一构建配置**

```javascript
// tools/build-tools/vite.config.base.js
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import dts from 'vite-plugin-dts'
import { resolve } from 'path'

export function createViteConfig(options = {}) {
  const {
    entry = 'src/index.ts',
    formats = ['es', 'cjs'],
    external = ['vue'],
    globals = { vue: 'Vue' }
  } = options

  return defineConfig({
    plugins: [
      vue(),
      dts({
        include: ['src/**/*'],
        exclude: ['src/**/*.stories.ts', 'src/**/*.test.ts']
      })
    ],
    build: {
      lib: {
        entry: resolve(process.cwd(), entry),
        formats,
        fileName: (format) => `index.${format}.js`
      },
      rollupOptions: {
        external,
        output: {
          globals
        }
      }
    },
    resolve: {
      alias: {
        '@': resolve(process.cwd(), 'src')
      }
    }
  })
}
```

**应用级构建配置**

```javascript
// packages/web-app/vite.config.js
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import { resolve } from 'path'

export default defineConfig({
  plugins: [vue()],
  resolve: {
    alias: {
      '@': resolve(__dirname, 'src'),
      '@ui': resolve(__dirname, '../ui-components/src'),
      '@utils': resolve(__dirname, '../utils/src')
    }
  },
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          vendor: ['vue', 'vue-router', 'pinia'],
          ui: ['@vue-monorepo/ui-components']
        }
      }
    }
  }
})
```



### 版本发布自动化

**自动化发布脚本**

```javascript
// scripts/release.js
const { execSync } = require('child_process')
const inquirer = require('inquirer')

async function release() {
  console.log('🚀 Starting release process...')
  
  // 1. 检查工作区状态
  try {
    execSync('git diff-index --quiet HEAD --')
  } catch (error) {
    console.error('❌ Working directory is not clean')
    process.exit(1)
  }
  
  // 2. 更新依赖
  console.log('📦 Installing dependencies...')
  execSync('pnpm install', { stdio: 'inherit' })
  
  // 3. 运行测试
  console.log('🧪 Running tests...')
  execSync('pnpm test', { stdio: 'inherit' })
  
  // 4. 构建所有包
  console.log('🔨 Building packages...')
  execSync('pnpm build', { stdio: 'inherit' })
  
  // 5. 选择发布类型
  const { releaseType } = await inquirer.prompt([
    {
      type: 'list',
      name: 'releaseType',
      message: 'Select release type:',
      choices: [
        { name: 'Patch (bug fixes)', value: 'patch' },
        { name: 'Minor (new features)', value: 'minor' },
        { name: 'Major (breaking changes)', value: 'major' },
        { name: 'Prerelease', value: 'prerelease' },
        { name: 'Graduate prerelease', value: 'graduate' }
      ]
    }
  ])
  
  // 6. 版本更新
  console.log('📝 Updating versions...')
  const versionCommand = releaseType === 'graduate' 
    ? 'lerna version --conventional-commits --conventional-graduate'
    : `lerna version ${releaseType} --conventional-commits`
  
  execSync(versionCommand, { stdio: 'inherit' })
  
  // 7. 发布
  const { shouldPublish } = await inquirer.prompt([
    {
      type: 'confirm',
      name: 'shouldPublish',
      message: 'Publish to npm?',
      default: true
    }
  ])
  
  if (shouldPublish) {
    console.log('🚀 Publishing to npm...')
    execSync('lerna publish from-git', { stdio: 'inherit' })
  }
  
  console.log('✅ Release completed!')
}

release().catch(console.error)
```

### 开发工作流优化

**并行开发脚本**

```javascript
// scripts/dev.js
const { spawn } = require('child_process')
const inquirer = require('inquirer')

async function dev() {
  const { packages } = await inquirer.prompt([
    {
      type: 'checkbox',
      name: 'packages',
      message: 'Select packages to run in development mode:',
      choices: [
        { name: 'UI Components', value: 'ui-components' },
        { name: 'Web App', value: 'web-app' },
        { name: 'Mobile App', value: 'mobile-app' },
        { name: 'Admin App', value: 'admin-app' },
        { name: 'Storybook', value: 'storybook' }
      ]
    }
  ])
  
  const processes = []
  
  packages.forEach(pkg => {
    const process = spawn('pnpm', ['--filter', `@vue-monorepo/${pkg}`, 'dev'], {
      stdio: 'inherit',
      shell: true
    })
    
    processes.push(process)
    console.log(`🚀 Started ${pkg} in development mode`)
  })
  
  // 优雅关闭
  process.on('SIGINT', () => {
    console.log('\n🛑 Shutting down all processes...')
    processes.forEach(proc => proc.kill())
    process.exit(0)
  })
}

dev().catch(console.error)
```

**依赖分析工具**

```javascript
// tools/analyze-deps.js
const fs = require('fs')
const path = require('path')
const glob = require('glob')

class DependencyAnalyzer {
  constructor() {
    this.packages = new Map()
    this.dependencies = new Map()
  }
  
  analyze() {
    this.scanPackages()
    this.buildDependencyGraph()
    this.generateReport()
  }
  
  scanPackages() {
    const packagePaths = glob.sync('packages/*/package.json')
    
    packagePaths.forEach(pkgPath => {
      const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf8'))
      const packageDir = path.dirname(pkgPath)
      
      this.packages.set(pkg.name, {
        ...pkg,
        path: packageDir,
        localDeps: this.findLocalDependencies(pkg),
        externalDeps: this.findExternalDependencies(pkg)
      })
    })
  }
  
  findLocalDependencies(pkg) {
    const deps = { ...pkg.dependencies, ...pkg.devDependencies }
    return Object.keys(deps).filter(dep => dep.startsWith('@vue-monorepo/'))
  }
  
  findExternalDependencies(pkg) {
    const deps = { ...pkg.dependencies, ...pkg.devDependencies }
    return Object.keys(deps).filter(dep => !dep.startsWith('@vue-monorepo/'))
  }
  
  buildDependencyGraph() {
    this.packages.forEach((pkg, name) => {
      pkg.localDeps.forEach(dep => {
        if (!this.dependencies.has(name)) {
          this.dependencies.set(name, [])
        }
        this.dependencies.get(name).push(dep)
      })
    })
  }
  
  generateReport() {
    const report = {
      packages: Array.from(this.packages.values()),
      dependencyGraph: Object.fromEntries(this.dependencies),
      duplicateDependencies: this.findDuplicateDependencies(),
      circularDependencies: this.findCircularDependencies()
    }
    
    fs.writeFileSync('dependency-report.json', JSON.stringify(report, null, 2))
    console.log('📊 Dependency analysis completed!')
  }
  
  findDuplicateDependencies() {
    const allDeps = new Map()
    
    this.packages.forEach(pkg => {
      pkg.externalDeps.forEach(dep => {
        if (!allDeps.has(dep)) {
          allDeps.set(dep, [])
        }
        allDeps.get(dep).push(pkg.name)
      })
    })
    
    return Array.from(allDeps.entries())
      .filter(([dep, packages]) => packages.length > 1)
      .map(([dep, packages]) => ({ dependency: dep, packages }))
  }
  
  findCircularDependencies() {
    // 简化的循环依赖检测
    const visited = new Set()
    const recursionStack = new Set()
    const cycles = []
    
    const dfs = (node, path = []) => {
      if (recursionStack.has(node)) {
        const cycleStart = path.indexOf(node)
        cycles.push(path.slice(cycleStart).concat(node))
        return
      }
      
      if (visited.has(node)) return
      
      visited.add(node)
      recursionStack.add(node)
      path.push(node)
      
      const deps = this.dependencies.get(node) || []
      deps.forEach(dep => dfs(dep, [...path]))
      
      recursionStack.delete(node)
    }
    
    this.packages.forEach((pkg, name) => {
      if (!visited.has(name)) {
        dfs(name)
      }
    })
    
    return cycles
  }
}

// 使用分析工具
const analyzer = new DependencyAnalyzer()
analyzer.analyze()
```

## 总结

Vue项目的工程化实践需要从多个维度综合考虑：

1. **代码质量保证** - 通过ESLint、Prettier、StyleLint等工具建立代码规范，配合Git Hooks确保代码质量
2. **测试策略** - 建立完整的测试体系，包括单元测试、组件测试和E2E测试，确保代码的可靠性
3. **文档与示例** - 使用Storybook和VitePress等工具建立完善的文档系统，提升团队协作效率
4. **组件库工作流** - 设计标准化的组件开发、测试、发布流程，支持大规模团队协作
5. **模块解耦** - 通过微前端架构和事件总线等技术实现团队间的松耦合协作
6. **渐进式迁移** - 制定合理的技术栈升级策略，降低迁移风险和成本
7. **Monorepo管理** - 使用现代化的包管理工具，实现代码复用和统一管理





# Vue 3 + TypeScript 深度集成

## Vue 3 中的 TypeScript 类型系统设计与实现原理

###  Vue 3 类型系统架构

Vue 3 的类型系统基于以下核心设计原则：

```typescript
// Vue 3 的核心类型定义结构
interface ComponentInternalInstance {
  uid: number
  vnode: VNode
  type: ConcreteComponent
  parent: ComponentInternalInstance | null
  appContext: AppContext
  // ... 更多内部属性
}

// 组件类型的抽象
type Component<P = {}, RawBindings = any> = 
  | ConcreteComponent<P, RawBindings>
  | ComponentPublicInstanceConstructor<P>

// 响应式系统的类型基础
interface Ref<T = any> {
  value: T
  [RefSymbol]: true
}
```



### 响应式系统的类型实现

```typescript
// 响应式引用的类型推导
function ref<T>(value: T): Ref<UnwrapRef<T>>
function ref<T = any>(): Ref<T | undefined>

// 计算属性的类型推导
function computed<T>(
  getter: ComputedGetter<T>,
  debugOptions?: DebuggerOptions
): ComputedRef<T>

function computed<T>(
  options: WritableComputedOptions<T>,
  debugOptions?: DebuggerOptions
): WritableComputedRef<T>

// 响应式对象的类型转换
type UnwrapRef<T> = T extends Ref<infer V>
  ? UnwrapRefSimple<V>
  : UnwrapRefSimple<T>

type UnwrapRefSimple<T> = T extends
  | Function
  | CollectionTypes
  | BaseTypes
  | Ref
  | RefUnwrapBailTypes[keyof RefUnwrapBailTypes]
  ? T
  : T extends Array<any>
  ? { [K in keyof T]: UnwrapRefSimple<T[K]> }
  : T extends object & { [ShallowReactiveMarker]?: never }
  ? {
      [P in keyof T]: P extends symbol ? T[P] : UnwrapRef<T[P]>
    }
  : T
```



### 组件定义的类型系统

```typescript
// defineComponent 的类型重载
function defineComponent<Props, RawBindings = object>(
  setup: (
    props: Readonly<Props>,
    ctx: SetupContext
  ) => RawBindings | RenderFunction
): DefineComponent<Props, RawBindings>

// 组件选项的类型定义
interface ComponentOptionsBase<V, D, C, M, E> {
  setup?: (
    props: Readonly<Props>,
    ctx: SetupContext<E>
  ) => Promise<RenderFunction | void> | RenderFunction | void
  name?: string
  template?: string | object
  render?: Function
  components?: Record<string, Component>
  directives?: Record<string, Directive>
  // ...更多选项
}
```



## Vue 组件 Props 的复杂类型定义与校验

### 基础 Props 类型定义

```typescript
// 基础 Props 接口定义
interface UserProps {
  id: number
  name: string
  email?: string
  roles: string[]
  metadata: Record<string, any>
}

// 组件中使用 Props
import { defineComponent, PropType } from 'vue'

export default defineComponent({
  props: {
    id: {
      type: Number,
      required: true
    },
    name: {
      type: String,
      required: true,
      validator: (value: string) => value.length > 0
    },
    email: {
      type: String,
      default: ''
    },
    roles: {
      type: Array as PropType<string[]>,
      required: true,
      validator: (roles: string[]) => roles.every(role => 
        ['admin', 'user', 'guest'].includes(role)
      )
    },
    metadata: {
      type: Object as PropType<Record<string, any>>,
      default: () => ({})
    }
  },
  setup(props) {
    // props 在这里已经具有完整的类型推导
    console.log(props.id) // number
    console.log(props.name) // string
    console.log(props.roles) // string[]
    
    return {}
  }
})
```



### 复杂 Props 类型和联合类型

```typescript
// 复杂类型定义
type ButtonVariant = 'primary' | 'secondary' | 'danger' | 'ghost'
type ButtonSize = 'small' | 'medium' | 'large'

interface ButtonConfig {
  variant: ButtonVariant
  size: ButtonSize
  disabled?: boolean
  loading?: boolean
}

// 联合类型的 Props
type DataSource = 
  | { type: 'api'; url: string; params?: Record<string, any> }
  | { type: 'static'; data: any[] }
  | { type: 'computed'; getter: () => any[] }

const DataTable = defineComponent({
  props: {
    config: {
      type: Object as PropType<ButtonConfig>,
      required: true,
      validator: (config: ButtonConfig) => {
        const validVariants: ButtonVariant[] = ['primary', 'secondary', 'danger', 'ghost']
        const validSizes: ButtonSize[] = ['small', 'medium', 'large']
        
        return validVariants.includes(config.variant) && 
               validSizes.includes(config.size)
      }
    },
    dataSource: {
      type: Object as PropType<DataSource>,
      required: true,
      validator: (source: DataSource) => {
        switch (source.type) {
          case 'api':
            return typeof source.url === 'string'
          case 'static':
            return Array.isArray(source.data)
          case 'computed':
            return typeof source.getter === 'function'
          default:
            return false
        }
      }
    }
  },
  setup(props) {
    // 类型推导和类型守卫
    const loadData = () => {
      const { dataSource } = props
      
      if (dataSource.type === 'api') {
        // TypeScript 知道这里 dataSource 有 url 属性
        return fetch(dataSource.url)
      } else if (dataSource.type === 'static') {
        // TypeScript 知道这里 dataSource 有 data 属性
        return Promise.resolve(dataSource.data)
      } else {
        // TypeScript 知道这里 dataSource 有 getter 属性
        return Promise.resolve(dataSource.getter())
      }
    }
    
    return { loadData }
  }
})
```



### 泛型 Props 和高级类型约束

```typescript
// 泛型组件定义
function defineGenericComponent<T extends Record<string, any>>() {
  return defineComponent({
    props: {
      items: {
        type: Array as PropType<T[]>,
        required: true
      },
      keyField: {
        type: String as PropType<keyof T>,
        required: true
      },
      displayField: {
        type: String as PropType<keyof T>,
        required: true
      }
    },
    setup(props) {
      const getItemKey = (item: T) => item[props.keyField]
      const getItemDisplay = (item: T) => item[props.displayField]
      
      return {
        getItemKey,
        getItemDisplay
      }
    }
  })
}

// 使用泛型组件
interface User {
  id: number
  name: string
  email: string
}

const UserList = defineGenericComponent<User>()

// 类型约束的 Props
interface ListProps<T, K extends keyof T> {
  items: T[]
  keyField: K
  sortBy?: K
  filterBy?: Partial<Pick<T, K>>
}

const GenericList = <T extends Record<string, any>, K extends keyof T>() =>
  defineComponent({
    props: {
      items: {
        type: Array as PropType<T[]>,
        required: true
      },
      keyField: {
        type: String as PropType<K>,
        required: true
      },
      sortBy: {
        type: String as PropType<K>
      },
      filterBy: {
        type: Object as PropType<Partial<Pick<T, K>>>
      }
    },
    setup(props) {
      const sortedItems = computed(() => {
        if (!props.sortBy) return props.items
        
        return [...props.items].sort((a, b) => {
          const aVal = a[props.sortBy!]
          const bVal = b[props.sortBy!]
          
          if (aVal < bVal) return -1
          if (aVal > bVal) return 1
          return 0
        })
      })
      
      const filteredItems = computed(() => {
        if (!props.filterBy) return sortedItems.value
        
        return sortedItems.value.filter(item => {
          return Object.entries(props.filterBy!).every(([key, value]) =>
            item[key] === value
          )
        })
      })
      
      return {
        sortedItems,
        filteredItems
      }
    }
  })
```



## 如何为 Vue 组合式函数编写精确的 TypeScript 类型

### 基础 Composable 函数类型

```typescript
// 状态管理 Composable
function useCounter(initialValue = 0) {
  const count = ref(initialValue)
  
  const increment = (step = 1) => {
    count.value += step
  }
  
  const decrement = (step = 1) => {
    count.value -= step
  }
  
  const reset = () => {
    count.value = initialValue
  }
  
  return {
    count: readonly(count),
    increment,
    decrement,
    reset
  } as const // 使用 as const 保持类型精确性
}

// 返回类型会被推导为：
// {
//   readonly count: DeepReadonly<Ref<number>>
//   readonly increment: (step?: number) => void
//   readonly decrement: (step?: number) => void
//   readonly reset: () => void
// }
```

### 泛型 Composable 函数

```typescript
// 泛型数据获取 Hook
interface UseAsyncStateOptions<T> {
  initialData?: T
  resetOnExecute?: boolean
  immediate?: boolean
  onError?: (error: Error) => void
  onSuccess?: (data: T) => void
}

interface UseAsyncStateReturn<T> {
  data: Ref<T | undefined>
  loading: Ref<boolean>
  error: Ref<Error | null>
  execute: () => Promise<T>
  reset: () => void
}

function useAsyncState<T>(
  promise: () => Promise<T>,
  options: UseAsyncStateOptions<T> = {}
): UseAsyncStateReturn<T> {
  const {
    initialData,
    resetOnExecute = true,
    immediate = true,
    onError,
    onSuccess
  } = options
  
  const data = ref<T | undefined>(initialData)
  const loading = ref(false)
  const error = ref<Error | null>(null)
  
  const execute = async (): Promise<T> => {
    try {
      loading.value = true
      if (resetOnExecute) {
        error.value = null
      }
      
      const result = await promise()
      data.value = result
      onSuccess?.(result)
      return result
    } catch (err) {
      const errorObj = err instanceof Error ? err : new Error(String(err))
      error.value = errorObj
      onError?.(errorObj)
      throw errorObj
    } finally {
      loading.value = false
    }
  }
  
  const reset = () => {
    data.value = initialData
    loading.value = false
    error.value = null
  }
  
  if (immediate) {
    nextTick(execute)
  }
  
  return {
    data,
    loading,
    error,
    execute,
    reset
  }
}

// 使用示例
interface User {
  id: number
  name: string
  email: string
}

const { data: userData, loading, error, execute } = useAsyncState<User>(
  () => fetch('/api/user').then(res => res.json()),
  {
    onSuccess: (user) => {
      console.log(`User ${user.name} loaded`) // user 类型为 User
    },
    onError: (err) => {
      console.error('Failed to load user:', err.message)
    }
  }
)
```



### 复杂 Composable 函数类型推导

```typescript
// 表单验证 Composable
type ValidationRule<T> = (value: T) => string | null

interface UseFormFieldOptions<T> {
  initialValue: T
  rules?: ValidationRule<T>[]
  validateOnChange?: boolean
  validateOnBlur?: boolean
}

interface UseFormFieldReturn<T> {
  value: Ref<T>
  error: Ref<string | null>
  isValid: ComputedRef<boolean>
  isDirty: ComputedRef<boolean>
  isTouched: Ref<boolean>
  validate: () => boolean
  reset: () => void
  setValue: (newValue: T) => void
}

function useFormField<T>(
  options: UseFormFieldOptions<T>
): UseFormFieldReturn<T> {
  const {
    initialValue,
    rules = [],
    validateOnChange = false,
    validateOnBlur = true
  } = options
  
  const value = ref<T>(initialValue)
  const error = ref<string | null>(null)
  const isTouched = ref(false)
  const initialValueRef = ref<T>(initialValue)
  
  const isValid = computed(() => error.value === null)
  const isDirty = computed(() => value.value !== initialValueRef.value)
  
  const validate = (): boolean => {
    for (const rule of rules) {
      const result = rule(value.value)
      if (result) {
        error.value = result
        return false
      }
    }
    error.value = null
    return true
  }
  
  const setValue = (newValue: T) => {
    value.value = newValue
    if (validateOnChange) {
      validate()
    }
  }
  
  const reset = () => {
    value.value = initialValueRef.value
    error.value = null
    isTouched.value = false
  }
  
  const handleBlur = () => {
    isTouched.value = true
    if (validateOnBlur) {
      validate()
    }
  }
  
  // 监听值变化
  watch(value, () => {
    if (validateOnChange && isTouched.value) {
      validate()
    }
  })
  
  return {
    value,
    error,
    isValid,
    isDirty,
    isTouched,
    validate,
    reset,
    setValue
  }
}

// 复合表单 Composable
interface FormField<T = any> {
  value: Ref<T>
  error: Ref<string | null>
  isValid: ComputedRef<boolean>
  validate: () => boolean
  reset: () => void
}

type FormFields<T extends Record<string, any>> = {
  [K in keyof T]: FormField<T[K]>
}

interface UseFormReturn<T extends Record<string, any>> {
  fields: FormFields<T>
  isValid: ComputedRef<boolean>
  isDirty: ComputedRef<boolean>
  values: ComputedRef<T>
  errors: ComputedRef<Partial<Record<keyof T, string>>>
  validate: () => boolean
  reset: () => void
  submit: (onSubmit: (values: T) => void | Promise<void>) => Promise<void>
}

function useForm<T extends Record<string, any>>(
  fieldDefinitions: {
    [K in keyof T]: UseFormFieldOptions<T[K]>
  }
): UseFormReturn<T> {
  const fields = {} as FormFields<T>
  
  // 创建所有字段
  for (const [fieldName, options] of Object.entries(fieldDefinitions)) {
    fields[fieldName as keyof T] = useFormField(options as any)
  }
  
  const isValid = computed(() =>
    Object.values(fields).every((field: any) => field.isValid.value)
  )
  
  const isDirty = computed(() =>
    Object.values(fields).some((field: any) => field.isDirty.value)
  )
  
  const values = computed(() => {
    const result = {} as T
    for (const [key, field] of Object.entries(fields)) {
      result[key as keyof T] = (field as any).value.value
    }
    return result
  })
  
  const errors = computed(() => {
    const result: Partial<Record<keyof T, string>> = {}
    for (const [key, field] of Object.entries(fields)) {
      const errorValue = (field as any).error.value
      if (errorValue) {
        result[key as keyof T] = errorValue
      }
    }
    return result
  })
  
  const validate = (): boolean => {
    return Object.values(fields).every((field: any) => field.validate())
  }
  
  const reset = () => {
    Object.values(fields).forEach((field: any) => field.reset())
  }
  
  const submit = async (onSubmit: (values: T) => void | Promise<void>) => {
    if (validate()) {
      await onSubmit(values.value)
    }
  }
  
  return {
    fields,
    isValid,
    isDirty,
    values,
    errors,
    validate,
    reset,
    submit
  }
}

// 使用示例
interface LoginForm {
  username: string
  password: string
  rememberMe: boolean
}

const loginForm = useForm<LoginForm>({
  username: {
    initialValue: '',
    rules: [
      (value) => !value ? 'Username is required' : null,
      (value) => value.length < 3 ? 'Username must be at least 3 characters' : null
    ],
    validateOnChange: true
  },
  password: {
    initialValue: '',
    rules: [
      (value) => !value ? 'Password is required' : null,
      (value) => value.length < 6 ? 'Password must be at least 6 characters' : null
    ]
  },
  rememberMe: {
    initialValue: false
  }
})
```





## Vue 项目中的高级类型技巧与最佳实践

### 类型工具函数和类型体操

```typescript
// 深度只读类型
type DeepReadonly<T> = {
  readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P]
}

// 深度可选类型
type DeepPartial<T> = {
  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P]
}

// 深度必选类型
type DeepRequired<T> = {
  [P in keyof T]-?: T[P] extends object ? DeepRequired<T[P]> : T[P]
}

// 提取函数返回类型的 Promise 值
type PromiseType<T> = T extends Promise<infer U> ? U : T

// 组件实例类型提取
type ComponentInstance<T> = T extends new (...args: any) => infer R ? R : never

// 提取 Props 类型
type ExtractPropTypes<T> = {
  [K in keyof T]: T[K] extends { type: infer U }
    ? U extends new (...args: any) => infer R
      ? R
      : U
    : any
}

// 事件处理器类型
type EventHandlers<T> = {
  [K in keyof T as K extends string ? `on${Capitalize<K>}` : never]?: (
    payload: T[K]
  ) => void
}

// 使用示例
interface UserEvents {
  login: { username: string; timestamp: Date }
  logout: { reason: string }
  profileUpdate: { changes: Partial<User> }
}

type UserEventHandlers = EventHandlers<UserEvents>
// 结果：
// {
//   onLogin?: (payload: { username: string; timestamp: Date }) => void
//   onLogout?: (payload: { reason: string }) => void
//   onProfileUpdate?: (payload: { changes: Partial<User> }) => void
// }
```



### 高级组件类型模式

```typescript
// 高阶组件类型定义
type HOCComponent<P = {}> = <T extends ComponentOptions>(
  WrappedComponent: T
) => DefineComponent<P & ExtractPropTypes<T['props']>>

// 插槽类型安全
interface TableSlots<T = any> {
  header?: (props: { columns: string[] }) => VNode[]
  row?: (props: { item: T; index: number }) => VNode[]
  footer?: (props: { total: number }) => VNode[]
}

const DataTable = defineComponent({
  props: {
    data: {
      type: Array as PropType<any[]>,
      required: true
    },
    columns: {
      type: Array as PropType<string[]>,
      required: true
    }
  },
  setup(props, { slots }) {
    return () => (
      <div class="data-table">
        <div class="table-header">
          {slots.header?.({ columns: props.columns })}
        </div>
        <div class="table-body">
          {props.data.map((item, index) => (
            <div key={index} class="table-row">
              {slots.row?.({ item, index })}
            </div>
          ))}
        </div>
        <div class="table-footer">
          {slots.footer?.({ total: props.data.length })}
        </div>
      </div>
    )
  }
})

// 条件类型组件
type ConditionalComponent<T extends boolean> = T extends true
  ? DefineComponent<{ required: true }>
  : DefineComponent<{ required?: false }>

function createConditionalComponent<T extends boolean>(
  required: T
): ConditionalComponent<T> {
  return defineComponent({
    props: {
      required: {
        type: Boolean,
        default: required
      }
    }
  }) as any
}
```



### 状态管理类型模式

```typescript
// 状态管理器类型定义
interface StoreState {
  user: User | null
  settings: AppSettings
  ui: UIState
}

interface StoreGetters {
  isAuthenticated: boolean
  userDisplayName: string
  themeMode: 'light' | 'dark'
}

interface StoreMutations {
  setUser: (user: User | null) => void
  updateSettings: (settings: Partial<AppSettings>) => void
  toggleTheme: () => void
}

interface StoreActions {
  login: (credentials: LoginCredentials) => Promise<User>
  logout: () => Promise<void>
  fetchUserProfile: () => Promise<User>
}

// 类型安全的 Store 工厂
function createTypedStore<
  State extends Record<string, any>,
  Getters extends Record<string, any>,
  Mutations extends Record<string, (...args: any[]) => void>,
  Actions extends Record<string, (...args: any[]) => any>
>(config: {
  state: () => State
  getters: {
    [K in keyof Getters]: (state: State) => Getters[K]
  }
  mutations: {
    [K in keyof Mutations]: (state: State, ...args: Parameters<Mutations[K]>) => void
  }
  actions: {
    [K in keyof Actions]: (context: {
      state: State
      getters: Getters
      commit: <T extends keyof Mutations>(
        type: T,
        ...payload: Parameters<Mutations[T]>
      ) => void
    }, ...args: Parameters<Actions[K]>) => ReturnType<Actions[K]>
  }
}) {
  // Store 实现逻辑
  return config
}

// 使用类型安全的 Store
const store = createTypedStore({
  state: (): StoreState => ({
    user: null,
    settings: {
      theme: 'light',
      language: 'en'
    },
    ui: {
      sidebarOpen: false,
      loading: false
    }
  }),
  getters: {
    isAuthenticated: (state) => state.user !== null,
    userDisplayName: (state) => state.user?.name || 'Guest',
    themeMode: (state) => state.settings.theme
  },
  mutations: {
    setUser: (state, user) => {
      state.user = user
    },
    updateSettings: (state, settings) => {
      Object.assign(state.settings, settings)
    },
    toggleTheme: (state) => {
      state.settings.theme = state.settings.theme === 'light' ? 'dark' : 'light'
    }
  },
  actions: {
    async login({ commit }, credentials) {
      const response = await fetch('/api/login', {
        method: 'POST',
        body: JSON.stringify(credentials)
      })
      const user = await response.json()
      commit('setUser', user)
      return user
    },
    async logout({ commit }) {
      await fetch('/api/logout', { method: 'POST' })
      commit('setUser', null)
    },
    async fetchUserProfile({ commit }) {
      const response = await fetch('/api/user/profile')
      const user = await response.json()
      commit('setUser', user)
      return user
    }
  }
})
```



##  详解 Vue 3 的类型推导机制及其局限性

###  模板引用的类型推导

```typescript
// 模板引用类型推导
const MyComponent = defineComponent({
  setup() {
    // 基础元素引用
    const inputRef = ref<HTMLInputElement>()
    const divRef = ref<HTMLDivElement>()
    
    // 组件引用
    const childComponentRef = ref<InstanceType<typeof ChildComponent>>()
    
    // 自动类型推导的限制
    const autoRef = ref() // 类型为 Ref<any>
    
    onMounted(() => {
      // 需要类型断言或检查
      if (inputRef.value) {
        inputRef.value.focus() // 类型安全
      }
      
      // 组件方法调用
      childComponentRef.value?.someMethod()
    })
    
    return {
      inputRef,
      divRef,
      childComponentRef
    }
  }
})

// 模板中的使用
/*
<template>
  <input ref="inputRef" />
  <div ref="divRef">Content</div>
  <ChildComponent ref="childComponentRef" />
</template>
*/
```

### 5.2 事件处理器类型推导

```typescript
// 事件处理的类型推导限制
const EventComponent = defineComponent({
  emits: {
    // 明确的事件类型定义
    update: (value: string) => typeof value === 'string',
    change: (event: { old: number; new: number }) => true,
    click: (event: MouseEvent) => true
  },
  setup(props, { emit }) {
    // 类型安全的事件发射
    const handleUpdate = (value: string) => {
      emit('update', value) // 类型检查通过
      // emit('update', 123) // 类型错误
    }
    
    const handleChange = (oldVal: number, newVal: number) => {
      emit('change', { old: oldVal, new: newVal })
    }
    
    const handleClick = (event: MouseEvent) => {
      emit('click', event)
    }
    
    return {
      handleUpdate,
      handleChange,
      handleClick
    }
  }
})

// 父组件中的事件监听
const ParentComponent = defineComponent({
  components: { EventComponent },
  setup() {
    const onUpdate = (value: string) => {
      console.log('Updated:', value) // value 自动推导为 string
    }
    
    const onChange = (event: { old: number; new: number }) => {
      console.log('Changed:', event) // event 类型正确推导
    }
    
    return {
      onUpdate,
      onChange
    }
  }
})
```

### 5.3 类型推导的局限性和解决方案

```typescript
// 局限性1：复杂泛型推导
// 问题：深层嵌套的泛型类型推导不准确
interface ApiResponse<T> {
  data: T
  status: number
  message: string
}

// 不够准确的推导
const useApi = <T>() => {
  const data = ref<T>()
  const loading = ref(false)
  
  const fetch = async (url: string): Promise<ApiResponse<T>> => {
    loading.value = true
    try {
      const response = await window.fetch(url)
      const result = await response.json()
      data.value = result.data // 类型推导可能不准确
      return result
    } finally {
      loading.value = false
    }
  }
  
  return { data, loading, fetch }
}

// 解决方案：显式类型约束
const useTypedApi = <T>() => {
  const data = ref<T | undefined>(undefined)
  const loading = ref(false)
  const error = ref<Error | null>(null)
  
  const fetch = async (url: string): Promise<ApiResponse<T>> => {
    loading.value = true
    error.value = null
    
    try {
      const response = await window.fetch(url)
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`)
      }
      
      const result: ApiResponse<T> = await response.json()
      data.value = result.data // 现在类型安全
      return result
    } catch (err) {
      const errorObj = err instanceof Error ? err : new Error(String(err))
      error.value = errorObj
      throw errorObj
    } finally {
      loading.value = false
    }
  }
  
  return { data: readonly(data), loading: readonly(loading), error: readonly(error), fetch }
}

// 局限性2：模板中的类型推导
// 问题：模板中无法进行复杂的类型检查
const ComplexComponent = defineComponent({
  props: {
    items: {
      type: Array as PropType<Array<{ id: number; name: string; metadata?: any }>>,
      required: true
    }
  },
  setup(props) {
    // 在 setup 中类型推导正常
    const processedItems = computed(() => {
      return props.items.map(item => ({
        ...item,
        displayName: item.name.toUpperCase(), // 类型安全
        hasMetadata: !!item.metadata
      }))
    })
    
    // 但在模板中类型检查有限
    return {
      processedItems
    }
  }
})

// 局限性3：动态组件类型推导
// 问题：动态组件无法获得准确的类型推导
const DynamicWrapper = defineComponent({
  props: {
    component: {
      type: [String, Object] as PropType<string | Component>,
      required: true
    },
    componentProps: {
      type: Object as PropType<Record<string, any>>,
      default: () => ({})
    }
  },
  setup(props) {
    // 无法获得 component 的具体类型信息
    return () => h(props.component, props.componentProps)
  }
})

// 解决方案：类型化的动态组件工厂
interface ComponentMap {
  button: typeof ButtonComponent
  input: typeof InputComponent
  select: typeof SelectComponent
}

type ComponentKey = keyof ComponentMap
type ComponentProps<K extends ComponentKey> = ComponentMap[K] extends 
  DefineComponent<infer P> ? P : never

function createTypedDynamicComponent<K extends ComponentKey>(
  componentKey: K,
  props: ComponentProps<K>
) {
  const componentMap: ComponentMap = {
    button: ButtonComponent,
    input: InputComponent,
    select: SelectComponent
  }
  
  return h(componentMap[componentKey], props)
}

// 局限性4：插槽类型推导
// 问题：插槽内容的类型推导不够精确
interface SlotProps {
  user: User
  index: number
  isSelected: boolean
}

const ListComponent = defineComponent({
  props: {
    users: {
      type: Array as PropType<User[]>,
      required: true
    }
  },
  setup(props, { slots }) {
    return () => (
      <div>
        {props.users.map((user, index) => (
          <div key={user.id}>
            {slots.default?.({
              user,
              index,
              isSelected: false
            } as SlotProps)}
          </div>
        ))}
      </div>
    )
  }
})

// 解决方案：显式的插槽类型定义
interface TypedSlots {
  default: (props: SlotProps) => VNode[]
  header: (props: { total: number }) => VNode[]
  footer: (props: { hasMore: boolean }) => VNode[]
}

const TypedListComponent = defineComponent({
  props: {
    users: {
      type: Array as PropType<User[]>,
      required: true
    }
  },
  setup(props, { slots }: SetupContext<{}, TypedSlots>) {
    return () => (
      <div>
        {slots.header?.({ total: props.users.length })}
        {props.users.map((user, index) => (
          <div key={user.id}>
            {slots.default?.({
              user,
              index,
              isSelected: false
            })}
          </div>
        ))}
        {slots.footer?.({ hasMore: false })}
      </div>
    )
  }
})
```





## Vue 与 TypeScript 结合的高级模式

### 6.1 依赖注入的类型安全

```typescript
// 类型安全的依赖注入系统
interface InjectionKey<T> extends Symbol {}

function createInjectionKey<T>(description: string): InjectionKey<T> {
  return Symbol(description) as InjectionKey<T>
}

// 定义服务接口
interface ApiService {
  get<T>(url: string): Promise<T>
  post<T>(url: string, data: any): Promise<T>
  put<T>(url: string, data: any): Promise<T>
  delete(url: string): Promise<void>
}

interface AuthService {
  login(credentials: LoginCredentials): Promise<User>
  logout(): Promise<void>
  getCurrentUser(): User | null
  isAuthenticated(): boolean
}

interface NotificationService {
  success(message: string): void
  error(message: string): void
  warning(message: string): void
  info(message: string): void
}

// 创建注入键
const API_SERVICE_KEY = createInjectionKey<ApiService>('api-service')
const AUTH_SERVICE_KEY = createInjectionKey<AuthService>('auth-service')
const NOTIFICATION_SERVICE_KEY = createInjectionKey<NotificationService>('notification-service')

// 服务实现
class ApiServiceImpl implements ApiService {
  private baseURL: string
  
  constructor(baseURL: string) {
    this.baseURL = baseURL
  }
  
  async get<T>(url: string): Promise<T> {
    const response = await fetch(`${this.baseURL}${url}`)
    return response.json()
  }
  
  async post<T>(url: string, data: any): Promise<T> {
    const response = await fetch(`${this.baseURL}${url}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data)
    })
    return response.json()
  }
  
  async put<T>(url: string, data: any): Promise<T> {
    const response = await fetch(`${this.baseURL}${url}`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data)
    })
    return response.json()
  }
  
  async delete(url: string): Promise<void> {
    await fetch(`${this.baseURL}${url}`, {
      method: 'DELETE'
    })
  }
}

class AuthServiceImpl implements AuthService {
  private currentUser: User | null = null
  
  async login(credentials: LoginCredentials): Promise<User> {
    // 登录逻辑
    const user = await fetch('/api/login', {
      method: 'POST',
      body: JSON.stringify(credentials)
    }).then(res => res.json())
    
    this.currentUser = user
    return user
  }
  
  async logout(): Promise<void> {
    await fetch('/api/logout', { method: 'POST' })
    this.currentUser = null
  }
  
  getCurrentUser(): User | null {
    return this.currentUser
  }
  
  isAuthenticated(): boolean {
    return this.currentUser !== null
  }
}

// 服务提供者组件
const ServiceProvider = defineComponent({
  name: 'ServiceProvider',
  setup(_, { slots }) {
    // 创建服务实例
    const apiService = new ApiServiceImpl('/api')
    const authService = new AuthServiceImpl()
    const notificationService = {
      success: (msg: string) => console.log('✓', msg),
      error: (msg: string) => console.error('✗', msg),
      warning: (msg: string) => console.warn('⚠', msg),
      info: (msg: string) => console.info('ℹ', msg)
    }
    
    // 提供服务
    provide(API_SERVICE_KEY, apiService)
    provide(AUTH_SERVICE_KEY, authService)
    provide(NOTIFICATION_SERVICE_KEY, notificationService)
    
    return () => slots.default?.()
  }
})

// 类型安全的服务注入 Hook
function useService<T>(key: InjectionKey<T>): T {
  const service = inject(key)
  if (!service) {
    throw new Error(`Service not provided: ${key.toString()}`)
  }
  return service
}

// 可选服务注入
function useOptionalService<T>(key: InjectionKey<T>): T | undefined {
  return inject(key)
}

// 带默认值的服务注入
function useServiceWithDefault<T>(key: InjectionKey<T>, defaultValue: T): T {
  return inject(key, defaultValue)
}

// 在组件中使用服务
const UserProfile = defineComponent({
  setup() {
    const apiService = useService(API_SERVICE_KEY)
    const authService = useService(AUTH_SERVICE_KEY)
    const notificationService = useService(NOTIFICATION_SERVICE_KEY)
    
    const user = ref<User | null>(null)
    const loading = ref(false)
    
    const loadUserProfile = async () => {
      try {
        loading.value = true
        const currentUser = authService.getCurrentUser()
        if (currentUser) {
          user.value = await apiService.get<User>(`/users/${currentUser.id}`)
          notificationService.success('Profile loaded successfully')
        }
      } catch (error) {
        notificationService.error('Failed to load profile')
        console.error(error)
      } finally {
        loading.value = false
      }
    }
    
    const updateProfile = async (updates: Partial<User>) => {
      if (!user.value) return
      
      try {
        const updatedUser = await apiService.put<User>(
          `/users/${user.value.id}`,
          updates
        )
        user.value = updatedUser
        notificationService.success('Profile updated successfully')
      } catch (error) {
        notificationService.error('Failed to update profile')
        console.error(error)
      }
    }
    
    onMounted(loadUserProfile)
    
    return {
      user,
      loading,
      updateProfile,
      loadUserProfile
    }
  }
})
```

### 6.2 插件系统的类型安全

```typescript
// 插件接口定义
interface Plugin<T = any> {
  name: string
  version: string
  install(app: App, options?: T): void
  uninstall?(app: App): void
}

// 插件配置类型
interface PluginConfig<T> {
  plugin: Plugin<T>
  options?: T
  enabled?: boolean
}

// 类型安全的插件管理器
class PluginManager {
  private plugins = new Map<string, Plugin>()
  private installedPlugins = new Set<string>()
  
  register<T>(plugin: Plugin<T>, options?: T): void {
    if (this.plugins.has(plugin.name)) {
      throw new Error(`Plugin ${plugin.name} is already registered`)
    }
    
    this.plugins.set(plugin.name, plugin)
  }
  
  install<T>(app: App, pluginName: string, options?: T): void {
    const plugin = this.plugins.get(pluginName)
    if (!plugin) {
      throw new Error(`Plugin ${pluginName} is not registered`)
    }
    
    if (this.installedPlugins.has(pluginName)) {
      console.warn(`Plugin ${pluginName} is already installed`)
      return
    }
    
    plugin.install(app, options)
    this.installedPlugins.add(pluginName)
  }
  
  uninstall(app: App, pluginName: string): void {
    const plugin = this.plugins.get(pluginName)
    if (!plugin || !this.installedPlugins.has(pluginName)) {
      return
    }
    
    plugin.uninstall?.(app)
    this.installedPlugins.delete(pluginName)
  }
  
  isInstalled(pluginName: string): boolean {
    return this.installedPlugins.has(pluginName)
  }
  
  getInstalledPlugins(): string[] {
    return Array.from(this.installedPlugins)
  }
}

// 具体插件实现
interface ToastOptions {
  duration?: number
  position?: 'top' | 'bottom' | 'center'
  theme?: 'light' | 'dark'
}

const ToastPlugin: Plugin<ToastOptions> = {
  name: 'toast',
  version: '1.0.0',
  install(app, options = {}) {
    const defaultOptions: ToastOptions = {
      duration: 3000,
      position: 'top',
      theme: 'light'
    }
    
    const mergedOptions = { ...defaultOptions, ...options }
    
    const toast = {
      show(message: string, type: 'success' | 'error' | 'warning' | 'info' = 'info') {
        // Toast 实现逻辑
        console.log(`[${type.toUpperCase()}] ${message}`)
      },
      success(message: string) {
        this.show(message, 'success')
      },
      error(message: string) {
        this.show(message, 'error')
      },
      warning(message: string) {
        this.show(message, 'warning')
      },
      info(message: string) {
        this.show(message, 'info')
      }
    }
    
    app.config.globalProperties.$toast = toast
    app.provide('toast', toast)
  }
}

// 验证插件
interface ValidationRule {
  required?: boolean
  minLength?: number
  maxLength?: number
  pattern?: RegExp
  custom?: (value: any) => string | null
}

interface ValidationOptions {
  rules?: Record<string, ValidationRule>
  locale?: string
}

const ValidationPlugin: Plugin<ValidationOptions> = {
  name: 'validation',
  version: '1.0.0',
  install(app, options = {}) {
    const validator = {
      validate(value: any, rules: ValidationRule): string | null {
        if (rules.required && (!value || value === '')) {
          return 'This field is required'
        }
        
        if (rules.minLength && value.length < rules.minLength) {
          return `Minimum length is ${rules.minLength}`
        }
        
        if (rules.maxLength && value.length > rules.maxLength) {
          return `Maximum length is ${rules.maxLength}`
        }
        
        if (rules.pattern && !rules.pattern.test(value)) {
          return 'Invalid format'
        }
        
        if (rules.custom) {
          return rules.custom(value)
        }
        
        return null
      },
      
      validateObject(obj: Record<string, any>, rules: Record<string, ValidationRule>) {
        const errors: Record<string, string> = {}
        
        for (const [field, rule] of Object.entries(rules)) {
          const error = this.validate(obj[field], rule)
          if (error) {
            errors[field] = error
          }
        }
        
        return Object.keys(errors).length > 0 ? errors : null
      }
    }
    
    app.config.globalProperties.$validator = validator
    app.provide('validator', validator)
  }
}

// 插件使用示例
const pluginManager = new PluginManager()

// 注册插件
pluginManager.register(ToastPlugin)
pluginManager.register(ValidationPlugin)

// 在应用中安装插件
const app = createApp(App)

pluginManager.install(app, 'toast', {
  duration: 5000,
  position: 'bottom',
  theme: 'dark'
})

pluginManager.install(app, 'validation', {
  locale: 'zh-CN'
})

// 类型安全的插件使用
const ComponentWithPlugins = defineComponent({
  setup() {
    const toast = inject<typeof ToastPlugin>('toast')
    const validator = inject<typeof ValidationPlugin>('validator')
    
    const handleSubmit = (formData: any) => {
      const errors = validator?.validateObject(formData, {
        name: { required: true, minLength: 2 },
        email: { required: true, pattern: /^[^\s@]+@[^\s@]+\.[^\s@]+$/ }
      })
      
      if (errors) {
        toast?.error('Please fix the validation errors')
      } else {
        toast?.success('Form submitted successfully')
      }
    }
    
    return {
      handleSubmit
    }
  }
})
```

### 6.3 高级类型守卫和运行时类型检查

```typescript
// 类型守卫函数
function isString(value: unknown): value is string {
  return typeof value === 'string'
}

function isNumber(value: unknown): value is number {
  return typeof value === 'number' && !isNaN(value)
}

function isArray<T>(value: unknown, itemGuard: (item: unknown) => item is T): value is T[] {
  return Array.isArray(value) && value.every(itemGuard)
}

function isObject(value: unknown): value is Record<string, unknown> {
  return typeof value === 'object' && value !== null && !Array.isArray(value)
}

// 复杂类型守卫
interface User {
  id: number
  name: string
  email: string
  roles: string[]
  profile?: {
    avatar?: string
    bio?: string
  }
}

function isUser(value: unknown): value is User {
  if (!isObject(value)) return false
  
  const obj = value as Record<string, unknown>
  
  return (
    isNumber(obj.id) &&
    isString(obj.name) &&
    isString(obj.email) &&
    isArray(obj.roles, isString) &&
    (obj.profile === undefined || (
      isObject(obj.profile) &&
      (obj.profile.avatar === undefined || isString(obj.profile.avatar)) &&
      (obj.profile.bio === undefined || isString(obj.profile.bio))
    ))
  )
}

// 运行时类型验证 Composable
function useTypeGuard<T>(guard: (value: unknown) => value is T) {
  const validate = (value: unknown): T => {
    if (guard(value)) {
      return value
    }
    throw new Error('Type validation failed')
  }
  
  const safeValidate = (value: unknown): T | null => {
    return guard(value) ? value : null
  }
  
  const isValid = (value: unknown): boolean => {
    return guard(value)
  }
  
  return {
    validate,
    safeValidate,
    isValid
  }
}

// API 响应类型验证
interface ApiResponse<T> {
  data: T
  status: number
  message: string
}

function createApiResponseGuard<T>(
  dataGuard: (value: unknown) => value is T
) {
  return (value: unknown): value is ApiResponse<T> => {
    if (!isObject(value)) return false
    
    const obj = value as Record<string, unknown>
    
    return (
      dataGuard(obj.data) &&
      isNumber(obj.status) &&
      isString(obj.message)
    )
  }
}

// 使用示例
const UserApiComponent = defineComponent({
  setup() {
    const userGuard = useTypeGuard(isUser)
    const userResponseGuard = useTypeGuard(createApiResponseGuard(isUser))
    
    const users = ref<User[]>([])
    const loading = ref(false)
    const error = ref<string | null>(null)
    
    const fetchUsers = async () => {
      try {
        loading.value = true
        error.value = null
        
        const response = await fetch('/api/users')
        const rawData = await response.json()
        
        // 运行时类型验证
        if (userResponseGuard.isValid(rawData)) {
          const validatedResponse = userResponseGuard.validate(rawData)
          users.value = [validatedResponse.data] // 类型安全
        } else {
          throw new Error('Invalid API response format')
        }
      } catch (err) {
        error.value = err instanceof Error ? err.message : 'Unknown error'
      } finally {
        loading.value = false
      }
    }
    
    const addUser = (userData: unknown) => {
      const validUser = userGuard.safeValidate(userData)
      if (validUser) {
        users.value.push(validUser)
      } else {
        error.value = 'Invalid user data format'
      }
    }
    
    return {
      users,
      loading,
      error,
      fetchUsers,
      addUser
    }
  }
})
```



## 大型 Vue+TypeScript 项目的类型组织与管理策略

### 7.1 项目结构和类型组织

```typescript
// types/api.ts - API 相关类型
export interface ApiResponse<T = any> {
  data: T
  status: number
  message: string
  timestamp: string
}

export interface PaginatedResponse<T> extends ApiResponse<T[]> {
  pagination: {
    page: number
    limit: number
    total: number
    hasNext: boolean
    hasPrev: boolean
  }
}

export interface ApiError {
  code: string
  message: string
  details?: Record<string, any>
}

// types/user.ts - 用户相关类型
export interface User {
  id: number
  username: string
  email: string
  firstName: string
  lastName: string
  avatar?: string
  roles: Role[]
  createdAt: string
  updatedAt: string
}

export interface CreateUserRequest {
  username: string
  email: string
  firstName: string
  lastName: string
  password: string
  roleIds: number[]
}

export interface UpdateUserRequest extends Partial<Omit<CreateUserRequest, 'password'>> {
  currentPassword?: string
  newPassword?: string
}

export interface UserProfile extends Omit<User, 'roles'> {
  bio?: string
  location?: string
  website?: string
  socialLinks?: {
    twitter?: string
    github?: string
    linkedin?: string
  }
}

// types/auth.ts - 认证相关类型
export interface LoginCredentials {
  email: string
  password: string
  rememberMe?: boolean
}

export interface AuthTokens {
  accessToken: string
  refreshToken: string
  expiresIn: number
}

export interface AuthUser extends User {
  permissions: Permission[]
}

// types/common.ts - 通用类型
export type ID = string | number

export interface BaseEntity {
  id: ID
  createdAt: string
  updatedAt: string
}

export interface SelectOption<T = any> {
  label: string
  value: T
  disabled?: boolean
  group?: string
}

export type SortDirection = 'asc' | 'desc'

export interface SortConfig<T = string> {
  field: T
  direction: SortDirection
}

export interface FilterConfig<T = any> {
  field: string
  operator: 'eq' | 'ne' | 'gt' | 'gte' | 'lt' | 'lte' | 'like' | 'in' | 'not_in'
  value: T
}

// types/components.ts - 组件相关类型
export interface TableColumn<T = any> {
  key: keyof T | string
  title: string
  width?: number
  sortable?: boolean
  filterable?: boolean
  render?: (value: any, record: T, index: number) => VNode | string
}

export interface FormField<T = any> {
  name: keyof T
  label: string
  type: 'text' | 'email' | 'password' | 'number' | 'select' | 'textarea' | 'checkbox'
  required?: boolean
  rules?: ValidationRule[]
  options?: SelectOption[]
  placeholder?: string
  disabled?: boolean
}

export interface ModalConfig {
  title: string
  width?: number | string
  maskClosable?: boolean
  destroyOnClose?: boolean
  footer?: boolean
}
```

### 7.2 类型生成和代码生成

```typescript
// scripts/generate-types.ts - 从 API Schema 生成类型
import { writeFileSync } from 'fs'
import { resolve } from 'path'

interface ApiSchema {
  paths: Record<string, {
    get?: ApiEndpoint
    post?: ApiEndpoint
    put?: ApiEndpoint
    delete?: ApiEndpoint
  }>
  components: {
    schemas: Record<string, SchemaDefinition>
  }
}

interface ApiEndpoint {
  summary: string
  parameters?: Parameter[]
  requestBody?: RequestBody
  responses: Record<string, Response>
}

interface SchemaDefinition {
  type: string
  properties?: Record<string, PropertyDefinition>
  required?: string[]
}

interface PropertyDefinition {
  type: string
  format?: string
  items?: PropertyDefinition
  $ref?: string
}

class TypeGenerator {
  private schema: ApiSchema
  
  constructor(schema: ApiSchema) {
    this.schema = schema
  }
  
  generateTypes(): string {
    let output = '// Auto-generated types from API schema\n\n'
    
    // 生成基础接口
    for (const [name, definition] of Object.entries(this.schema.components.schemas)) {
      output += this.generateInterface(name, definition)
      output += '\n\n'
    }
    
    // 生成 API 类型
    output += this.generateApiTypes()
    
    return output
  }
  
  private generateInterface(name: string, definition: SchemaDefinition): string {
    let interfaceStr = `export interface ${this.capitalize(name)} {\n`
    
    if (definition.properties) {
      for (const [propName, propDef] of Object.entries(definition.properties)) {
        const isRequired = definition.required?.includes(propName) ?? false
        const propType = this.getTypeFromDefinition(propDef)
        const optional = isRequired ? '' : '?'
        
        interfaceStr += `  ${propName}${optional}: ${propType}\n`
      }
    }
    
    interfaceStr += '}'
    return interfaceStr
  }
  
  private getTypeFromDefinition(def: PropertyDefinition): string {
    switch (def.type) {
      case 'string':
        return 'string'
      case 'number':
      case 'integer':
        return 'number'
      case 'boolean':
        return 'boolean'
      case 'array':
        if (def.items) {
          return `${this.getTypeFromDefinition(def.items)}[]`
        }
        return 'any[]'
      case 'object':
        return 'Record<string, any>'
      default:
        if (def.$ref) {
          const refName = def.$ref.split('/').pop()
          return this.capitalize(refName || 'any')
        }
        return 'any'
    }
  }
  
  private generateApiTypes(): string {
    let apiTypes = '// API endpoint types\n'
    
    for (const [path, methods] of Object.entries(this.schema.paths)) {
      const pathName = this.pathToTypeName(path)
      
      for (const [method, endpoint] of Object.entries(methods)) {
        if (endpoint) {
          apiTypes += this.generateEndpointTypes(pathName, method, endpoint)
        }
      }
    }
    
    return apiTypes
  }
  
  private generateEndpointTypes(pathName: string, method: string, endpoint: ApiEndpoint): string {
    const typeName = `${this.capitalize(method)}${pathName}`
    let types = ''
    
    // Request type
    if (endpoint.requestBody) {
      types += `export interface ${typeName}Request {\n`
      // Generate request body type
      types += '  // TODO: Generate from request body schema\n'
      types += '}\n\n'
    }
    
    // Response type
    types += `export interface ${typeName}Response {\n`
    // Generate response type
    types += '  // TODO: Generate from response schema\n'
    types += '}\n\n'
    
    return types
  }
  
  private pathToTypeName(path: string): string {
    return path
      .split('/')
      .filter(segment => segment && !segment.startsWith('{'))
      .map(segment => this.capitalize(segment))
      .join('')
  }
  
  private capitalize(str: string): string {
    return str.charAt(0).toUpperCase() + str.slice(1)
  }
}

// 使用示例
async function generateApiTypes() {
  try {
    const response = await fetch('http://localhost:3000/api/schema')
    const schema: ApiSchema = await response.json()
    
    const generator = new TypeGenerator(schema)
    const types = generator.generateTypes()
    
    writeFileSync(
      resolve(__dirname, '../src/types/generated.ts'),
      types,
      'utf-8'
    )
    
    console.log('Types generated successfully!')
  } catch (error) {
    console.error('Failed to generate types:', error)
  }
}
```

