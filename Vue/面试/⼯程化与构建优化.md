# â¼¯ç¨‹åŒ–ä¸æ„å»ºä¼˜åŒ–

 

## Vite åœ¨ Vue é¡¹ç›®ä¸­çš„åº”ç”¨åŠåŸç†åˆ†æã€‘

### Vite æ ¸å¿ƒåŸç†

**åŸºäº ESM çš„å¼€å‘æ¨¡å¼**

- åˆ©ç”¨æµè§ˆå™¨åŸç”Ÿ ES æ¨¡å—æ”¯æŒ
- æŒ‰éœ€ç¼–è¯‘ï¼Œåªå¤„ç†å½“å‰è®¿é—®çš„æ¨¡å—
- çƒ­æ›´æ–°é€Ÿåº¦æå¿«ï¼Œæ¯«ç§’çº§å“åº”

**åŒå¼•æ“æ¶æ„**

```javascript
// vite.config.js - Vue é¡¹ç›®é…ç½®
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'

export default defineConfig({
  plugins: [vue()],
  // å¼€å‘æœåŠ¡å™¨é…ç½®
  server: {
    port: 3000,
    hmr: true
  },
  // æ„å»ºé…ç½®
  build: {
    target: 'es2015',
    rollupOptions: {
      output: {
        chunkFileNames: 'js/[name]-[hash].js',
        entryFileNames: 'js/[name]-[hash].js',
        assetFileNames: 'assets/[name]-[hash].[ext]'
      }
    }
  }
})
```

![image-20250526152101342](C:/Users/27019/AppData/Roaming/Typora/typora-user-images/image-20250526152101342.png)

**æ„å»ºæ€§èƒ½å¯¹æ¯”**

```javascript
// Webpack é…ç½®ç¤ºä¾‹
module.exports = {
  entry: './src/main.js',
  module: {
    rules: [
      {
        test: /\.vue$/,
        loader: 'vue-loader'
      },
      {
        test: /\.js$/,
        loader: 'babel-loader',
        exclude: /node_modules/
      }
    ]
  },
  plugins: [
    new VueLoaderPlugin(),
    new HtmlWebpackPlugin()
  ]
}

// Vite ç­‰æ•ˆé…ç½®
export default defineConfig({
  plugins: [vue()]
  // å¤§éƒ¨åˆ†é…ç½®å¼€ç®±å³ç”¨
})
```



## Vue é¡¹ç›®æ„å»ºé€Ÿåº¦å’Œäº§ç‰©ä½“ç§¯ä¼˜åŒ–

### æ„å»ºé€Ÿåº¦ä¼˜åŒ–ç­–ç•¥

**ä¾èµ–é¢„æ„å»ºä¼˜åŒ–**

```javascript
// vite.config.js
export default defineConfig({
  optimizeDeps: {
    include: ['vue', 'vue-router', 'axios'],
    exclude: ['your-es-lib']
  },
  server: {
    warmup: {
      clientFiles: ['./src/components/*.vue']
    }
  }
})
```



**å¹¶è¡Œæ„å»ºé…ç½®**

```javascript
// å¤šçº¿ç¨‹æ„å»º
export default defineConfig({
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          vendor: ['vue', 'vue-router'],
          ui: ['element-plus', 'ant-design-vue']
        }
      }
    },
    terserOptions: {
      parallel: true
    }
  }
})
```



### äº§ç‰©ä½“ç§¯ä¼˜åŒ–

**Tree Shaking é…ç½®**

```javascript
// ç¡®ä¿ Tree Shaking ç”Ÿæ•ˆ
export default defineConfig({
  build: {
    rollupOptions: {
      external: ['vue'],
      output: {
        globals: {
          vue: 'Vue'
        }
      }
    }
  },
  esbuild: {
    drop: ['console', 'debugger']
  }
```



**æŒ‰éœ€å¯¼å…¥é…ç½®**

```javascript
// è‡ªåŠ¨å¯¼å…¥æ’ä»¶
import AutoImport from 'unplugin-auto-import/vite'
import Components from 'unplugin-vue-components/vite'

export default defineConfig({
  plugins: [
    AutoImport({
      imports: ['vue', 'vue-router'],
      dts: true
    }),
    Components({
      dts: true
    })
  ]
})
```



**èµ„æºå‹ç¼©ä¼˜åŒ–**

```javascript
import { defineConfig } from 'vite'
import legacy from '@vitejs/plugin-legacy'
import { visualizer } from 'rollup-plugin-visualizer'

export default defineConfig({
  plugins: [
    legacy({
      targets: ['defaults', 'not IE 11']
    }),
    visualizer({
      filename: 'dist/stats.html',
      open: true
    })
  ],
  build: {
    minify: 'terser',
    terserOptions: {
      compress: {
        drop_console: true,
        drop_debugger: true
      }
    }
  }
})
```



## æ¨¡å—è”é‚¦åœ¨ Vue é¡¹ç›®ä¸­çš„åº”ç”¨

### Module Federation åŸºç¡€é…ç½®

**ä¸»åº”ç”¨é…ç½®**

```javascript
// host/vite.config.js
import { defineConfig } from 'vite'
import federation from '@originjs/vite-plugin-federation'

export default defineConfig({
  plugins: [
    federation({
      name: 'host-app',
      remotes: {
        remote1: 'http://localhost:5001/assets/remoteEntry.js',
        remote2: 'http://localhost:5002/assets/remoteEntry.js'
      },
      shared: ['vue', 'vue-router']
    })
  ]
})
```



**è¿œç¨‹åº”ç”¨é…ç½®**

```javascript
// remote/vite.config.js
export default defineConfig({
  plugins: [
    federation({
      name: 'remote-app',
      filename: 'remoteEntry.js',
      exposes: {
        './Button': './src/components/Button.vue',
        './UserModule': './src/modules/User/index.js'
      },
      shared: ['vue', 'vue-router']
    })
  ]
})
```



### å¾®å‰ç«¯æ¶æ„å®ç°

**åŠ¨æ€è¿œç¨‹ç»„ä»¶åŠ è½½**

```vue
<!-- ä¸»åº”ç”¨ä¸­ä½¿ç”¨è¿œç¨‹ç»„ä»¶ -->
<template>
  <div>
    <Suspense>
      <template #default>
        <RemoteButton />
      </template>
      <template #fallback>
        <div>Loading...</div>
      </template>
    </Suspense>
  </div>
</template>

<script setup>
import { defineAsyncComponent } from 'vue'

const RemoteButton = defineAsyncComponent(() =>
  import('remote1/Button')
)
</script>
```

**è·¯ç”±çº§åˆ«çš„æ¨¡å—è”é‚¦**

```javascript
// è·¯ç”±é…ç½®
import { createRouter } from 'vue-router'

const routes = [
  {
    path: '/user',
    component: () => import('remote1/UserModule')
  },
  {
    path: '/product',
    component: () => import('remote2/ProductModule')
  }
]

export default createRouter({
  routes
})
```



## Vue åº“çš„æŒ‰éœ€åŠ è½½è®¾è®¡ä¸å®ç°



### ç»„ä»¶åº“æŒ‰éœ€å¯¼å…¥

**Babel æ’ä»¶é…ç½®**

```javascript
// babel.config.js
module.exports = {
  plugins: [
    ['import', {
      libraryName: 'element-plus',
      customStyleName: (name) => {
        return `element-plus/lib/theme-chalk/${name}.css`
      }
    }]
  ]
}
```

**è‡ªå®šä¹‰æŒ‰éœ€åŠ è½½æ’ä»¶**

```javascript
// plugins/auto-import.js
function createAutoImportPlugin() {
  return {
    name: 'auto-import',
    resolveId(id) {
      if (id.startsWith('my-ui/')) {
        return id
      }
    },
    load(id) {
      if (id.startsWith('my-ui/')) {
        const componentName = id.split('/')[1]
        return `
          import Component from '../components/${componentName}/index.vue'
          import '../components/${componentName}/style.css'
          export default Component
        `
      }
    }
  }
}
```

### å·¥å…·å‡½æ•°æ ‘æ‘‡ä¼˜åŒ–

```javascript
// utils/index.js - æ”¯æŒ Tree Shaking
export const formatDate = (date) => {
  // æ ¼å¼åŒ–æ—¥æœŸé€»è¾‘
}

export const debounce = (fn, delay) => {
  // é˜²æŠ–é€»è¾‘
}

// ç¡®ä¿æ¯ä¸ªå·¥å…·å‡½æ•°ç‹¬ç«‹å¯¼å‡º
// é¿å…ä½¿ç”¨ export default { formatDate, debounce }
```



## Vue é¡¹ç›®çš„æ„å»ºæµæ°´çº¿è®¾è®¡ä¸ CI/CD å®è·µ



### GitHub Actions é…ç½®

```yaml
# .github/workflows/deploy.yml
name: Build and Deploy

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'npm'
    
    - name: Install dependencies
      run: npm ci
    
    - name: Run tests
      run: npm run test:unit
    
    - name: Build project
      run: npm run build
      env:
        NODE_ENV: production
    
    - name: Deploy to OSS
      run: |
        npm install -g ossutil
        ossutil cp -r dist/ oss://your-bucket/
```

### Docker å®¹å™¨åŒ–æ„å»º

```dockerfile
# Dockerfile
FROM node:18-alpine as builder

WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production

COPY . .
RUN npm run build

FROM nginx:alpine
COPY --from=builder /app/dist /usr/share/nginx/html
COPY nginx.conf /etc/nginx/nginx.conf

EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

### å¤šç¯å¢ƒæ„å»ºé…ç½®

```javascript
// scripts/build.js
const { execSync } = require('child_process')
const path = require('path')

const environments = {
  dev: {
    API_BASE_URL: 'https://dev-api.example.com',
    CDN_URL: 'https://dev-cdn.example.com'
  },
  staging: {
    API_BASE_URL: 'https://staging-api.example.com',
    CDN_URL: 'https://staging-cdn.example.com'
  },
  prod: {
    API_BASE_URL: 'https://api.example.com',
    CDN_URL: 'https://cdn.example.com'
  }
}

const env = process.argv[2] || 'dev'
const config = environments[env]

// è®¾ç½®ç¯å¢ƒå˜é‡å¹¶æ„å»º
Object.keys(config).forEach(key => {
  process.env[key] = config[key]
})

execSync('vite build', { stdio: 'inherit' })
```





## Vue SFC çš„æ„å»ºæµç¨‹åŠè‡ªå®šä¹‰å—å¤„ç†

### SFC ç¼–è¯‘æµç¨‹åˆ†æ

**ç¼–è¯‘æ­¥éª¤è¯¦è§£**

```javascript
// SFC ç¼–è¯‘æµç¨‹
const { parse, compileTemplate, compileScript, compileStyle } = require('@vue/compiler-sfc')

function compileSFC(source, filename) {
  // 1. è§£æ SFC
  const { descriptor } = parse(source, { filename })
  
  // 2. ç¼–è¯‘ script
  const scriptResult = compileScript(descriptor, {
    id: 'vue-component'
  })
  
  // 3. ç¼–è¯‘ template
  const templateResult = compileTemplate({
    source: descriptor.template.content,
    filename
  })
  
  // 4. ç¼–è¯‘ style
  const styleResults = descriptor.styles.map(style =>
    compileStyle({
      source: style.content,
      scoped: style.scoped
    })
  )
  
  return {
    script: scriptResult.content,
    template: templateResult.code,
    styles: styleResults.map(s => s.code)
  }
}
```



### è‡ªå®šä¹‰å—å¤„ç†

**è‡ªå®šä¹‰å—å®šä¹‰**

```vue
<template>
  <div>{{ message }}</div>
</template>

<script setup>
import { ref } from 'vue'
const message = ref('Hello')
</script>

<docs>
è¿™æ˜¯ä¸€ä¸ªç¤ºä¾‹ç»„ä»¶
ç”¨äºå±•ç¤ºè‡ªå®šä¹‰å—çš„ä½¿ç”¨
</docs>

<i18n>
{
  "en": {
    "hello": "Hello"
  },
  "zh": {
    "hello": "ä½ å¥½"
  }
}
</i18n>
```

**è‡ªå®šä¹‰å—å¤„ç†å™¨**

```javascript
// vite-plugin-custom-block.js
export function customBlockPlugin() {
  return {
    name: 'custom-block',
    transform(code, id) {
      if (!id.includes('.vue')) return
      
      const { parse } = require('@vue/compiler-sfc')
      const { descriptor } = parse(code)
      
      // å¤„ç† docs å—
      if (descriptor.customBlocks.find(b => b.type === 'docs')) {
        const docsBlock = descriptor.customBlocks.find(b => b.type === 'docs')
        // ç”Ÿæˆæ–‡æ¡£æˆ–æ³¨å…¥å…ƒæ•°æ®
        console.log('Component docs:', docsBlock.content)
      }
      
      // å¤„ç† i18n å—
      if (descriptor.customBlocks.find(b => b.type === 'i18n')) {
        const i18nBlock = descriptor.customBlocks.find(b => b.type === 'i18n')
        const i18nData = JSON.parse(i18nBlock.content)
        
        // æ³¨å…¥åˆ°ç»„ä»¶ä¸­
        code += `
          export const __i18n = ${JSON.stringify(i18nData)}
        `
      }
      
      return code
    }
  }
}
```



## å¤§å‹ Vue é¡¹ç›®çš„åˆ†åŒ…ç­–ç•¥ä¸ç¼“å­˜ä¼˜åŒ–

### æ™ºèƒ½åˆ†åŒ…ç­–ç•¥

**åŸºäºè·¯ç”±çš„åˆ†åŒ…**

```javascript
// vite.config.js
export default defineConfig({
  build: {
    rollupOptions: {
      output: {
        manualChunks: (id) => {
          // ç¬¬ä¸‰æ–¹åº“åˆ†åŒ…
          if (id.includes('node_modules')) {
            if (id.includes('vue')) {
              return 'vue-vendor'
            }
            if (id.includes('element-plus')) {
              return 'ui-vendor'
            }
            if (id.includes('axios') || id.includes('lodash')) {
              return 'utils-vendor'
            }
            return 'vendor'
          }
          
          // æŒ‰é¡µé¢æ¨¡å—åˆ†åŒ…
          if (id.includes('/src/views/user/')) {
            return 'user-module'
          }
          if (id.includes('/src/views/product/')) {
            return 'product-module'
          }
          if (id.includes('/src/views/order/')) {
            return 'order-module'
          }
        }
      }
    }
  }
})
```



**åŠ¨æ€å¯¼å…¥ä¼˜åŒ–**

```javascript
// router/index.js
const routes = [
  {
    path: '/user',
    component: () => import(
      /* webpackChunkName: "user" */
      '../views/User/index.vue'
    )
  },
  {
    path: '/product',
    component: () => import(
      /* webpackChunkName: "product" */
      '../views/Product/index.vue'
    )
  }
]
```



### ç¼“å­˜ä¼˜åŒ–ç­–ç•¥

**HTTP ç¼“å­˜é…ç½®**

```nginx
# nginx.conf
location ~* \.(js|css)$ {
    expires 1y;
    add_header Cache-Control "public, immutable";
}

location ~* \.(html)$ {
    expires -1;
    add_header Cache-Control "no-cache, no-store, must-revalidate";
}
```



**Service Worker ç¼“å­˜**

```javascript
// sw.js
const CACHE_NAME = 'vue-app-v1'
const urlsToCache = [
  '/',
  '/js/app.js',
  '/css/app.css'
]

self.addEventListener('install', event => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then(cache => cache.addAll(urlsToCache))
  )
})

self.addEventListener('fetch', event => {
  event.respondWith(
    caches.match(event.request)
      .then(response => {
        if (response) {
          return response
        }
        return fetch(event.request)
      })
  )
})
```



**æ„å»ºæ—¶æ–‡ä»¶æŒ‡çº¹**

```javascript
// ç¡®ä¿æ–‡ä»¶å†…å®¹å˜åŒ–æ—¶æ–‡ä»¶åå˜åŒ–
export default defineConfig({
  build: {
    rollupOptions: {
      output: {
        entryFileNames: 'js/[name].[hash].js',
        chunkFileNames: 'js/[name].[hash].js',
        assetFileNames: 'assets/[name].[hash].[ext]'
      }
    }
  }
})
```



### æ€§èƒ½ç›‘æ§ä¸åˆ†æ

**Bundle åˆ†æ**

```javascript
import { defineConfig } from 'vite'
import { Bundle } from 'rollup-plugin-analyzer'

export default defineConfig({
  plugins: [
    Bundle({
      summaryOnly: true,
      limit: 10
    })
  ]
})
```

**è¿è¡Œæ—¶æ€§èƒ½ç›‘æ§**

```javascript
// performance.js
export function trackPerformance() {
  // é¦–å±åŠ è½½æ—¶é—´
  window.addEventListener('load', () => {
    const loadTime = performance.timing.loadEventEnd - performance.timing.navigationStart
    console.log('Page load time:', loadTime)
  })
  
  // è·¯ç”±åˆ‡æ¢æ€§èƒ½
  router.beforeEach((to, from, next) => {
    window.routeStartTime = performance.now()
    next()
  })
  
  router.afterEach(() => {
    const routeTime = performance.now() - window.routeStartTime
    console.log('Route change time:', routeTime)
  })
}
```



# Vueé¡¹ç›®å·¥ç¨‹åŒ–å®è·µ

## Vue é¡¹ç›®çš„ä»£ç è§„èŒƒä¸è´¨é‡ä¿è¯ä½“ç³»

### ä»£ç è§„èŒƒé…ç½®

**ESLint é…ç½®**

```javascript
// .eslintrc.js
module.exports = {
  root: true,
  env: {
    node: true,
    browser: true,
    es2021: true
  },
  extends: [
    'plugin:vue/vue3-essential',
    '@vue/eslint-config-typescript',
    '@vue/eslint-config-prettier',
    'plugin:@typescript-eslint/recommended'
  ],
  parserOptions: {
    ecmaVersion: 2021,
    parser: '@typescript-eslint/parser',
    sourceType: 'module'
  },
  rules: {
    // Vue ç›¸å…³è§„åˆ™
    'vue/multi-word-component-names': 'error',
    'vue/component-definition-name-casing': ['error', 'PascalCase'],
    'vue/component-name-in-template-casing': ['error', 'kebab-case'],
    'vue/prop-name-casing': ['error', 'camelCase'],
    'vue/no-unused-vars': 'error',
    
    // TypeScript è§„åˆ™
    '@typescript-eslint/no-unused-vars': 'error',
    '@typescript-eslint/explicit-function-return-type': 'warn',
    '@typescript-eslint/no-explicit-any': 'warn',
    
    // é€šç”¨è§„åˆ™
    'no-console': process.env.NODE_ENV === 'production' ? 'warn' : 'off',
    'no-debugger': process.env.NODE_ENV === 'production' ? 'warn' : 'off',
    'prefer-const': 'error',
    'no-var': 'error'
  }
}
```

**Prettier é…ç½®**

```json
// .prettierrc
{
  "semi": false,
  "singleQuote": true,
  "trailingComma": "none",
  "printWidth": 100,
  "tabWidth": 2,
  "useTabs": false,
  "bracketSpacing": true,
  "arrowParens": "avoid",
  "vueIndentScriptAndStyle": true
}
```

**StyleLint é…ç½®**

```javascript
// .stylelintrc.js
module.exports = {
  extends: [
    'stylelint-config-standard',
    'stylelint-config-recommended-vue'
  ],
  rules: {
    'selector-pseudo-element-no-unknown': [
      true,
      {
        ignorePseudoElements: ['v-deep', 'v-global', 'v-slotted']
      }
    ],
    'at-rule-no-unknown': [
      true,
      {
        ignoreAtRules: ['tailwind', 'apply', 'variants', 'responsive', 'screen']
      }
    ]
  }
}
```

### Git Hooks é…ç½®

**Husky + lint-staged**

```json
// package.json
{
  "husky": {
    "hooks": {
      "pre-commit": "lint-staged",
      "commit-msg": "commitlint -E HUSKY_GIT_PARAMS"
    }
  },
  "lint-staged": {
    "*.{js,ts,vue}": [
      "eslint --fix",
      "prettier --write"
    ],
    "*.{css,scss,vue}": [
      "stylelint --fix"
    ],
    "*.{json,md}": [
      "prettier --write"
    ]
  }
}
```

**Commitlint é…ç½®**

```javascript
// commitlint.config.js
module.exports = {
  extends: ['@commitlint/config-conventional'],
  rules: {
    'type-enum': [
      2,
      'always',
      [
        'feat',     // æ–°åŠŸèƒ½
        'fix',      // ä¿®å¤bug
        'docs',     // æ–‡æ¡£æ›´æ–°
        'style',    // æ ·å¼ä¿®æ”¹
        'refactor', // é‡æ„
        'perf',     // æ€§èƒ½ä¼˜åŒ–
        'test',     // æµ‹è¯•ç›¸å…³
        'chore',    // æ„å»ºè¿‡ç¨‹æˆ–è¾…åŠ©å·¥å…·çš„å˜åŠ¨
        'revert'    // å›é€€
      ]
    ],
    'subject-case': [0]
  }
}
```

### ä»£ç è´¨é‡æ£€æµ‹

**SonarQube é›†æˆ**

```yaml
# sonar-project.properties
sonar.projectKey=vue-project
sonar.projectName=Vue Project
sonar.projectVersion=1.0

sonar.sources=src
sonar.tests=tests
sonar.test.inclusions=**/*.spec.ts,**/*.test.ts
sonar.typescript.lcov.reportPaths=coverage/lcov.info

sonar.exclusions=**/node_modules/**,**/dist/**,**/*.d.ts
```



##  Vue é¡¹ç›®çš„è‡ªåŠ¨åŒ–æµ‹è¯•ç­–ç•¥



### å•å…ƒæµ‹è¯•é…ç½®

**Vitest é…ç½®**

```javascript
// vitest.config.ts
import { defineConfig } from 'vitest/config'
import vue from '@vitejs/plugin-vue'

export default defineConfig({
  plugins: [vue()],
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: ['./tests/setup.ts'],
    coverage: {
      reporter: ['text', 'json', 'html'],
      exclude: [
        'node_modules/',
        'tests/',
        '**/*.d.ts',
        '**/*.config.*'
      ]
    }
  }
})
```

**å•å…ƒæµ‹è¯•ç¤ºä¾‹**

```typescript
// tests/unit/Button.spec.ts
import { mount } from '@vue/test-utils'
import { describe, it, expect } from 'vitest'
import Button from '@/components/Button.vue'

describe('Button Component', () => {
  it('renders correctly with default props', () => {
    const wrapper = mount(Button, {
      props: {
        type: 'primary'
      },
      slots: {
        default: 'Click me'
      }
    })
    
    expect(wrapper.text()).toBe('Click me')
    expect(wrapper.classes()).toContain('btn-primary')
  })
  
  it('emits click event when clicked', async () => {
    const wrapper = mount(Button)
    await wrapper.trigger('click')
    
    expect(wrapper.emitted()).toHaveProperty('click')
    expect(wrapper.emitted('click')).toHaveLength(1)
  })
  
  it('is disabled when loading', () => {
    const wrapper = mount(Button, {
      props: {
        loading: true
      }
    })
    
    expect(wrapper.element.disabled).toBe(true)
    expect(wrapper.find('.loading-icon').exists()).toBe(true)
  })
})
```

### ç»„ä»¶æµ‹è¯•

**å¤æ‚ç»„ä»¶æµ‹è¯•**

```typescript
// tests/components/UserForm.spec.ts
import { mount } from '@vue/test-utils'
import { createPinia, setActivePinia } from 'pinia'
import UserForm from '@/components/UserForm.vue'
import { useUserStore } from '@/stores/user'

describe('UserForm Component', () => {
  beforeEach(() => {
    setActivePinia(createPinia())
  })
  
  it('validates form inputs correctly', async () => {
    const wrapper = mount(UserForm)
    const userStore = useUserStore()
    
    // æµ‹è¯•è¡¨å•éªŒè¯
    await wrapper.find('#email').setValue('invalid-email')
    await wrapper.find('form').trigger('submit')
    
    expect(wrapper.find('.error-message').text()).toContain('Invalid email')
    expect(userStore.createUser).not.toHaveBeenCalled()
  })
  
  it('submits form with valid data', async () => {
    const wrapper = mount(UserForm)
    const userStore = useUserStore()
    
    // Mock store method
    vi.spyOn(userStore, 'createUser').mockResolvedValue({ id: 1 })
    
    await wrapper.find('#name').setValue('John Doe')
    await wrapper.find('#email').setValue('john@example.com')
    await wrapper.find('form').trigger('submit')
    
    expect(userStore.createUser).toHaveBeenCalledWith({
      name: 'John Doe',
      email: 'john@example.com'
    })
  })
})
```

### E2E æµ‹è¯•

**Playwright é…ç½®**

```javascript
// playwright.config.js
import { defineConfig } from '@playwright/test'

export default defineConfig({
  testDir: './tests/e2e',
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,
  reporter: 'html',
  use: {
    baseURL: 'http://localhost:3000',
    trace: 'on-first-retry',
    screenshot: 'only-on-failure'
  },
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] }
    },
    {
      name: 'firefox',
      use: { ...devices['Desktop Firefox'] }
    },
    {
      name: 'webkit',
      use: { ...devices['Desktop Safari'] }
    }
  ],
  webServer: {
    command: 'npm run dev',
    url: 'http://localhost:3000',
    reuseExistingServer: !process.env.CI
  }
})
```

**E2E æµ‹è¯•ç¤ºä¾‹**

```javascript
// tests/e2e/user-workflow.spec.js
import { test, expect } from '@playwright/test'

test.describe('User Workflow', () => {
  test('user can register and login', async ({ page }) => {
    // æ³¨å†Œæµç¨‹
    await page.goto('/register')
    await page.fill('[data-testid="username"]', 'testuser')
    await page.fill('[data-testid="email"]', 'test@example.com')
    await page.fill('[data-testid="password"]', 'password123')
    await page.click('[data-testid="register-btn"]')
    
    // éªŒè¯æ³¨å†ŒæˆåŠŸ
    await expect(page.locator('.success-message')).toBeVisible()
    
    // ç™»å½•æµç¨‹
    await page.goto('/login')
    await page.fill('[data-testid="email"]', 'test@example.com')
    await page.fill('[data-testid="password"]', 'password123')
    await page.click('[data-testid="login-btn"]')
    
    // éªŒè¯ç™»å½•æˆåŠŸ
    await expect(page.locator('[data-testid="user-menu"]')).toBeVisible()
  })
  
  test('user can create and edit profile', async ({ page }) => {
    // é¢„è®¾ç™»å½•çŠ¶æ€
    await page.goto('/login')
    // ... ç™»å½•é€»è¾‘
    
    // åˆ›å»ºä¸ªäººèµ„æ–™
    await page.goto('/profile/edit')
    await page.fill('#bio', 'This is my bio')
    await page.selectOption('#country', 'US')
    await page.click('button[type="submit"]')
    
    // éªŒè¯ä¿å­˜æˆåŠŸ
    await expect(page.locator('.profile-bio')).toContainText('This is my bio')
  })
})
```



## Vue ç»„ä»¶çš„æ–‡æ¡£ç”Ÿæˆä¸ç¤ºä¾‹å±•ç¤ºç³»ç»Ÿ

### Storybook é…ç½®

**Storybook ä¸»é…ç½®**

```javascript
// .storybook/main.js
module.exports = {
  stories: ['../src/**/*.stories.@(js|jsx|ts|tsx|mdx)'],
  addons: [
    '@storybook/addon-essentials',
    '@storybook/addon-docs',
    '@storybook/addon-controls',
    '@storybook/addon-viewport',
    '@storybook/addon-a11y'
  ],
  framework: '@storybook/vue3',
  features: {
    buildStoriesJson: true
  },
  viteFinal: async (config) => {
    config.plugins = config.plugins || []
    config.plugins.push(
      require('@vitejs/plugin-vue')()
    )
    return config
  }
}
```

**ç»„ä»¶ Story ç¤ºä¾‹**

```javascript
// src/components/Button/Button.stories.js
import Button from './Button.vue'

export default {
  title: 'Components/Button',
  component: Button,
  argTypes: {
    type: {
      control: { type: 'select' },
      options: ['primary', 'secondary', 'danger', 'ghost']
    },
    size: {
      control: { type: 'select' },
      options: ['small', 'medium', 'large']
    },
    disabled: {
      control: { type: 'boolean' }
    },
    loading: {
      control: { type: 'boolean' }
    }
  }
}

const Template = (args) => ({
  components: { Button },
  setup() {
    return { args }
  },
  template: '<Button v-bind="args">{{ args.default }}</Button>'
})

export const Primary = Template.bind({})
Primary.args = {
  type: 'primary',
  default: 'Primary Button'
}

export const Secondary = Template.bind({})
Secondary.args = {
  type: 'secondary',
  default: 'Secondary Button'
}

export const Loading = Template.bind({})
Loading.args = {
  type: 'primary',
  loading: true,
  default: 'Loading...'
}

export const AllSizes = () => ({
  components: { Button },
  template: `
    <div class="flex gap-4">
      <Button size="small">Small</Button>
      <Button size="medium">Medium</Button>
      <Button size="large">Large</Button>
    </div>
  `
})
```

### VitePress æ–‡æ¡£ç³»ç»Ÿ

**VitePress é…ç½®**

```javascript
// docs/.vitepress/config.js
import { defineConfig } from 'vitepress'

export default defineConfig({
  title: 'Vue Component Library',
  description: 'A comprehensive Vue 3 component library',
  themeConfig: {
    nav: [
      { text: 'Guide', link: '/guide/' },
      { text: 'Components', link: '/components/' },
      { text: 'API', link: '/api/' }
    ],
    sidebar: {
      '/guide/': [
        {
          text: 'Getting Started',
          items: [
            { text: 'Installation', link: '/guide/installation' },
            { text: 'Quick Start', link: '/guide/quick-start' },
            { text: 'Theming', link: '/guide/theming' }
          ]
        }
      ],
      '/components/': [
        {
          text: 'Basic Components',
          items: [
            { text: 'Button', link: '/components/button' },
            { text: 'Input', link: '/components/input' },
            { text: 'Card', link: '/components/card' }
          ]
        }
      ]
    }
  },
  vite: {
    plugins: [
      // è‡ªå®šä¹‰æ’ä»¶å¤„ç† Vue ç»„ä»¶ç¤ºä¾‹
    ]
  }
})
```

**ç»„ä»¶æ–‡æ¡£ç¤ºä¾‹**

```markdown
# Button æŒ‰é’®

åŸºç¡€çš„æŒ‰é’®ç»„ä»¶ï¼Œæ”¯æŒå¤šç§ç±»å‹å’ŒçŠ¶æ€ã€‚

## åŸºç¡€ç”¨æ³•

<demo>
<template>
  <div class="demo-button">
    <Button type="primary">Primary</Button>
    <Button type="secondary">Secondary</Button>
    <Button type="danger">Danger</Button>
  </div>
</template>
</demo>

## ç¦ç”¨çŠ¶æ€

<demo>
<template>
  <div class="demo-button">
    <Button disabled>Disabled Button</Button>
    <Button type="primary" disabled>Primary Disabled</Button>
  </div>
</template>
</demo>

## API

### Props

| å‚æ•° | è¯´æ˜ | ç±»å‹ | å¯é€‰å€¼ | é»˜è®¤å€¼ |
|------|------|------|--------|--------|
| type | æŒ‰é’®ç±»å‹ | string | primary / secondary / danger / ghost | - |
| size | æŒ‰é’®å°ºå¯¸ | string | small / medium / large | medium |
| disabled | æ˜¯å¦ç¦ç”¨ | boolean | - | false |
| loading | æ˜¯å¦åŠ è½½ä¸­ | boolean | - | false |

### Events

| äº‹ä»¶å | è¯´æ˜ | å›è°ƒå‚æ•° |
|--------|------|----------|
| click | ç‚¹å‡»äº‹ä»¶ | (event: MouseEvent) |

### Slots

| æ’æ§½å | è¯´æ˜ |
|-------|------|
| default | æŒ‰é’®å†…å®¹ |
```



## ä¼ä¸šçº§ Vue ç»„ä»¶åº“å¼€å‘å·¥ä½œæµ

### é¡¹ç›®ç»“æ„è®¾è®¡

```
vue-ui-library/
â”œâ”€â”€ packages/
â”‚   â”œâ”€â”€ components/          # ç»„ä»¶æºç 
â”‚   â”‚   â”œâ”€â”€ button/
â”‚   â”‚   â”œâ”€â”€ input/
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”œâ”€â”€ theme/              # ä¸»é¢˜ç›¸å…³
â”‚   â”œâ”€â”€ utils/              # å·¥å…·å‡½æ•°
â”‚   â””â”€â”€ icons/              # å›¾æ ‡åº“
â”œâ”€â”€ docs/                   # æ–‡æ¡£
â”œâ”€â”€ playground/             # å¼€å‘è°ƒè¯•
â”œâ”€â”€ tests/                  # æµ‹è¯•
â”œâ”€â”€ scripts/                # æ„å»ºè„šæœ¬
â””â”€â”€ tools/                  # å¼€å‘å·¥å…·
```

### ç»„ä»¶å¼€å‘æ¨¡æ¿

**ç»„ä»¶æ¨¡æ¿ç”Ÿæˆå™¨**

```javascript
// scripts/create-component.js
const fs = require('fs')
const path = require('path')

function createComponent(componentName) {
  const componentDir = path.join(__dirname, '../packages/components', componentName)
  
  // åˆ›å»ºç›®å½•ç»“æ„
  fs.mkdirSync(componentDir, { recursive: true })
  
  // ç”Ÿæˆç»„ä»¶æ–‡ä»¶
  const componentTemplate = `
<template>
  <div class="ui-${componentName.toLowerCase()}">
    <slot />
  </div>
</template>

<script setup lang="ts">
import { defineProps, defineEmits } from 'vue'

interface Props {
  // å®šä¹‰ props ç±»å‹
}

interface Emits {
  // å®šä¹‰ emits ç±»å‹
}

const props = withDefaults(defineProps<Props>(), {
  // é»˜è®¤å€¼
})

const emit = defineEmits<Emits>()
</script>

<style scoped lang="scss">
.ui-${componentName.toLowerCase()} {
  // ç»„ä»¶æ ·å¼
}
</style>
`

  fs.writeFileSync(
    path.join(componentDir, `${componentName}.vue`), 
    componentTemplate
  )
  
  // ç”Ÿæˆ index.ts
  const indexTemplate = `
import ${componentName} from './${componentName}.vue'
import type { App } from 'vue'

${componentName}.install = (app: App) => {
  app.component('Ui${componentName}', ${componentName})
}

export default ${componentName}
`
  
  fs.writeFileSync(
    path.join(componentDir, 'index.ts'), 
    indexTemplate
  )
  
  console.log(`Component ${componentName} created successfully!`)
}

// ä½¿ç”¨: node scripts/create-component.js Button
const componentName = process.argv[2]
if (componentName) {
  createComponent(componentName)
}
```

### è‡ªåŠ¨åŒ–å‘å¸ƒæµç¨‹

**Release é…ç½®**

```javascript
// scripts/release.js
const { execSync } = require('child_process')
const inquirer = require('inquirer')
const semver = require('semver')
const fs = require('fs')

async function release() {
  // 1. æ£€æŸ¥å·¥ä½œåŒºçŠ¶æ€
  const status = execSync('git status --porcelain', { encoding: 'utf8' })
  if (status) {
    console.error('Working directory is not clean')
    process.exit(1)
  }
  
  // 2. è¿è¡Œæµ‹è¯•
  console.log('Running tests...')
  execSync('npm run test', { stdio: 'inherit' })
  
  // 3. æ„å»º
  console.log('Building...')
  execSync('npm run build', { stdio: 'inherit' })
  
  // 4. ç‰ˆæœ¬é€‰æ‹©
  const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'))
  const currentVersion = pkg.version
  
  const { version } = await inquirer.prompt([
    {
      type: 'list',
      name: 'version',
      message: 'Select release type:',
      choices: [
        { name: `patch (${semver.inc(currentVersion, 'patch')})`, value: 'patch' },
        { name: `minor (${semver.inc(currentVersion, 'minor')})`, value: 'minor' },
        { name: `major (${semver.inc(currentVersion, 'major')})`, value: 'major' },
        { name: 'custom', value: 'custom' }
      ]
    }
  ])
  
  const newVersion = version === 'custom' 
    ? (await inquirer.prompt([{ name: 'version', message: 'Enter version:' }])).version
    : semver.inc(currentVersion, version)
  
  // 5. æ›´æ–°ç‰ˆæœ¬å·
  pkg.version = newVersion
  fs.writeFileSync('package.json', JSON.stringify(pkg, null, 2))
  
  // 6. æäº¤å¹¶æ‰“æ ‡ç­¾
  execSync(`git add package.json`)
  execSync(`git commit -m "release: v${newVersion}"`)
  execSync(`git tag v${newVersion}`)
  
  // 7. å‘å¸ƒåˆ° npm
  execSync('npm publish', { stdio: 'inherit' })
  
  // 8. æ¨é€åˆ°è¿œç¨‹ä»“åº“
  execSync('git push origin main --tags')
  
  console.log(`Released v${newVersion} successfully!`)
}

release().catch(console.error)
```





## å¤šå›¢é˜Ÿåä½œä¸‹çš„ Vue é¡¹ç›®ç®¡ç†ä¸æ¨¡å—è§£è€¦

### å¾®å‰ç«¯æ¶æ„è®¾è®¡

**ä¸»åº”ç”¨æ¡†æ¶**

```javascript
// apps/main/src/main.js
import { createApp } from 'vue'
import { createRouter, createWebHistory } from 'vue-router'
import App from './App.vue'

// å¾®åº”ç”¨æ³¨å†Œ
const microApps = [
  {
    name: 'user-module',
    entry: 'http://localhost:8081',
    container: '#user-container',
    activeRule: '/user'
  },
  {
    name: 'product-module',
    entry: 'http://localhost:8082',
    container: '#product-container',
    activeRule: '/product'
  }
]

// è·¯ç”±é…ç½®
const routes = [
  {
    path: '/user/:pathMatch(.*)*',
    component: () => import('./MicroApp.vue'),
    props: { appName: 'user-module' }
  },
  {
    path: '/product/:pathMatch(.*)*',
    component: () => import('./MicroApp.vue'),
    props: { appName: 'product-module' }
  }
]

const router = createRouter({
  history: createWebHistory(),
  routes
})

const app = createApp(App)
app.use(router)
app.mount('#app')
```

**å›¢é˜Ÿè¾¹ç•Œåè®®**

```typescript
// shared/types/team-contracts.ts
export interface TeamContract {
  team: string
  modules: string[]
  apis: ApiContract[]
  events: EventContract[]
  dependencies: string[]
}

export interface ApiContract {
  name: string
  method: 'GET' | 'POST' | 'PUT' | 'DELETE'
  path: string
  request?: any
  response?: any
}

export interface EventContract {
  name: string
  payload?: any
}

// ç”¨æˆ·å›¢é˜Ÿåè®®
export const userTeamContract: TeamContract = {
  team: 'user-team',
  modules: ['user-management', 'user-profile', 'authentication'],
  apis: [
    {
      name: 'getUserInfo',
      method: 'GET',
      path: '/api/user/:id',
      response: {
        id: 'string',
        name: 'string',
        email: 'string'
      }
    }
  ],
  events: [
    {
      name: 'user-login',
      payload: {
        userId: 'string',
        timestamp: 'number'
      }
    }
  ],
  dependencies: ['@shared/ui-components', '@shared/utils']
}
```

### è·¨å›¢é˜Ÿé€šä¿¡æœºåˆ¶

**äº‹ä»¶æ€»çº¿ç³»ç»Ÿ**

```typescript
// shared/event-bus.ts
class EventBus {
  private events: Map<string, Function[]> = new Map()
  
  on(event: string, callback: Function) {
    if (!this.events.has(event)) {
      this.events.set(event, [])
    }
    this.events.get(event)!.push(callback)
  }
  
  emit(event: string, data?: any) {
    const callbacks = this.events.get(event)
    if (callbacks) {
      callbacks.forEach(callback => callback(data))
    }
  }
  
  off(event: string, callback?: Function) {
    if (!callback) {
      this.events.delete(event)
      return
    }
    
    const callbacks = this.events.get(event)
    if (callbacks) {
      const index = callbacks.indexOf(callback)
      if (index > -1) {
        callbacks.splice(index, 1)
      }
    }
  }
}

export const globalEventBus = new EventBus()

// åœ¨ Vue åº”ç”¨ä¸­ä½¿ç”¨
import { getCurrentInstance } from 'vue'

export function useEventBus() {
  const instance = getCurrentInstance()
  
  const emit = (event: string, data?: any) => {
    globalEventBus.emit(event, data)
  }
  
  const on = (event: string, callback: Function) => {
    globalEventBus.on(event, callback)
    
    // ç»„ä»¶å¸è½½æ—¶è‡ªåŠ¨æ¸…ç†
    if (instance) {
      const { scope } = instance
      scope.stop = () => {
        globalEventBus.off(event, callback)
      }
    }
  }
  
  return { emit, on }
}
```



## Vue é¡¹ç›®çš„æ¸è¿›å¼è¿ç§»ç­–ç•¥

### Vue 2 åˆ° Vue 3 è¿ç§»æ–¹æ¡ˆ

**å…¼å®¹æ€§æ„å»ºé…ç½®**

```javascript
// vue.config.js (Vue 2 é¡¹ç›®)
const { defineConfig } = require('@vue/cli-service')

module.exports = defineConfig({
  // å¯ç”¨ Vue 3 å…¼å®¹æ¨¡å¼
  chainWebpack: config => {
    config.resolve.alias.set('vue', '@vue/compat')
    
    config.module
      .rule('vue')
      .use('vue-loader')
      .tap(options => {
        return {
          ...options,
          compilerOptions: {
            compatConfig: {
              MODE: 2
            }
          }
        }
      })
  }
})
```

**æ¸è¿›å¼è¿ç§»å·¥å…·**

```javascript
// scripts/migration-helper.js
const fs = require('fs')
const path = require('path')
const { parse } = require('@vue/compiler-sfc')

class MigrationHelper {
  constructor(srcDir) {
    this.srcDir = srcDir
    this.issues = []
  }
  
  // æ£€æµ‹éœ€è¦è¿ç§»çš„å†…å®¹
  checkCompatibility() {
    this.scanDirectory(this.srcDir)
    this.generateReport()
  }
  
  scanDirectory(dir) {
    const files = fs.readdirSync(dir)
    
    files.forEach(file => {
      const filePath = path.join(dir, file)
      const stat = fs.statSync(filePath)
      
      if (stat.isDirectory()) {
        this.scanDirectory(filePath)
      } else if (file.endsWith('.vue')) {
        this.checkVueFile(filePath)
      } else if (file.endsWith('.js') || file.endsWith('.ts')) {
        this.checkJSFile(filePath)
      }
    })
  }
  
  checkVueFile(filePath) {
    const content = fs.readFileSync(filePath, 'utf8')
    const { descriptor } = parse(content, { filename: filePath })
    
    // æ£€æŸ¥ Vue 2 ç‰¹æœ‰è¯­æ³•
    if (descriptor.script) {
      this.checkVue2Patterns(descriptor.script.content, filePath)
    }
    
    if (descriptor.template) {
      this.checkTemplatePatterns(descriptor.template.content, filePath)
    }
  }
  
  checkVue2Patterns(content, filePath) {
    const patterns = [
      {
        pattern: /\$listeners/g,
        message: '$listeners å·²è¢«ç§»é™¤ï¼Œä½¿ç”¨ $attrs æ›¿ä»£',
        severity: 'error'
      },
      {
        pattern: /\$scopedSlots/g,
        message: '$scopedSlots å·²è¢«ç§»é™¤ï¼Œä½¿ç”¨ $slots æ›¿ä»£',
        severity: 'error'
      },
      {
        pattern: /Vue\.filter/g,
        message: 'è¿‡æ»¤å™¨å·²è¢«ç§»é™¤ï¼Œä½¿ç”¨è®¡ç®—å±æ€§æˆ–æ–¹æ³•æ›¿ä»£',
        severity: 'error'
      },
      {
        pattern: /new Vue\(/g,
        message: 'ä½¿ç”¨ createApp() æ›¿ä»£ new Vue()',
        severity: 'warning'
      }
    ]
    
    patterns.forEach(({ pattern, message, severity }) => {
      const matches = content.match(pattern)
      if (matches) {
        this.issues.push({
          file: filePath,
          type: severity,
          message,
          count: matches.length
        })
      }
    })
  }
  
  generateReport() {
    const report = {
      total: this.issues.length,
      errors: this.issues.filter(i => i.type === 'error').length,
      warnings: this.issues.filter(i => i.type === 'warning').length,
      issues: this.issues
    }
    
    fs.writeFileSync(
      'migration-report.json',
      JSON.stringify(report, null, 2)
    )
    
    console.log(`Migration Report Generated:`)
    console.log(`Total Issues: ${report.total}`)
    console.log(`Errors: ${report.errors}`)
    console.log(`Warnings: ${report.warnings}`)
  }
}

// ä½¿ç”¨è¿ç§»åŠ©æ‰‹
const migrationHelper = new MigrationHelper('./src')
migrationHelper.checkCompatibility()
```

**åˆ†æ­¥è¿ç§»ç­–ç•¥**

```javascript
// ç¬¬ä¸€é˜¶æ®µï¼šåŸºç¡€ API è¿ç§»
// migration/phase1-basic-api.js
export function migrateBasicAPIs(content) {
  return content
    // Vue å®ä¾‹åˆ›å»º
    .replace(/new Vue\(\{/g, 'createApp({')
    // å…¨å±€ API
    .replace(/Vue\.extend/g, 'defineComponent')
    .replace(/Vue\.component/g, 'app.component')
    .replace(/Vue\.directive/g, 'app.directive')
    .replace(/Vue\.mixin/g, 'app.mixin')
    .replace(/Vue\.use/g, 'app.use')
    // å®ä¾‹æ–¹æ³•
    .replace(/\$mount\(['"](.*?)['"]\)/g, 'mount("$1")')
}

// ç¬¬äºŒé˜¶æ®µï¼šç»„åˆå¼ API è¿ç§»
// migration/phase2-composition-api.js
export function migrateToCompositionAPI(vueComponent) {
  const template = `
<template>
  ${vueComponent.template}
</template>

<script setup>
import { ref, reactive, computed, watch, onMounted } from 'vue'

// å°† data è½¬æ¢ä¸º reactive/ref
${convertDataToRefs(vueComponent.data)}

// å°† computed è½¬æ¢
${convertComputed(vueComponent.computed)}

// å°† methods è½¬æ¢ä¸ºå‡½æ•°
${convertMethods(vueComponent.methods)}

// å°†ç”Ÿå‘½å‘¨æœŸé’©å­è½¬æ¢
${convertLifecycle(vueComponent)}

// å°† watch è½¬æ¢
${convertWatchers(vueComponent.watch)}
</script>

<style scoped>
${vueComponent.style}
</style>
`
  return template
}
```

### ç‰ˆæœ¬å…¼å®¹æ€§ç®¡ç†

**ç‰¹æ€§å¼€å…³ç³»ç»Ÿ**

```typescript
// utils/feature-flags.ts
interface FeatureFlags {
  useVue3Features: boolean
  enableCompositionAPI: boolean
  useTeleport: boolean
  useFragments: boolean
}

class FeatureFlagManager {
  private flags: FeatureFlags
  
  constructor() {
    this.flags = {
      useVue3Features: this.checkVueVersion() >= 3,
      enableCompositionAPI: true,
      useTeleport: this.checkVueVersion() >= 3,
      useFragments: this.checkVueVersion() >= 3
    }
  }
  
  private checkVueVersion(): number {
    // @ts-ignore
    const version = require('vue/package.json').version
    return parseInt(version.split('.')[0])
  }
  
  isEnabled(flag: keyof FeatureFlags): boolean {
    return this.flags[flag]
  }
  
  enable(flag: keyof FeatureFlags) {
    this.flags[flag] = true
  }
  
  disable(flag: keyof FeatureFlags) {
    this.flags[flag] = false
  }
}

export const featureFlags = new FeatureFlagManager()

// åœ¨ç»„ä»¶ä¸­ä½¿ç”¨
export function useFeatureFlag(flag: keyof FeatureFlags) {
  return featureFlags.isEnabled(flag)
}
```



## Monorepo åœ¨ Vue é¡¹ç›®ä¸­çš„åº”ç”¨ä¸å®è·µ

### Lerna + pnpm é…ç½®

**é¡¹ç›®ç»“æ„**

```
vue-monorepo/
â”œâ”€â”€ packages/
â”‚   â”œâ”€â”€ ui-components/          # ç»„ä»¶åº“
â”‚   â”œâ”€â”€ utils/                  # å·¥å…·åº“
â”‚   â”œâ”€â”€ theme/                  # ä¸»é¢˜åŒ…
â”‚   â”œâ”€â”€ icons/                  # å›¾æ ‡åŒ…
â”‚   â”œâ”€â”€ web-app/               # Web åº”ç”¨
â”‚   â”œâ”€â”€ mobile-app/            # ç§»åŠ¨ç«¯åº”ç”¨
â”‚   â””â”€â”€ admin-app/             # ç®¡ç†åå°
â”œâ”€â”€ tools/
â”‚   â”œâ”€â”€ build-tools/           # æ„å»ºå·¥å…·
â”‚   â”œâ”€â”€ eslint-config/         # ESLint é…ç½®
â”‚   â””â”€â”€ jest-config/           # Jest é…ç½®
â”œâ”€â”€ docs/                      # æ–‡æ¡£
â”œâ”€â”€ pnpm-workspace.yaml
â”œâ”€â”€ lerna.json
â””â”€â”€ package.json
```

**Workspace é…ç½®**

```yaml
# pnpm-workspace.yaml
packages:
  - 'packages/*'
  - 'tools/*'
  - 'docs'
```

```json
// lerna.json
{
  "version": "independent",
  "npmClient": "pnpm",
  "useWorkspaces": true,
  "command": {
    "publish": {
      "conventionalCommits": true,
      "message": "chore(release): publish",
      "registry": "https://registry.npmjs.org/"
    },
    "version": {
      "allowBranch": ["main", "release/*"],
      "conventionalCommits": true
    }
  }
}
```





### åŒ…ç®¡ç†ä¸ä¾èµ–ä¼˜åŒ–

**æ ¹ç›®å½• package.json**

```json
{
  "name": "vue-monorepo",
  "private": true,
  "workspaces": ["packages/*", "tools/*"],
  "scripts": {
    "build": "lerna run build",
    "test": "lerna run test",
    "lint": "lerna run lint",
    "dev": "lerna run dev --parallel",
    "clean": "lerna clean && rm -rf node_modules",
    "bootstrap": "lerna bootstrap",
    "publish": "lerna publish",
    "version": "lerna version"
  },
  "devDependencies": {
    "@lerna/cli": "latest",
    "typescript": "latest",
    "vite": "latest",
    "@vue/tsconfig": "latest"
  }
}
```

**å­åŒ…é…ç½®ç¤ºä¾‹**

```json
// packages/ui-components/package.json
{
  "name": "@vue-monorepo/ui-components",
  "version": "1.0.0",
  "main": "dist/index.js",
  "module": "dist/index.esm.js",
  "types": "dist/index.d.ts",
  "files": ["dist"],
  "scripts": {
    "build": "vite build",
    "dev": "vite build --watch",
    "test": "vitest"
  },
  "dependencies": {
    "vue": "^3.3.0"
  },
  "peerDependencies": {
    "vue": "^3.0.0"
  }
}
```

### æ„å»ºå·¥å…·é…ç½®

**ç»Ÿä¸€æ„å»ºé…ç½®**

```javascript
// tools/build-tools/vite.config.base.js
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import dts from 'vite-plugin-dts'
import { resolve } from 'path'

export function createViteConfig(options = {}) {
  const {
    entry = 'src/index.ts',
    formats = ['es', 'cjs'],
    external = ['vue'],
    globals = { vue: 'Vue' }
  } = options

  return defineConfig({
    plugins: [
      vue(),
      dts({
        include: ['src/**/*'],
        exclude: ['src/**/*.stories.ts', 'src/**/*.test.ts']
      })
    ],
    build: {
      lib: {
        entry: resolve(process.cwd(), entry),
        formats,
        fileName: (format) => `index.${format}.js`
      },
      rollupOptions: {
        external,
        output: {
          globals
        }
      }
    },
    resolve: {
      alias: {
        '@': resolve(process.cwd(), 'src')
      }
    }
  })
}
```

**åº”ç”¨çº§æ„å»ºé…ç½®**

```javascript
// packages/web-app/vite.config.js
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import { resolve } from 'path'

export default defineConfig({
  plugins: [vue()],
  resolve: {
    alias: {
      '@': resolve(__dirname, 'src'),
      '@ui': resolve(__dirname, '../ui-components/src'),
      '@utils': resolve(__dirname, '../utils/src')
    }
  },
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          vendor: ['vue', 'vue-router', 'pinia'],
          ui: ['@vue-monorepo/ui-components']
        }
      }
    }
  }
})
```



### ç‰ˆæœ¬å‘å¸ƒè‡ªåŠ¨åŒ–

**è‡ªåŠ¨åŒ–å‘å¸ƒè„šæœ¬**

```javascript
// scripts/release.js
const { execSync } = require('child_process')
const inquirer = require('inquirer')

async function release() {
  console.log('ğŸš€ Starting release process...')
  
  // 1. æ£€æŸ¥å·¥ä½œåŒºçŠ¶æ€
  try {
    execSync('git diff-index --quiet HEAD --')
  } catch (error) {
    console.error('âŒ Working directory is not clean')
    process.exit(1)
  }
  
  // 2. æ›´æ–°ä¾èµ–
  console.log('ğŸ“¦ Installing dependencies...')
  execSync('pnpm install', { stdio: 'inherit' })
  
  // 3. è¿è¡Œæµ‹è¯•
  console.log('ğŸ§ª Running tests...')
  execSync('pnpm test', { stdio: 'inherit' })
  
  // 4. æ„å»ºæ‰€æœ‰åŒ…
  console.log('ğŸ”¨ Building packages...')
  execSync('pnpm build', { stdio: 'inherit' })
  
  // 5. é€‰æ‹©å‘å¸ƒç±»å‹
  const { releaseType } = await inquirer.prompt([
    {
      type: 'list',
      name: 'releaseType',
      message: 'Select release type:',
      choices: [
        { name: 'Patch (bug fixes)', value: 'patch' },
        { name: 'Minor (new features)', value: 'minor' },
        { name: 'Major (breaking changes)', value: 'major' },
        { name: 'Prerelease', value: 'prerelease' },
        { name: 'Graduate prerelease', value: 'graduate' }
      ]
    }
  ])
  
  // 6. ç‰ˆæœ¬æ›´æ–°
  console.log('ğŸ“ Updating versions...')
  const versionCommand = releaseType === 'graduate' 
    ? 'lerna version --conventional-commits --conventional-graduate'
    : `lerna version ${releaseType} --conventional-commits`
  
  execSync(versionCommand, { stdio: 'inherit' })
  
  // 7. å‘å¸ƒ
  const { shouldPublish } = await inquirer.prompt([
    {
      type: 'confirm',
      name: 'shouldPublish',
      message: 'Publish to npm?',
      default: true
    }
  ])
  
  if (shouldPublish) {
    console.log('ğŸš€ Publishing to npm...')
    execSync('lerna publish from-git', { stdio: 'inherit' })
  }
  
  console.log('âœ… Release completed!')
}

release().catch(console.error)
```

### å¼€å‘å·¥ä½œæµä¼˜åŒ–

**å¹¶è¡Œå¼€å‘è„šæœ¬**

```javascript
// scripts/dev.js
const { spawn } = require('child_process')
const inquirer = require('inquirer')

async function dev() {
  const { packages } = await inquirer.prompt([
    {
      type: 'checkbox',
      name: 'packages',
      message: 'Select packages to run in development mode:',
      choices: [
        { name: 'UI Components', value: 'ui-components' },
        { name: 'Web App', value: 'web-app' },
        { name: 'Mobile App', value: 'mobile-app' },
        { name: 'Admin App', value: 'admin-app' },
        { name: 'Storybook', value: 'storybook' }
      ]
    }
  ])
  
  const processes = []
  
  packages.forEach(pkg => {
    const process = spawn('pnpm', ['--filter', `@vue-monorepo/${pkg}`, 'dev'], {
      stdio: 'inherit',
      shell: true
    })
    
    processes.push(process)
    console.log(`ğŸš€ Started ${pkg} in development mode`)
  })
  
  // ä¼˜é›…å…³é—­
  process.on('SIGINT', () => {
    console.log('\nğŸ›‘ Shutting down all processes...')
    processes.forEach(proc => proc.kill())
    process.exit(0)
  })
}

dev().catch(console.error)
```

**ä¾èµ–åˆ†æå·¥å…·**

```javascript
// tools/analyze-deps.js
const fs = require('fs')
const path = require('path')
const glob = require('glob')

class DependencyAnalyzer {
  constructor() {
    this.packages = new Map()
    this.dependencies = new Map()
  }
  
  analyze() {
    this.scanPackages()
    this.buildDependencyGraph()
    this.generateReport()
  }
  
  scanPackages() {
    const packagePaths = glob.sync('packages/*/package.json')
    
    packagePaths.forEach(pkgPath => {
      const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf8'))
      const packageDir = path.dirname(pkgPath)
      
      this.packages.set(pkg.name, {
        ...pkg,
        path: packageDir,
        localDeps: this.findLocalDependencies(pkg),
        externalDeps: this.findExternalDependencies(pkg)
      })
    })
  }
  
  findLocalDependencies(pkg) {
    const deps = { ...pkg.dependencies, ...pkg.devDependencies }
    return Object.keys(deps).filter(dep => dep.startsWith('@vue-monorepo/'))
  }
  
  findExternalDependencies(pkg) {
    const deps = { ...pkg.dependencies, ...pkg.devDependencies }
    return Object.keys(deps).filter(dep => !dep.startsWith('@vue-monorepo/'))
  }
  
  buildDependencyGraph() {
    this.packages.forEach((pkg, name) => {
      pkg.localDeps.forEach(dep => {
        if (!this.dependencies.has(name)) {
          this.dependencies.set(name, [])
        }
        this.dependencies.get(name).push(dep)
      })
    })
  }
  
  generateReport() {
    const report = {
      packages: Array.from(this.packages.values()),
      dependencyGraph: Object.fromEntries(this.dependencies),
      duplicateDependencies: this.findDuplicateDependencies(),
      circularDependencies: this.findCircularDependencies()
    }
    
    fs.writeFileSync('dependency-report.json', JSON.stringify(report, null, 2))
    console.log('ğŸ“Š Dependency analysis completed!')
  }
  
  findDuplicateDependencies() {
    const allDeps = new Map()
    
    this.packages.forEach(pkg => {
      pkg.externalDeps.forEach(dep => {
        if (!allDeps.has(dep)) {
          allDeps.set(dep, [])
        }
        allDeps.get(dep).push(pkg.name)
      })
    })
    
    return Array.from(allDeps.entries())
      .filter(([dep, packages]) => packages.length > 1)
      .map(([dep, packages]) => ({ dependency: dep, packages }))
  }
  
  findCircularDependencies() {
    // ç®€åŒ–çš„å¾ªç¯ä¾èµ–æ£€æµ‹
    const visited = new Set()
    const recursionStack = new Set()
    const cycles = []
    
    const dfs = (node, path = []) => {
      if (recursionStack.has(node)) {
        const cycleStart = path.indexOf(node)
        cycles.push(path.slice(cycleStart).concat(node))
        return
      }
      
      if (visited.has(node)) return
      
      visited.add(node)
      recursionStack.add(node)
      path.push(node)
      
      const deps = this.dependencies.get(node) || []
      deps.forEach(dep => dfs(dep, [...path]))
      
      recursionStack.delete(node)
    }
    
    this.packages.forEach((pkg, name) => {
      if (!visited.has(name)) {
        dfs(name)
      }
    })
    
    return cycles
  }
}

// ä½¿ç”¨åˆ†æå·¥å…·
const analyzer = new DependencyAnalyzer()
analyzer.analyze()
```

## æ€»ç»“

Vueé¡¹ç›®çš„å·¥ç¨‹åŒ–å®è·µéœ€è¦ä»å¤šä¸ªç»´åº¦ç»¼åˆè€ƒè™‘ï¼š

1. **ä»£ç è´¨é‡ä¿è¯** - é€šè¿‡ESLintã€Prettierã€StyleLintç­‰å·¥å…·å»ºç«‹ä»£ç è§„èŒƒï¼Œé…åˆGit Hooksç¡®ä¿ä»£ç è´¨é‡
2. **æµ‹è¯•ç­–ç•¥** - å»ºç«‹å®Œæ•´çš„æµ‹è¯•ä½“ç³»ï¼ŒåŒ…æ‹¬å•å…ƒæµ‹è¯•ã€ç»„ä»¶æµ‹è¯•å’ŒE2Eæµ‹è¯•ï¼Œç¡®ä¿ä»£ç çš„å¯é æ€§
3. **æ–‡æ¡£ä¸ç¤ºä¾‹** - ä½¿ç”¨Storybookå’ŒVitePressç­‰å·¥å…·å»ºç«‹å®Œå–„çš„æ–‡æ¡£ç³»ç»Ÿï¼Œæå‡å›¢é˜Ÿåä½œæ•ˆç‡
4. **ç»„ä»¶åº“å·¥ä½œæµ** - è®¾è®¡æ ‡å‡†åŒ–çš„ç»„ä»¶å¼€å‘ã€æµ‹è¯•ã€å‘å¸ƒæµç¨‹ï¼Œæ”¯æŒå¤§è§„æ¨¡å›¢é˜Ÿåä½œ
5. **æ¨¡å—è§£è€¦** - é€šè¿‡å¾®å‰ç«¯æ¶æ„å’Œäº‹ä»¶æ€»çº¿ç­‰æŠ€æœ¯å®ç°å›¢é˜Ÿé—´çš„æ¾è€¦åˆåä½œ
6. **æ¸è¿›å¼è¿ç§»** - åˆ¶å®šåˆç†çš„æŠ€æœ¯æ ˆå‡çº§ç­–ç•¥ï¼Œé™ä½è¿ç§»é£é™©å’Œæˆæœ¬
7. **Monorepoç®¡ç†** - ä½¿ç”¨ç°ä»£åŒ–çš„åŒ…ç®¡ç†å·¥å…·ï¼Œå®ç°ä»£ç å¤ç”¨å’Œç»Ÿä¸€ç®¡ç†





# Vue 3 + TypeScript æ·±åº¦é›†æˆ

## Vue 3 ä¸­çš„ TypeScript ç±»å‹ç³»ç»Ÿè®¾è®¡ä¸å®ç°åŸç†

###  Vue 3 ç±»å‹ç³»ç»Ÿæ¶æ„

Vue 3 çš„ç±»å‹ç³»ç»ŸåŸºäºä»¥ä¸‹æ ¸å¿ƒè®¾è®¡åŸåˆ™ï¼š

```typescript
// Vue 3 çš„æ ¸å¿ƒç±»å‹å®šä¹‰ç»“æ„
interface ComponentInternalInstance {
  uid: number
  vnode: VNode
  type: ConcreteComponent
  parent: ComponentInternalInstance | null
  appContext: AppContext
  // ... æ›´å¤šå†…éƒ¨å±æ€§
}

// ç»„ä»¶ç±»å‹çš„æŠ½è±¡
type Component<P = {}, RawBindings = any> = 
  | ConcreteComponent<P, RawBindings>
  | ComponentPublicInstanceConstructor<P>

// å“åº”å¼ç³»ç»Ÿçš„ç±»å‹åŸºç¡€
interface Ref<T = any> {
  value: T
  [RefSymbol]: true
}
```



### å“åº”å¼ç³»ç»Ÿçš„ç±»å‹å®ç°

```typescript
// å“åº”å¼å¼•ç”¨çš„ç±»å‹æ¨å¯¼
function ref<T>(value: T): Ref<UnwrapRef<T>>
function ref<T = any>(): Ref<T | undefined>

// è®¡ç®—å±æ€§çš„ç±»å‹æ¨å¯¼
function computed<T>(
  getter: ComputedGetter<T>,
  debugOptions?: DebuggerOptions
): ComputedRef<T>

function computed<T>(
  options: WritableComputedOptions<T>,
  debugOptions?: DebuggerOptions
): WritableComputedRef<T>

// å“åº”å¼å¯¹è±¡çš„ç±»å‹è½¬æ¢
type UnwrapRef<T> = T extends Ref<infer V>
  ? UnwrapRefSimple<V>
  : UnwrapRefSimple<T>

type UnwrapRefSimple<T> = T extends
  | Function
  | CollectionTypes
  | BaseTypes
  | Ref
  | RefUnwrapBailTypes[keyof RefUnwrapBailTypes]
  ? T
  : T extends Array<any>
  ? { [K in keyof T]: UnwrapRefSimple<T[K]> }
  : T extends object & { [ShallowReactiveMarker]?: never }
  ? {
      [P in keyof T]: P extends symbol ? T[P] : UnwrapRef<T[P]>
    }
  : T
```



### ç»„ä»¶å®šä¹‰çš„ç±»å‹ç³»ç»Ÿ

```typescript
// defineComponent çš„ç±»å‹é‡è½½
function defineComponent<Props, RawBindings = object>(
  setup: (
    props: Readonly<Props>,
    ctx: SetupContext
  ) => RawBindings | RenderFunction
): DefineComponent<Props, RawBindings>

// ç»„ä»¶é€‰é¡¹çš„ç±»å‹å®šä¹‰
interface ComponentOptionsBase<V, D, C, M, E> {
  setup?: (
    props: Readonly<Props>,
    ctx: SetupContext<E>
  ) => Promise<RenderFunction | void> | RenderFunction | void
  name?: string
  template?: string | object
  render?: Function
  components?: Record<string, Component>
  directives?: Record<string, Directive>
  // ...æ›´å¤šé€‰é¡¹
}
```



## Vue ç»„ä»¶ Props çš„å¤æ‚ç±»å‹å®šä¹‰ä¸æ ¡éªŒ

### åŸºç¡€ Props ç±»å‹å®šä¹‰

```typescript
// åŸºç¡€ Props æ¥å£å®šä¹‰
interface UserProps {
  id: number
  name: string
  email?: string
  roles: string[]
  metadata: Record<string, any>
}

// ç»„ä»¶ä¸­ä½¿ç”¨ Props
import { defineComponent, PropType } from 'vue'

export default defineComponent({
  props: {
    id: {
      type: Number,
      required: true
    },
    name: {
      type: String,
      required: true,
      validator: (value: string) => value.length > 0
    },
    email: {
      type: String,
      default: ''
    },
    roles: {
      type: Array as PropType<string[]>,
      required: true,
      validator: (roles: string[]) => roles.every(role => 
        ['admin', 'user', 'guest'].includes(role)
      )
    },
    metadata: {
      type: Object as PropType<Record<string, any>>,
      default: () => ({})
    }
  },
  setup(props) {
    // props åœ¨è¿™é‡Œå·²ç»å…·æœ‰å®Œæ•´çš„ç±»å‹æ¨å¯¼
    console.log(props.id) // number
    console.log(props.name) // string
    console.log(props.roles) // string[]
    
    return {}
  }
})
```



### å¤æ‚ Props ç±»å‹å’Œè”åˆç±»å‹

```typescript
// å¤æ‚ç±»å‹å®šä¹‰
type ButtonVariant = 'primary' | 'secondary' | 'danger' | 'ghost'
type ButtonSize = 'small' | 'medium' | 'large'

interface ButtonConfig {
  variant: ButtonVariant
  size: ButtonSize
  disabled?: boolean
  loading?: boolean
}

// è”åˆç±»å‹çš„ Props
type DataSource = 
  | { type: 'api'; url: string; params?: Record<string, any> }
  | { type: 'static'; data: any[] }
  | { type: 'computed'; getter: () => any[] }

const DataTable = defineComponent({
  props: {
    config: {
      type: Object as PropType<ButtonConfig>,
      required: true,
      validator: (config: ButtonConfig) => {
        const validVariants: ButtonVariant[] = ['primary', 'secondary', 'danger', 'ghost']
        const validSizes: ButtonSize[] = ['small', 'medium', 'large']
        
        return validVariants.includes(config.variant) && 
               validSizes.includes(config.size)
      }
    },
    dataSource: {
      type: Object as PropType<DataSource>,
      required: true,
      validator: (source: DataSource) => {
        switch (source.type) {
          case 'api':
            return typeof source.url === 'string'
          case 'static':
            return Array.isArray(source.data)
          case 'computed':
            return typeof source.getter === 'function'
          default:
            return false
        }
      }
    }
  },
  setup(props) {
    // ç±»å‹æ¨å¯¼å’Œç±»å‹å®ˆå«
    const loadData = () => {
      const { dataSource } = props
      
      if (dataSource.type === 'api') {
        // TypeScript çŸ¥é“è¿™é‡Œ dataSource æœ‰ url å±æ€§
        return fetch(dataSource.url)
      } else if (dataSource.type === 'static') {
        // TypeScript çŸ¥é“è¿™é‡Œ dataSource æœ‰ data å±æ€§
        return Promise.resolve(dataSource.data)
      } else {
        // TypeScript çŸ¥é“è¿™é‡Œ dataSource æœ‰ getter å±æ€§
        return Promise.resolve(dataSource.getter())
      }
    }
    
    return { loadData }
  }
})
```



### æ³›å‹ Props å’Œé«˜çº§ç±»å‹çº¦æŸ

```typescript
// æ³›å‹ç»„ä»¶å®šä¹‰
function defineGenericComponent<T extends Record<string, any>>() {
  return defineComponent({
    props: {
      items: {
        type: Array as PropType<T[]>,
        required: true
      },
      keyField: {
        type: String as PropType<keyof T>,
        required: true
      },
      displayField: {
        type: String as PropType<keyof T>,
        required: true
      }
    },
    setup(props) {
      const getItemKey = (item: T) => item[props.keyField]
      const getItemDisplay = (item: T) => item[props.displayField]
      
      return {
        getItemKey,
        getItemDisplay
      }
    }
  })
}

// ä½¿ç”¨æ³›å‹ç»„ä»¶
interface User {
  id: number
  name: string
  email: string
}

const UserList = defineGenericComponent<User>()

// ç±»å‹çº¦æŸçš„ Props
interface ListProps<T, K extends keyof T> {
  items: T[]
  keyField: K
  sortBy?: K
  filterBy?: Partial<Pick<T, K>>
}

const GenericList = <T extends Record<string, any>, K extends keyof T>() =>
  defineComponent({
    props: {
      items: {
        type: Array as PropType<T[]>,
        required: true
      },
      keyField: {
        type: String as PropType<K>,
        required: true
      },
      sortBy: {
        type: String as PropType<K>
      },
      filterBy: {
        type: Object as PropType<Partial<Pick<T, K>>>
      }
    },
    setup(props) {
      const sortedItems = computed(() => {
        if (!props.sortBy) return props.items
        
        return [...props.items].sort((a, b) => {
          const aVal = a[props.sortBy!]
          const bVal = b[props.sortBy!]
          
          if (aVal < bVal) return -1
          if (aVal > bVal) return 1
          return 0
        })
      })
      
      const filteredItems = computed(() => {
        if (!props.filterBy) return sortedItems.value
        
        return sortedItems.value.filter(item => {
          return Object.entries(props.filterBy!).every(([key, value]) =>
            item[key] === value
          )
        })
      })
      
      return {
        sortedItems,
        filteredItems
      }
    }
  })
```



## å¦‚ä½•ä¸º Vue ç»„åˆå¼å‡½æ•°ç¼–å†™ç²¾ç¡®çš„ TypeScript ç±»å‹

### åŸºç¡€ Composable å‡½æ•°ç±»å‹

```typescript
// çŠ¶æ€ç®¡ç† Composable
function useCounter(initialValue = 0) {
  const count = ref(initialValue)
  
  const increment = (step = 1) => {
    count.value += step
  }
  
  const decrement = (step = 1) => {
    count.value -= step
  }
  
  const reset = () => {
    count.value = initialValue
  }
  
  return {
    count: readonly(count),
    increment,
    decrement,
    reset
  } as const // ä½¿ç”¨ as const ä¿æŒç±»å‹ç²¾ç¡®æ€§
}

// è¿”å›ç±»å‹ä¼šè¢«æ¨å¯¼ä¸ºï¼š
// {
//   readonly count: DeepReadonly<Ref<number>>
//   readonly increment: (step?: number) => void
//   readonly decrement: (step?: number) => void
//   readonly reset: () => void
// }
```

### æ³›å‹ Composable å‡½æ•°

```typescript
// æ³›å‹æ•°æ®è·å– Hook
interface UseAsyncStateOptions<T> {
  initialData?: T
  resetOnExecute?: boolean
  immediate?: boolean
  onError?: (error: Error) => void
  onSuccess?: (data: T) => void
}

interface UseAsyncStateReturn<T> {
  data: Ref<T | undefined>
  loading: Ref<boolean>
  error: Ref<Error | null>
  execute: () => Promise<T>
  reset: () => void
}

function useAsyncState<T>(
  promise: () => Promise<T>,
  options: UseAsyncStateOptions<T> = {}
): UseAsyncStateReturn<T> {
  const {
    initialData,
    resetOnExecute = true,
    immediate = true,
    onError,
    onSuccess
  } = options
  
  const data = ref<T | undefined>(initialData)
  const loading = ref(false)
  const error = ref<Error | null>(null)
  
  const execute = async (): Promise<T> => {
    try {
      loading.value = true
      if (resetOnExecute) {
        error.value = null
      }
      
      const result = await promise()
      data.value = result
      onSuccess?.(result)
      return result
    } catch (err) {
      const errorObj = err instanceof Error ? err : new Error(String(err))
      error.value = errorObj
      onError?.(errorObj)
      throw errorObj
    } finally {
      loading.value = false
    }
  }
  
  const reset = () => {
    data.value = initialData
    loading.value = false
    error.value = null
  }
  
  if (immediate) {
    nextTick(execute)
  }
  
  return {
    data,
    loading,
    error,
    execute,
    reset
  }
}

// ä½¿ç”¨ç¤ºä¾‹
interface User {
  id: number
  name: string
  email: string
}

const { data: userData, loading, error, execute } = useAsyncState<User>(
  () => fetch('/api/user').then(res => res.json()),
  {
    onSuccess: (user) => {
      console.log(`User ${user.name} loaded`) // user ç±»å‹ä¸º User
    },
    onError: (err) => {
      console.error('Failed to load user:', err.message)
    }
  }
)
```



### å¤æ‚ Composable å‡½æ•°ç±»å‹æ¨å¯¼

```typescript
// è¡¨å•éªŒè¯ Composable
type ValidationRule<T> = (value: T) => string | null

interface UseFormFieldOptions<T> {
  initialValue: T
  rules?: ValidationRule<T>[]
  validateOnChange?: boolean
  validateOnBlur?: boolean
}

interface UseFormFieldReturn<T> {
  value: Ref<T>
  error: Ref<string | null>
  isValid: ComputedRef<boolean>
  isDirty: ComputedRef<boolean>
  isTouched: Ref<boolean>
  validate: () => boolean
  reset: () => void
  setValue: (newValue: T) => void
}

function useFormField<T>(
  options: UseFormFieldOptions<T>
): UseFormFieldReturn<T> {
  const {
    initialValue,
    rules = [],
    validateOnChange = false,
    validateOnBlur = true
  } = options
  
  const value = ref<T>(initialValue)
  const error = ref<string | null>(null)
  const isTouched = ref(false)
  const initialValueRef = ref<T>(initialValue)
  
  const isValid = computed(() => error.value === null)
  const isDirty = computed(() => value.value !== initialValueRef.value)
  
  const validate = (): boolean => {
    for (const rule of rules) {
      const result = rule(value.value)
      if (result) {
        error.value = result
        return false
      }
    }
    error.value = null
    return true
  }
  
  const setValue = (newValue: T) => {
    value.value = newValue
    if (validateOnChange) {
      validate()
    }
  }
  
  const reset = () => {
    value.value = initialValueRef.value
    error.value = null
    isTouched.value = false
  }
  
  const handleBlur = () => {
    isTouched.value = true
    if (validateOnBlur) {
      validate()
    }
  }
  
  // ç›‘å¬å€¼å˜åŒ–
  watch(value, () => {
    if (validateOnChange && isTouched.value) {
      validate()
    }
  })
  
  return {
    value,
    error,
    isValid,
    isDirty,
    isTouched,
    validate,
    reset,
    setValue
  }
}

// å¤åˆè¡¨å• Composable
interface FormField<T = any> {
  value: Ref<T>
  error: Ref<string | null>
  isValid: ComputedRef<boolean>
  validate: () => boolean
  reset: () => void
}

type FormFields<T extends Record<string, any>> = {
  [K in keyof T]: FormField<T[K]>
}

interface UseFormReturn<T extends Record<string, any>> {
  fields: FormFields<T>
  isValid: ComputedRef<boolean>
  isDirty: ComputedRef<boolean>
  values: ComputedRef<T>
  errors: ComputedRef<Partial<Record<keyof T, string>>>
  validate: () => boolean
  reset: () => void
  submit: (onSubmit: (values: T) => void | Promise<void>) => Promise<void>
}

function useForm<T extends Record<string, any>>(
  fieldDefinitions: {
    [K in keyof T]: UseFormFieldOptions<T[K]>
  }
): UseFormReturn<T> {
  const fields = {} as FormFields<T>
  
  // åˆ›å»ºæ‰€æœ‰å­—æ®µ
  for (const [fieldName, options] of Object.entries(fieldDefinitions)) {
    fields[fieldName as keyof T] = useFormField(options as any)
  }
  
  const isValid = computed(() =>
    Object.values(fields).every((field: any) => field.isValid.value)
  )
  
  const isDirty = computed(() =>
    Object.values(fields).some((field: any) => field.isDirty.value)
  )
  
  const values = computed(() => {
    const result = {} as T
    for (const [key, field] of Object.entries(fields)) {
      result[key as keyof T] = (field as any).value.value
    }
    return result
  })
  
  const errors = computed(() => {
    const result: Partial<Record<keyof T, string>> = {}
    for (const [key, field] of Object.entries(fields)) {
      const errorValue = (field as any).error.value
      if (errorValue) {
        result[key as keyof T] = errorValue
      }
    }
    return result
  })
  
  const validate = (): boolean => {
    return Object.values(fields).every((field: any) => field.validate())
  }
  
  const reset = () => {
    Object.values(fields).forEach((field: any) => field.reset())
  }
  
  const submit = async (onSubmit: (values: T) => void | Promise<void>) => {
    if (validate()) {
      await onSubmit(values.value)
    }
  }
  
  return {
    fields,
    isValid,
    isDirty,
    values,
    errors,
    validate,
    reset,
    submit
  }
}

// ä½¿ç”¨ç¤ºä¾‹
interface LoginForm {
  username: string
  password: string
  rememberMe: boolean
}

const loginForm = useForm<LoginForm>({
  username: {
    initialValue: '',
    rules: [
      (value) => !value ? 'Username is required' : null,
      (value) => value.length < 3 ? 'Username must be at least 3 characters' : null
    ],
    validateOnChange: true
  },
  password: {
    initialValue: '',
    rules: [
      (value) => !value ? 'Password is required' : null,
      (value) => value.length < 6 ? 'Password must be at least 6 characters' : null
    ]
  },
  rememberMe: {
    initialValue: false
  }
})
```





## Vue é¡¹ç›®ä¸­çš„é«˜çº§ç±»å‹æŠ€å·§ä¸æœ€ä½³å®è·µ

### ç±»å‹å·¥å…·å‡½æ•°å’Œç±»å‹ä½“æ“

```typescript
// æ·±åº¦åªè¯»ç±»å‹
type DeepReadonly<T> = {
  readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P]
}

// æ·±åº¦å¯é€‰ç±»å‹
type DeepPartial<T> = {
  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P]
}

// æ·±åº¦å¿…é€‰ç±»å‹
type DeepRequired<T> = {
  [P in keyof T]-?: T[P] extends object ? DeepRequired<T[P]> : T[P]
}

// æå–å‡½æ•°è¿”å›ç±»å‹çš„ Promise å€¼
type PromiseType<T> = T extends Promise<infer U> ? U : T

// ç»„ä»¶å®ä¾‹ç±»å‹æå–
type ComponentInstance<T> = T extends new (...args: any) => infer R ? R : never

// æå– Props ç±»å‹
type ExtractPropTypes<T> = {
  [K in keyof T]: T[K] extends { type: infer U }
    ? U extends new (...args: any) => infer R
      ? R
      : U
    : any
}

// äº‹ä»¶å¤„ç†å™¨ç±»å‹
type EventHandlers<T> = {
  [K in keyof T as K extends string ? `on${Capitalize<K>}` : never]?: (
    payload: T[K]
  ) => void
}

// ä½¿ç”¨ç¤ºä¾‹
interface UserEvents {
  login: { username: string; timestamp: Date }
  logout: { reason: string }
  profileUpdate: { changes: Partial<User> }
}

type UserEventHandlers = EventHandlers<UserEvents>
// ç»“æœï¼š
// {
//   onLogin?: (payload: { username: string; timestamp: Date }) => void
//   onLogout?: (payload: { reason: string }) => void
//   onProfileUpdate?: (payload: { changes: Partial<User> }) => void
// }
```



### é«˜çº§ç»„ä»¶ç±»å‹æ¨¡å¼

```typescript
// é«˜é˜¶ç»„ä»¶ç±»å‹å®šä¹‰
type HOCComponent<P = {}> = <T extends ComponentOptions>(
  WrappedComponent: T
) => DefineComponent<P & ExtractPropTypes<T['props']>>

// æ’æ§½ç±»å‹å®‰å…¨
interface TableSlots<T = any> {
  header?: (props: { columns: string[] }) => VNode[]
  row?: (props: { item: T; index: number }) => VNode[]
  footer?: (props: { total: number }) => VNode[]
}

const DataTable = defineComponent({
  props: {
    data: {
      type: Array as PropType<any[]>,
      required: true
    },
    columns: {
      type: Array as PropType<string[]>,
      required: true
    }
  },
  setup(props, { slots }) {
    return () => (
      <div class="data-table">
        <div class="table-header">
          {slots.header?.({ columns: props.columns })}
        </div>
        <div class="table-body">
          {props.data.map((item, index) => (
            <div key={index} class="table-row">
              {slots.row?.({ item, index })}
            </div>
          ))}
        </div>
        <div class="table-footer">
          {slots.footer?.({ total: props.data.length })}
        </div>
      </div>
    )
  }
})

// æ¡ä»¶ç±»å‹ç»„ä»¶
type ConditionalComponent<T extends boolean> = T extends true
  ? DefineComponent<{ required: true }>
  : DefineComponent<{ required?: false }>

function createConditionalComponent<T extends boolean>(
  required: T
): ConditionalComponent<T> {
  return defineComponent({
    props: {
      required: {
        type: Boolean,
        default: required
      }
    }
  }) as any
}
```



### çŠ¶æ€ç®¡ç†ç±»å‹æ¨¡å¼

```typescript
// çŠ¶æ€ç®¡ç†å™¨ç±»å‹å®šä¹‰
interface StoreState {
  user: User | null
  settings: AppSettings
  ui: UIState
}

interface StoreGetters {
  isAuthenticated: boolean
  userDisplayName: string
  themeMode: 'light' | 'dark'
}

interface StoreMutations {
  setUser: (user: User | null) => void
  updateSettings: (settings: Partial<AppSettings>) => void
  toggleTheme: () => void
}

interface StoreActions {
  login: (credentials: LoginCredentials) => Promise<User>
  logout: () => Promise<void>
  fetchUserProfile: () => Promise<User>
}

// ç±»å‹å®‰å…¨çš„ Store å·¥å‚
function createTypedStore<
  State extends Record<string, any>,
  Getters extends Record<string, any>,
  Mutations extends Record<string, (...args: any[]) => void>,
  Actions extends Record<string, (...args: any[]) => any>
>(config: {
  state: () => State
  getters: {
    [K in keyof Getters]: (state: State) => Getters[K]
  }
  mutations: {
    [K in keyof Mutations]: (state: State, ...args: Parameters<Mutations[K]>) => void
  }
  actions: {
    [K in keyof Actions]: (context: {
      state: State
      getters: Getters
      commit: <T extends keyof Mutations>(
        type: T,
        ...payload: Parameters<Mutations[T]>
      ) => void
    }, ...args: Parameters<Actions[K]>) => ReturnType<Actions[K]>
  }
}) {
  // Store å®ç°é€»è¾‘
  return config
}

// ä½¿ç”¨ç±»å‹å®‰å…¨çš„ Store
const store = createTypedStore({
  state: (): StoreState => ({
    user: null,
    settings: {
      theme: 'light',
      language: 'en'
    },
    ui: {
      sidebarOpen: false,
      loading: false
    }
  }),
  getters: {
    isAuthenticated: (state) => state.user !== null,
    userDisplayName: (state) => state.user?.name || 'Guest',
    themeMode: (state) => state.settings.theme
  },
  mutations: {
    setUser: (state, user) => {
      state.user = user
    },
    updateSettings: (state, settings) => {
      Object.assign(state.settings, settings)
    },
    toggleTheme: (state) => {
      state.settings.theme = state.settings.theme === 'light' ? 'dark' : 'light'
    }
  },
  actions: {
    async login({ commit }, credentials) {
      const response = await fetch('/api/login', {
        method: 'POST',
        body: JSON.stringify(credentials)
      })
      const user = await response.json()
      commit('setUser', user)
      return user
    },
    async logout({ commit }) {
      await fetch('/api/logout', { method: 'POST' })
      commit('setUser', null)
    },
    async fetchUserProfile({ commit }) {
      const response = await fetch('/api/user/profile')
      const user = await response.json()
      commit('setUser', user)
      return user
    }
  }
})
```



##  è¯¦è§£ Vue 3 çš„ç±»å‹æ¨å¯¼æœºåˆ¶åŠå…¶å±€é™æ€§

###  æ¨¡æ¿å¼•ç”¨çš„ç±»å‹æ¨å¯¼

```typescript
// æ¨¡æ¿å¼•ç”¨ç±»å‹æ¨å¯¼
const MyComponent = defineComponent({
  setup() {
    // åŸºç¡€å…ƒç´ å¼•ç”¨
    const inputRef = ref<HTMLInputElement>()
    const divRef = ref<HTMLDivElement>()
    
    // ç»„ä»¶å¼•ç”¨
    const childComponentRef = ref<InstanceType<typeof ChildComponent>>()
    
    // è‡ªåŠ¨ç±»å‹æ¨å¯¼çš„é™åˆ¶
    const autoRef = ref() // ç±»å‹ä¸º Ref<any>
    
    onMounted(() => {
      // éœ€è¦ç±»å‹æ–­è¨€æˆ–æ£€æŸ¥
      if (inputRef.value) {
        inputRef.value.focus() // ç±»å‹å®‰å…¨
      }
      
      // ç»„ä»¶æ–¹æ³•è°ƒç”¨
      childComponentRef.value?.someMethod()
    })
    
    return {
      inputRef,
      divRef,
      childComponentRef
    }
  }
})

// æ¨¡æ¿ä¸­çš„ä½¿ç”¨
/*
<template>
  <input ref="inputRef" />
  <div ref="divRef">Content</div>
  <ChildComponent ref="childComponentRef" />
</template>
*/
```

### 5.2 äº‹ä»¶å¤„ç†å™¨ç±»å‹æ¨å¯¼

```typescript
// äº‹ä»¶å¤„ç†çš„ç±»å‹æ¨å¯¼é™åˆ¶
const EventComponent = defineComponent({
  emits: {
    // æ˜ç¡®çš„äº‹ä»¶ç±»å‹å®šä¹‰
    update: (value: string) => typeof value === 'string',
    change: (event: { old: number; new: number }) => true,
    click: (event: MouseEvent) => true
  },
  setup(props, { emit }) {
    // ç±»å‹å®‰å…¨çš„äº‹ä»¶å‘å°„
    const handleUpdate = (value: string) => {
      emit('update', value) // ç±»å‹æ£€æŸ¥é€šè¿‡
      // emit('update', 123) // ç±»å‹é”™è¯¯
    }
    
    const handleChange = (oldVal: number, newVal: number) => {
      emit('change', { old: oldVal, new: newVal })
    }
    
    const handleClick = (event: MouseEvent) => {
      emit('click', event)
    }
    
    return {
      handleUpdate,
      handleChange,
      handleClick
    }
  }
})

// çˆ¶ç»„ä»¶ä¸­çš„äº‹ä»¶ç›‘å¬
const ParentComponent = defineComponent({
  components: { EventComponent },
  setup() {
    const onUpdate = (value: string) => {
      console.log('Updated:', value) // value è‡ªåŠ¨æ¨å¯¼ä¸º string
    }
    
    const onChange = (event: { old: number; new: number }) => {
      console.log('Changed:', event) // event ç±»å‹æ­£ç¡®æ¨å¯¼
    }
    
    return {
      onUpdate,
      onChange
    }
  }
})
```

### 5.3 ç±»å‹æ¨å¯¼çš„å±€é™æ€§å’Œè§£å†³æ–¹æ¡ˆ

```typescript
// å±€é™æ€§1ï¼šå¤æ‚æ³›å‹æ¨å¯¼
// é—®é¢˜ï¼šæ·±å±‚åµŒå¥—çš„æ³›å‹ç±»å‹æ¨å¯¼ä¸å‡†ç¡®
interface ApiResponse<T> {
  data: T
  status: number
  message: string
}

// ä¸å¤Ÿå‡†ç¡®çš„æ¨å¯¼
const useApi = <T>() => {
  const data = ref<T>()
  const loading = ref(false)
  
  const fetch = async (url: string): Promise<ApiResponse<T>> => {
    loading.value = true
    try {
      const response = await window.fetch(url)
      const result = await response.json()
      data.value = result.data // ç±»å‹æ¨å¯¼å¯èƒ½ä¸å‡†ç¡®
      return result
    } finally {
      loading.value = false
    }
  }
  
  return { data, loading, fetch }
}

// è§£å†³æ–¹æ¡ˆï¼šæ˜¾å¼ç±»å‹çº¦æŸ
const useTypedApi = <T>() => {
  const data = ref<T | undefined>(undefined)
  const loading = ref(false)
  const error = ref<Error | null>(null)
  
  const fetch = async (url: string): Promise<ApiResponse<T>> => {
    loading.value = true
    error.value = null
    
    try {
      const response = await window.fetch(url)
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`)
      }
      
      const result: ApiResponse<T> = await response.json()
      data.value = result.data // ç°åœ¨ç±»å‹å®‰å…¨
      return result
    } catch (err) {
      const errorObj = err instanceof Error ? err : new Error(String(err))
      error.value = errorObj
      throw errorObj
    } finally {
      loading.value = false
    }
  }
  
  return { data: readonly(data), loading: readonly(loading), error: readonly(error), fetch }
}

// å±€é™æ€§2ï¼šæ¨¡æ¿ä¸­çš„ç±»å‹æ¨å¯¼
// é—®é¢˜ï¼šæ¨¡æ¿ä¸­æ— æ³•è¿›è¡Œå¤æ‚çš„ç±»å‹æ£€æŸ¥
const ComplexComponent = defineComponent({
  props: {
    items: {
      type: Array as PropType<Array<{ id: number; name: string; metadata?: any }>>,
      required: true
    }
  },
  setup(props) {
    // åœ¨ setup ä¸­ç±»å‹æ¨å¯¼æ­£å¸¸
    const processedItems = computed(() => {
      return props.items.map(item => ({
        ...item,
        displayName: item.name.toUpperCase(), // ç±»å‹å®‰å…¨
        hasMetadata: !!item.metadata
      }))
    })
    
    // ä½†åœ¨æ¨¡æ¿ä¸­ç±»å‹æ£€æŸ¥æœ‰é™
    return {
      processedItems
    }
  }
})

// å±€é™æ€§3ï¼šåŠ¨æ€ç»„ä»¶ç±»å‹æ¨å¯¼
// é—®é¢˜ï¼šåŠ¨æ€ç»„ä»¶æ— æ³•è·å¾—å‡†ç¡®çš„ç±»å‹æ¨å¯¼
const DynamicWrapper = defineComponent({
  props: {
    component: {
      type: [String, Object] as PropType<string | Component>,
      required: true
    },
    componentProps: {
      type: Object as PropType<Record<string, any>>,
      default: () => ({})
    }
  },
  setup(props) {
    // æ— æ³•è·å¾— component çš„å…·ä½“ç±»å‹ä¿¡æ¯
    return () => h(props.component, props.componentProps)
  }
})

// è§£å†³æ–¹æ¡ˆï¼šç±»å‹åŒ–çš„åŠ¨æ€ç»„ä»¶å·¥å‚
interface ComponentMap {
  button: typeof ButtonComponent
  input: typeof InputComponent
  select: typeof SelectComponent
}

type ComponentKey = keyof ComponentMap
type ComponentProps<K extends ComponentKey> = ComponentMap[K] extends 
  DefineComponent<infer P> ? P : never

function createTypedDynamicComponent<K extends ComponentKey>(
  componentKey: K,
  props: ComponentProps<K>
) {
  const componentMap: ComponentMap = {
    button: ButtonComponent,
    input: InputComponent,
    select: SelectComponent
  }
  
  return h(componentMap[componentKey], props)
}

// å±€é™æ€§4ï¼šæ’æ§½ç±»å‹æ¨å¯¼
// é—®é¢˜ï¼šæ’æ§½å†…å®¹çš„ç±»å‹æ¨å¯¼ä¸å¤Ÿç²¾ç¡®
interface SlotProps {
  user: User
  index: number
  isSelected: boolean
}

const ListComponent = defineComponent({
  props: {
    users: {
      type: Array as PropType<User[]>,
      required: true
    }
  },
  setup(props, { slots }) {
    return () => (
      <div>
        {props.users.map((user, index) => (
          <div key={user.id}>
            {slots.default?.({
              user,
              index,
              isSelected: false
            } as SlotProps)}
          </div>
        ))}
      </div>
    )
  }
})

// è§£å†³æ–¹æ¡ˆï¼šæ˜¾å¼çš„æ’æ§½ç±»å‹å®šä¹‰
interface TypedSlots {
  default: (props: SlotProps) => VNode[]
  header: (props: { total: number }) => VNode[]
  footer: (props: { hasMore: boolean }) => VNode[]
}

const TypedListComponent = defineComponent({
  props: {
    users: {
      type: Array as PropType<User[]>,
      required: true
    }
  },
  setup(props, { slots }: SetupContext<{}, TypedSlots>) {
    return () => (
      <div>
        {slots.header?.({ total: props.users.length })}
        {props.users.map((user, index) => (
          <div key={user.id}>
            {slots.default?.({
              user,
              index,
              isSelected: false
            })}
          </div>
        ))}
        {slots.footer?.({ hasMore: false })}
      </div>
    )
  }
})
```





## Vue ä¸ TypeScript ç»“åˆçš„é«˜çº§æ¨¡å¼

### 6.1 ä¾èµ–æ³¨å…¥çš„ç±»å‹å®‰å…¨

```typescript
// ç±»å‹å®‰å…¨çš„ä¾èµ–æ³¨å…¥ç³»ç»Ÿ
interface InjectionKey<T> extends Symbol {}

function createInjectionKey<T>(description: string): InjectionKey<T> {
  return Symbol(description) as InjectionKey<T>
}

// å®šä¹‰æœåŠ¡æ¥å£
interface ApiService {
  get<T>(url: string): Promise<T>
  post<T>(url: string, data: any): Promise<T>
  put<T>(url: string, data: any): Promise<T>
  delete(url: string): Promise<void>
}

interface AuthService {
  login(credentials: LoginCredentials): Promise<User>
  logout(): Promise<void>
  getCurrentUser(): User | null
  isAuthenticated(): boolean
}

interface NotificationService {
  success(message: string): void
  error(message: string): void
  warning(message: string): void
  info(message: string): void
}

// åˆ›å»ºæ³¨å…¥é”®
const API_SERVICE_KEY = createInjectionKey<ApiService>('api-service')
const AUTH_SERVICE_KEY = createInjectionKey<AuthService>('auth-service')
const NOTIFICATION_SERVICE_KEY = createInjectionKey<NotificationService>('notification-service')

// æœåŠ¡å®ç°
class ApiServiceImpl implements ApiService {
  private baseURL: string
  
  constructor(baseURL: string) {
    this.baseURL = baseURL
  }
  
  async get<T>(url: string): Promise<T> {
    const response = await fetch(`${this.baseURL}${url}`)
    return response.json()
  }
  
  async post<T>(url: string, data: any): Promise<T> {
    const response = await fetch(`${this.baseURL}${url}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data)
    })
    return response.json()
  }
  
  async put<T>(url: string, data: any): Promise<T> {
    const response = await fetch(`${this.baseURL}${url}`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data)
    })
    return response.json()
  }
  
  async delete(url: string): Promise<void> {
    await fetch(`${this.baseURL}${url}`, {
      method: 'DELETE'
    })
  }
}

class AuthServiceImpl implements AuthService {
  private currentUser: User | null = null
  
  async login(credentials: LoginCredentials): Promise<User> {
    // ç™»å½•é€»è¾‘
    const user = await fetch('/api/login', {
      method: 'POST',
      body: JSON.stringify(credentials)
    }).then(res => res.json())
    
    this.currentUser = user
    return user
  }
  
  async logout(): Promise<void> {
    await fetch('/api/logout', { method: 'POST' })
    this.currentUser = null
  }
  
  getCurrentUser(): User | null {
    return this.currentUser
  }
  
  isAuthenticated(): boolean {
    return this.currentUser !== null
  }
}

// æœåŠ¡æä¾›è€…ç»„ä»¶
const ServiceProvider = defineComponent({
  name: 'ServiceProvider',
  setup(_, { slots }) {
    // åˆ›å»ºæœåŠ¡å®ä¾‹
    const apiService = new ApiServiceImpl('/api')
    const authService = new AuthServiceImpl()
    const notificationService = {
      success: (msg: string) => console.log('âœ“', msg),
      error: (msg: string) => console.error('âœ—', msg),
      warning: (msg: string) => console.warn('âš ', msg),
      info: (msg: string) => console.info('â„¹', msg)
    }
    
    // æä¾›æœåŠ¡
    provide(API_SERVICE_KEY, apiService)
    provide(AUTH_SERVICE_KEY, authService)
    provide(NOTIFICATION_SERVICE_KEY, notificationService)
    
    return () => slots.default?.()
  }
})

// ç±»å‹å®‰å…¨çš„æœåŠ¡æ³¨å…¥ Hook
function useService<T>(key: InjectionKey<T>): T {
  const service = inject(key)
  if (!service) {
    throw new Error(`Service not provided: ${key.toString()}`)
  }
  return service
}

// å¯é€‰æœåŠ¡æ³¨å…¥
function useOptionalService<T>(key: InjectionKey<T>): T | undefined {
  return inject(key)
}

// å¸¦é»˜è®¤å€¼çš„æœåŠ¡æ³¨å…¥
function useServiceWithDefault<T>(key: InjectionKey<T>, defaultValue: T): T {
  return inject(key, defaultValue)
}

// åœ¨ç»„ä»¶ä¸­ä½¿ç”¨æœåŠ¡
const UserProfile = defineComponent({
  setup() {
    const apiService = useService(API_SERVICE_KEY)
    const authService = useService(AUTH_SERVICE_KEY)
    const notificationService = useService(NOTIFICATION_SERVICE_KEY)
    
    const user = ref<User | null>(null)
    const loading = ref(false)
    
    const loadUserProfile = async () => {
      try {
        loading.value = true
        const currentUser = authService.getCurrentUser()
        if (currentUser) {
          user.value = await apiService.get<User>(`/users/${currentUser.id}`)
          notificationService.success('Profile loaded successfully')
        }
      } catch (error) {
        notificationService.error('Failed to load profile')
        console.error(error)
      } finally {
        loading.value = false
      }
    }
    
    const updateProfile = async (updates: Partial<User>) => {
      if (!user.value) return
      
      try {
        const updatedUser = await apiService.put<User>(
          `/users/${user.value.id}`,
          updates
        )
        user.value = updatedUser
        notificationService.success('Profile updated successfully')
      } catch (error) {
        notificationService.error('Failed to update profile')
        console.error(error)
      }
    }
    
    onMounted(loadUserProfile)
    
    return {
      user,
      loading,
      updateProfile,
      loadUserProfile
    }
  }
})
```

### 6.2 æ’ä»¶ç³»ç»Ÿçš„ç±»å‹å®‰å…¨

```typescript
// æ’ä»¶æ¥å£å®šä¹‰
interface Plugin<T = any> {
  name: string
  version: string
  install(app: App, options?: T): void
  uninstall?(app: App): void
}

// æ’ä»¶é…ç½®ç±»å‹
interface PluginConfig<T> {
  plugin: Plugin<T>
  options?: T
  enabled?: boolean
}

// ç±»å‹å®‰å…¨çš„æ’ä»¶ç®¡ç†å™¨
class PluginManager {
  private plugins = new Map<string, Plugin>()
  private installedPlugins = new Set<string>()
  
  register<T>(plugin: Plugin<T>, options?: T): void {
    if (this.plugins.has(plugin.name)) {
      throw new Error(`Plugin ${plugin.name} is already registered`)
    }
    
    this.plugins.set(plugin.name, plugin)
  }
  
  install<T>(app: App, pluginName: string, options?: T): void {
    const plugin = this.plugins.get(pluginName)
    if (!plugin) {
      throw new Error(`Plugin ${pluginName} is not registered`)
    }
    
    if (this.installedPlugins.has(pluginName)) {
      console.warn(`Plugin ${pluginName} is already installed`)
      return
    }
    
    plugin.install(app, options)
    this.installedPlugins.add(pluginName)
  }
  
  uninstall(app: App, pluginName: string): void {
    const plugin = this.plugins.get(pluginName)
    if (!plugin || !this.installedPlugins.has(pluginName)) {
      return
    }
    
    plugin.uninstall?.(app)
    this.installedPlugins.delete(pluginName)
  }
  
  isInstalled(pluginName: string): boolean {
    return this.installedPlugins.has(pluginName)
  }
  
  getInstalledPlugins(): string[] {
    return Array.from(this.installedPlugins)
  }
}

// å…·ä½“æ’ä»¶å®ç°
interface ToastOptions {
  duration?: number
  position?: 'top' | 'bottom' | 'center'
  theme?: 'light' | 'dark'
}

const ToastPlugin: Plugin<ToastOptions> = {
  name: 'toast',
  version: '1.0.0',
  install(app, options = {}) {
    const defaultOptions: ToastOptions = {
      duration: 3000,
      position: 'top',
      theme: 'light'
    }
    
    const mergedOptions = { ...defaultOptions, ...options }
    
    const toast = {
      show(message: string, type: 'success' | 'error' | 'warning' | 'info' = 'info') {
        // Toast å®ç°é€»è¾‘
        console.log(`[${type.toUpperCase()}] ${message}`)
      },
      success(message: string) {
        this.show(message, 'success')
      },
      error(message: string) {
        this.show(message, 'error')
      },
      warning(message: string) {
        this.show(message, 'warning')
      },
      info(message: string) {
        this.show(message, 'info')
      }
    }
    
    app.config.globalProperties.$toast = toast
    app.provide('toast', toast)
  }
}

// éªŒè¯æ’ä»¶
interface ValidationRule {
  required?: boolean
  minLength?: number
  maxLength?: number
  pattern?: RegExp
  custom?: (value: any) => string | null
}

interface ValidationOptions {
  rules?: Record<string, ValidationRule>
  locale?: string
}

const ValidationPlugin: Plugin<ValidationOptions> = {
  name: 'validation',
  version: '1.0.0',
  install(app, options = {}) {
    const validator = {
      validate(value: any, rules: ValidationRule): string | null {
        if (rules.required && (!value || value === '')) {
          return 'This field is required'
        }
        
        if (rules.minLength && value.length < rules.minLength) {
          return `Minimum length is ${rules.minLength}`
        }
        
        if (rules.maxLength && value.length > rules.maxLength) {
          return `Maximum length is ${rules.maxLength}`
        }
        
        if (rules.pattern && !rules.pattern.test(value)) {
          return 'Invalid format'
        }
        
        if (rules.custom) {
          return rules.custom(value)
        }
        
        return null
      },
      
      validateObject(obj: Record<string, any>, rules: Record<string, ValidationRule>) {
        const errors: Record<string, string> = {}
        
        for (const [field, rule] of Object.entries(rules)) {
          const error = this.validate(obj[field], rule)
          if (error) {
            errors[field] = error
          }
        }
        
        return Object.keys(errors).length > 0 ? errors : null
      }
    }
    
    app.config.globalProperties.$validator = validator
    app.provide('validator', validator)
  }
}

// æ’ä»¶ä½¿ç”¨ç¤ºä¾‹
const pluginManager = new PluginManager()

// æ³¨å†Œæ’ä»¶
pluginManager.register(ToastPlugin)
pluginManager.register(ValidationPlugin)

// åœ¨åº”ç”¨ä¸­å®‰è£…æ’ä»¶
const app = createApp(App)

pluginManager.install(app, 'toast', {
  duration: 5000,
  position: 'bottom',
  theme: 'dark'
})

pluginManager.install(app, 'validation', {
  locale: 'zh-CN'
})

// ç±»å‹å®‰å…¨çš„æ’ä»¶ä½¿ç”¨
const ComponentWithPlugins = defineComponent({
  setup() {
    const toast = inject<typeof ToastPlugin>('toast')
    const validator = inject<typeof ValidationPlugin>('validator')
    
    const handleSubmit = (formData: any) => {
      const errors = validator?.validateObject(formData, {
        name: { required: true, minLength: 2 },
        email: { required: true, pattern: /^[^\s@]+@[^\s@]+\.[^\s@]+$/ }
      })
      
      if (errors) {
        toast?.error('Please fix the validation errors')
      } else {
        toast?.success('Form submitted successfully')
      }
    }
    
    return {
      handleSubmit
    }
  }
})
```

### 6.3 é«˜çº§ç±»å‹å®ˆå«å’Œè¿è¡Œæ—¶ç±»å‹æ£€æŸ¥

```typescript
// ç±»å‹å®ˆå«å‡½æ•°
function isString(value: unknown): value is string {
  return typeof value === 'string'
}

function isNumber(value: unknown): value is number {
  return typeof value === 'number' && !isNaN(value)
}

function isArray<T>(value: unknown, itemGuard: (item: unknown) => item is T): value is T[] {
  return Array.isArray(value) && value.every(itemGuard)
}

function isObject(value: unknown): value is Record<string, unknown> {
  return typeof value === 'object' && value !== null && !Array.isArray(value)
}

// å¤æ‚ç±»å‹å®ˆå«
interface User {
  id: number
  name: string
  email: string
  roles: string[]
  profile?: {
    avatar?: string
    bio?: string
  }
}

function isUser(value: unknown): value is User {
  if (!isObject(value)) return false
  
  const obj = value as Record<string, unknown>
  
  return (
    isNumber(obj.id) &&
    isString(obj.name) &&
    isString(obj.email) &&
    isArray(obj.roles, isString) &&
    (obj.profile === undefined || (
      isObject(obj.profile) &&
      (obj.profile.avatar === undefined || isString(obj.profile.avatar)) &&
      (obj.profile.bio === undefined || isString(obj.profile.bio))
    ))
  )
}

// è¿è¡Œæ—¶ç±»å‹éªŒè¯ Composable
function useTypeGuard<T>(guard: (value: unknown) => value is T) {
  const validate = (value: unknown): T => {
    if (guard(value)) {
      return value
    }
    throw new Error('Type validation failed')
  }
  
  const safeValidate = (value: unknown): T | null => {
    return guard(value) ? value : null
  }
  
  const isValid = (value: unknown): boolean => {
    return guard(value)
  }
  
  return {
    validate,
    safeValidate,
    isValid
  }
}

// API å“åº”ç±»å‹éªŒè¯
interface ApiResponse<T> {
  data: T
  status: number
  message: string
}

function createApiResponseGuard<T>(
  dataGuard: (value: unknown) => value is T
) {
  return (value: unknown): value is ApiResponse<T> => {
    if (!isObject(value)) return false
    
    const obj = value as Record<string, unknown>
    
    return (
      dataGuard(obj.data) &&
      isNumber(obj.status) &&
      isString(obj.message)
    )
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const UserApiComponent = defineComponent({
  setup() {
    const userGuard = useTypeGuard(isUser)
    const userResponseGuard = useTypeGuard(createApiResponseGuard(isUser))
    
    const users = ref<User[]>([])
    const loading = ref(false)
    const error = ref<string | null>(null)
    
    const fetchUsers = async () => {
      try {
        loading.value = true
        error.value = null
        
        const response = await fetch('/api/users')
        const rawData = await response.json()
        
        // è¿è¡Œæ—¶ç±»å‹éªŒè¯
        if (userResponseGuard.isValid(rawData)) {
          const validatedResponse = userResponseGuard.validate(rawData)
          users.value = [validatedResponse.data] // ç±»å‹å®‰å…¨
        } else {
          throw new Error('Invalid API response format')
        }
      } catch (err) {
        error.value = err instanceof Error ? err.message : 'Unknown error'
      } finally {
        loading.value = false
      }
    }
    
    const addUser = (userData: unknown) => {
      const validUser = userGuard.safeValidate(userData)
      if (validUser) {
        users.value.push(validUser)
      } else {
        error.value = 'Invalid user data format'
      }
    }
    
    return {
      users,
      loading,
      error,
      fetchUsers,
      addUser
    }
  }
})
```



## å¤§å‹ Vue+TypeScript é¡¹ç›®çš„ç±»å‹ç»„ç»‡ä¸ç®¡ç†ç­–ç•¥

### 7.1 é¡¹ç›®ç»“æ„å’Œç±»å‹ç»„ç»‡

```typescript
// types/api.ts - API ç›¸å…³ç±»å‹
export interface ApiResponse<T = any> {
  data: T
  status: number
  message: string
  timestamp: string
}

export interface PaginatedResponse<T> extends ApiResponse<T[]> {
  pagination: {
    page: number
    limit: number
    total: number
    hasNext: boolean
    hasPrev: boolean
  }
}

export interface ApiError {
  code: string
  message: string
  details?: Record<string, any>
}

// types/user.ts - ç”¨æˆ·ç›¸å…³ç±»å‹
export interface User {
  id: number
  username: string
  email: string
  firstName: string
  lastName: string
  avatar?: string
  roles: Role[]
  createdAt: string
  updatedAt: string
}

export interface CreateUserRequest {
  username: string
  email: string
  firstName: string
  lastName: string
  password: string
  roleIds: number[]
}

export interface UpdateUserRequest extends Partial<Omit<CreateUserRequest, 'password'>> {
  currentPassword?: string
  newPassword?: string
}

export interface UserProfile extends Omit<User, 'roles'> {
  bio?: string
  location?: string
  website?: string
  socialLinks?: {
    twitter?: string
    github?: string
    linkedin?: string
  }
}

// types/auth.ts - è®¤è¯ç›¸å…³ç±»å‹
export interface LoginCredentials {
  email: string
  password: string
  rememberMe?: boolean
}

export interface AuthTokens {
  accessToken: string
  refreshToken: string
  expiresIn: number
}

export interface AuthUser extends User {
  permissions: Permission[]
}

// types/common.ts - é€šç”¨ç±»å‹
export type ID = string | number

export interface BaseEntity {
  id: ID
  createdAt: string
  updatedAt: string
}

export interface SelectOption<T = any> {
  label: string
  value: T
  disabled?: boolean
  group?: string
}

export type SortDirection = 'asc' | 'desc'

export interface SortConfig<T = string> {
  field: T
  direction: SortDirection
}

export interface FilterConfig<T = any> {
  field: string
  operator: 'eq' | 'ne' | 'gt' | 'gte' | 'lt' | 'lte' | 'like' | 'in' | 'not_in'
  value: T
}

// types/components.ts - ç»„ä»¶ç›¸å…³ç±»å‹
export interface TableColumn<T = any> {
  key: keyof T | string
  title: string
  width?: number
  sortable?: boolean
  filterable?: boolean
  render?: (value: any, record: T, index: number) => VNode | string
}

export interface FormField<T = any> {
  name: keyof T
  label: string
  type: 'text' | 'email' | 'password' | 'number' | 'select' | 'textarea' | 'checkbox'
  required?: boolean
  rules?: ValidationRule[]
  options?: SelectOption[]
  placeholder?: string
  disabled?: boolean
}

export interface ModalConfig {
  title: string
  width?: number | string
  maskClosable?: boolean
  destroyOnClose?: boolean
  footer?: boolean
}
```

### 7.2 ç±»å‹ç”Ÿæˆå’Œä»£ç ç”Ÿæˆ

```typescript
// scripts/generate-types.ts - ä» API Schema ç”Ÿæˆç±»å‹
import { writeFileSync } from 'fs'
import { resolve } from 'path'

interface ApiSchema {
  paths: Record<string, {
    get?: ApiEndpoint
    post?: ApiEndpoint
    put?: ApiEndpoint
    delete?: ApiEndpoint
  }>
  components: {
    schemas: Record<string, SchemaDefinition>
  }
}

interface ApiEndpoint {
  summary: string
  parameters?: Parameter[]
  requestBody?: RequestBody
  responses: Record<string, Response>
}

interface SchemaDefinition {
  type: string
  properties?: Record<string, PropertyDefinition>
  required?: string[]
}

interface PropertyDefinition {
  type: string
  format?: string
  items?: PropertyDefinition
  $ref?: string
}

class TypeGenerator {
  private schema: ApiSchema
  
  constructor(schema: ApiSchema) {
    this.schema = schema
  }
  
  generateTypes(): string {
    let output = '// Auto-generated types from API schema\n\n'
    
    // ç”ŸæˆåŸºç¡€æ¥å£
    for (const [name, definition] of Object.entries(this.schema.components.schemas)) {
      output += this.generateInterface(name, definition)
      output += '\n\n'
    }
    
    // ç”Ÿæˆ API ç±»å‹
    output += this.generateApiTypes()
    
    return output
  }
  
  private generateInterface(name: string, definition: SchemaDefinition): string {
    let interfaceStr = `export interface ${this.capitalize(name)} {\n`
    
    if (definition.properties) {
      for (const [propName, propDef] of Object.entries(definition.properties)) {
        const isRequired = definition.required?.includes(propName) ?? false
        const propType = this.getTypeFromDefinition(propDef)
        const optional = isRequired ? '' : '?'
        
        interfaceStr += `  ${propName}${optional}: ${propType}\n`
      }
    }
    
    interfaceStr += '}'
    return interfaceStr
  }
  
  private getTypeFromDefinition(def: PropertyDefinition): string {
    switch (def.type) {
      case 'string':
        return 'string'
      case 'number':
      case 'integer':
        return 'number'
      case 'boolean':
        return 'boolean'
      case 'array':
        if (def.items) {
          return `${this.getTypeFromDefinition(def.items)}[]`
        }
        return 'any[]'
      case 'object':
        return 'Record<string, any>'
      default:
        if (def.$ref) {
          const refName = def.$ref.split('/').pop()
          return this.capitalize(refName || 'any')
        }
        return 'any'
    }
  }
  
  private generateApiTypes(): string {
    let apiTypes = '// API endpoint types\n'
    
    for (const [path, methods] of Object.entries(this.schema.paths)) {
      const pathName = this.pathToTypeName(path)
      
      for (const [method, endpoint] of Object.entries(methods)) {
        if (endpoint) {
          apiTypes += this.generateEndpointTypes(pathName, method, endpoint)
        }
      }
    }
    
    return apiTypes
  }
  
  private generateEndpointTypes(pathName: string, method: string, endpoint: ApiEndpoint): string {
    const typeName = `${this.capitalize(method)}${pathName}`
    let types = ''
    
    // Request type
    if (endpoint.requestBody) {
      types += `export interface ${typeName}Request {\n`
      // Generate request body type
      types += '  // TODO: Generate from request body schema\n'
      types += '}\n\n'
    }
    
    // Response type
    types += `export interface ${typeName}Response {\n`
    // Generate response type
    types += '  // TODO: Generate from response schema\n'
    types += '}\n\n'
    
    return types
  }
  
  private pathToTypeName(path: string): string {
    return path
      .split('/')
      .filter(segment => segment && !segment.startsWith('{'))
      .map(segment => this.capitalize(segment))
      .join('')
  }
  
  private capitalize(str: string): string {
    return str.charAt(0).toUpperCase() + str.slice(1)
  }
}

// ä½¿ç”¨ç¤ºä¾‹
async function generateApiTypes() {
  try {
    const response = await fetch('http://localhost:3000/api/schema')
    const schema: ApiSchema = await response.json()
    
    const generator = new TypeGenerator(schema)
    const types = generator.generateTypes()
    
    writeFileSync(
      resolve(__dirname, '../src/types/generated.ts'),
      types,
      'utf-8'
    )
    
    console.log('Types generated successfully!')
  } catch (error) {
    console.error('Failed to generate types:', error)
  }
}
```

